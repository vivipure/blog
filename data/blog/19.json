{
    "title": "Vue 源码学习 (5) - nextTick",
    "excerpt": "写在前面 在平时开发中，我们更新数据后，需要通过 nextTick 的回调中才能获取DOM。 `ts this.value = 1 this.$nextTick(() => { ... }) ` 通过前面的文章我们知道，这是因为 Vue中数...",
    "updated": "2022-07-03 16:43:36 ",
    "created": "2022-07-03 16:43:36 ",
    "avatar": "https://avatars.githubusercontent.com/u/26271337?v=4",
    "id": 19,
    "content": "<h1 id=\"写在前面\">写在前面</h1>\n<p>在平时开发中，我们更新数据后，需要通过 nextTick 的回调中才能获取DOM。</p>\n<pre><code class=\"language-ts\">this.value = 1\nthis.$nextTick(() =&gt; {\n    ...\n})\n</code></pre>\n<p>通过前面的文章我们知道，这是因为 Vue中数据更新后，视图并不是立即更新，而是进入批量更新的队列中，而批量更新的队列也是在 nextTick 的回调，所以当 更新的回调执行完成后，我们操作dom的回调执行时才能正确获取到DOM的状态。</p>\n<p>所以来看看nextTick</p>\n<h1 id=\"nexttick\">nextTick</h1>\n<pre><code class=\"language-ts\">export function nextTick(cb?: (...args: any[]) =&gt; any, ctx?: object) {\n    let _resolve\n    callbacks.push(() =&gt; {\n        if (cb) {\n        cb.call(ctx)\n        } else if (_resolve) {\n        _resolve(ctx)\n        }\n\n    })\n    if (!pending) {\n        pending = true\n        timerFunc()\n    }\n    if (!cb &amp;&amp; typeof Promise !== &#39;undefined&#39;) {\n    return new Promise(resolve =&gt; {\n        _resolve = resolve\n    })\n\n    }\n\n}\n</code></pre>\n<p>nextTick 方法可以将 回调函数推入到 callbacks 数组中，如果未传入 cb， 则会执行 resolve， 保证 nextTick后的 then回调被执行。</p>\n<p>这里会执行 timeFunc 函数</p>\n<pre><code class=\"language-ts\">const p = Promise.resolve()\ntimerFunc = () =&gt; {\n    p.then(flushCallbacks)\n    if (isIOS) setTimeout(noop)\n}\n...\ntimerFunc = () =&gt; {\n    setImmediate(flushCallbacks)\n}\n...\ntimerFunc = () =&gt; {\n    setTimeout(flushCallbacks, 0)\n}\n</code></pre>\n<p>这里做了很多兼容，有使用Promise 的微任务回调版本，也有定时器版本的宏任务版本。</p>\n<p>这里保证nextTick 回调的执行实际在 任务队列中完成，执行 flushCallbacks</p>\n<pre><code class=\"language-ts\">function flushCallbacks() {\n    pending = false\n    const copies = callbacks.slice(0)\n    callbacks.length = 0\n    for (let i = 0; i &lt; copies.length; i++) {\n        copies[i]()\n    }\n}\n</code></pre>\n<p>平时我们使用的 $nextTick 就是 这个逻辑</p>\n<pre><code class=\"language-ts\">Vue.nextTick = nextTick\nVue.prototype.$nextTick = function (fn: (...args: any[]) =&gt; any) {\n    return nextTick(fn, this)\n}\n</code></pre>\n<h1 id=\"总结\">总结</h1>\n<p>通过对 nextTick 的源码学习，我们知道了 Vue 的批量更新是 不是在主线程执行的逻辑里面，而是在任务队列中执行相关的逻辑。</p>\n"
}