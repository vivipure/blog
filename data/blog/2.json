{
    "title": "Webpack 5 的变化",
    "excerpt": "现代前端开发都讲究模块化开发，作为打包界的扛把子，Webpack对与整个前端生态有着巨大的影响。但是随着Vite,ESBuild等后起之秀的崛起，webpack本身存在的问题就愈发明显。无论是繁琐的配置文件，还是奇慢无比的构建速度都令人望而...",
    "updated": "2022-10-20 13:50:21 ",
    "created": "2022-05-10 15:31:41 ",
    "avatar": "https://avatars.githubusercontent.com/u/26271337?v=4",
    "id": 2,
    "content": "<p>现代前端开发都讲究模块化开发，作为打包界的扛把子，Webpack对与整个前端生态有着巨大的影响。但是随着Vite,ESBuild等后起之秀的崛起，webpack本身存在的问题就愈发明显。无论是繁琐的配置文件，还是奇慢无比的构建速度都令人望而却步。 </p>\n<p>Webpack官方也知道自身的问题，于是Webpack 5 来了</p>\n<h1 id=\"1-它的变化\">1. 它的变化</h1>\n<p>版本来到了5，Webpack有了以下这些变化：</p>\n<h2 id=\"11-基于文件系统的缓存\">1.1 基于文件系统的缓存</h2>\n<pre><code class=\"language-jsx\">{\n    cache: &quot;filesystem&quot;\n}\n</code></pre>\n<p>新增的缓存的功能让开发者在首次构建后享受缓存带来的构建速度提升（是的，首次还是很慢），实际测试后，无论是直接构建还是热更新开发，首次之后的重新构建时间只有几秒，热更新甚至少于1s.</p>\n<p>开启了这个功能之后，会在<code>node_modules</code>文件下多一个<code>.cache</code>的文件夹，里面会存放之前构建产生的缓存。但是这个功能还是存在问题，由于缓存的存在，<strong>新添加的插件或者热更新被打断后重新运行都有几率报错</strong>。遇到这个问题，删除<code>.cache</code>文件夹就好了\n<img src=\"https://user-images.githubusercontent.com/26271337/168218613-bf34cc73-facf-4c9c-a66c-f0c73ba3fdd5.png\" alt=\"image\"></p>\n<h2 id=\"12-asset-modules\">1.2 Asset Modules</h2>\n<p>Webpack 5 新增了Asset Module,取代了之前版本需要下载的 <code>raw-load,</code> <code>url-loader</code>, <code>file-loader</code>.</p>\n<p>Asset Modules总共有四种类型</p>\n<ol>\n<li><p>asset/resource </p>\n<p> 用于文件的处理，替换了<code>file-loader</code></p>\n<pre><code class=\"language-jsx\">{\n    test: /\\.(mp4|mp3|wav)$/,\n    type: &#39;asset/resource&#39;,\n    generator: {\n        filename: &#39;res/video/[name][ext]&#39;,\n    }\n},\n</code></pre>\n</li>\n<li><p>asset/inline </p>\n<p>   替换了 <code>url-loader</code>, 会将文件转化为data URL</p>\n</li>\n<li><p>asset/source </p>\n<p> 替换了 <code>raw-loader</code> ,会直接导入文件的内容</p>\n</li>\n<li><p>asset (默认)</p>\n<p> 会自动选择生产文件还是生成data URL, 可以进行设置maxSize来进行判断处理</p>\n</li>\n</ol>\n<pre><code class=\"language-jsx\">{\n    test: /\\.(woff2|ttf|woff|png|svg|eot|jpg)$/,\n    type: &#39;asset&#39;,\n    parser: {\n        dataUrlCondition: {\n            maxSize: 100000\n        }\n    },\n    generator: {\n        filename: &#39;res/[hash][ext]&#39;,\n    }\n}\n</code></pre>\n<p>因为Webpack 内置了这个所以之前的<code>url-loader</code>  等依赖也无法在Webpack 5下生效</p>\n<h2 id=\"13-module-federation\">1.3 Module Federation</h2>\n<p>Webpack 5的更新中，这个功能最有用（我说的）。Module Federation 即模块联邦，在配置文件中配置后可以让当前项目共享其他项目的代码，也可以共享本身的代码给其他服务。 </p>\n<p>在实际使用中就可以用来做组件库，然后共享给所有项目。完美解决了以往通用组件库存在的痛点，即每次更新后，所有使用到组件库的服务都需要重新进行依赖下载和构建。 而Module Federation只用构建组件库即可，依赖组件库的服务可以直接使用到最新的组件。</p>\n<p>Module Federation 的配置如下</p>\n<pre><code class=\"language-jsx\">// 服务\nnew ModuleFederationPlugin({\n    name: &#39;service-name&#39;,\n    remotes: {\n        microFE: `microFE@http://localhost:7777/remoteEntry.js`\n    },\n    shared: {\n        ...deps\n    }\n})\n// 组件库\nnew ModuleFederation({\n    name: &quot;microFE&quot;,\n    filename: &#39;remoteEntry.js&#39;,\n    exposes: {\n        &#39;./Button&#39;: &#39;./src/components/Button/index.vue&#39;,\n    },\n        shared: {\n            ...deps, // packjson.dependencies\n            vue: ..., // 有些模块需要声明共享的程度\n        }\n})\n</code></pre>\n<p>服务本身要切换成动态导入的模式</p>\n<pre><code class=\"language-jsx\">// main.js 入口文件\nimport(&#39;bootloader.js&#39;)\n</code></pre>\n<pre><code class=\"language-jsx\">// main.js 入口文件\nimport(&#39;bootloader.js&#39;)\n\n// bootloader.js\nimport Vue from &#39;vue\nimport App from &#39;App.vue&#39;\n\nnew Vue({\n    render: h =&gt; h(App)\n}).$mount(&quot;#app&quot;)\n\n// 页面中使用\nimport Button from &#39;microFE/Button&#39;\n</code></pre>\n<p>Module Federation 本身的原理还是很简单的，就是利用动态导入打包成单独的包，然后其他服务使用时通过url加载对应的bundle即可。有了这个特性无论前端框架是什么，都可以做到组件共享。</p>\n<p>然后讲一下配置项</p>\n<ul>\n<li>name: &#39;service-name&#39;  定义服务的名称</li>\n<li>remotes  共享的服务的地址</li>\n<li>shared 声明公用的依赖</li>\n<li>exposed 声明暴露给其他服务使用的模块</li>\n<li>filename 服务构建后生产的单独文件，用于其他服务remotes使用</li>\n</ul>\n<h1 id=\"14-其他修改\">1.4 其他修改</h1>\n<p>Webpack 5还有很多其他的修改，例如一些配置项的更改, 内置了Terser进行代码压缩等。</p>\n<h1 id=\"2-存在的问题\">2. 存在的问题</h1>\n<p>新的版本，新的功能。总的来说对于开发者的使用体验有了很大的提升。</p>\n<p>在升级的过程中，我发现了一些问题：</p>\n<ol>\n<li>plugin 的写法还是过于复杂，用户自定义插件开发体验还是很糟糕</li>\n<li>首次构建速度变慢了，因为内置了Terser</li>\n<li>引入的缓存系统导致构建时的报错</li>\n</ol>\n"
}