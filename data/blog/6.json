{
    "title": "Vuex 源码学习",
    "excerpt": "1. 我的疑问 1.1 $store是怎么保证每个组件都可以进行访问的 1.2. 为什么需要Mutation,而不是直接使用Action 1.3. mapState等方法是怎么映射到组件的 1.4. 怎么和Vue的响应式结合起来的 1.5....",
    "updated": "2022-06-11 12:38:18 ",
    "created": "2022-06-11 10:08:27 ",
    "avatar": "https://avatars.githubusercontent.com/u/26271337?v=4",
    "id": 6,
    "content": "<h1 id=\"1-我的疑问\">1. 我的疑问</h1>\n<p> 1.1 $store是怎么保证每个组件都可以进行访问的\n 1.2. 为什么需要Mutation,而不是直接使用Action\n 1.3. mapState等方法是怎么映射到组件的\n 1.4. 怎么和Vue的响应式结合起来的\n 1.5. 插件的实现【兴趣不大】\n 1.6. 模块的实现【兴趣不大】</p>\n<p>带着我的疑问，现在就开搞！</p>\n<h1 id=\"2--基本介绍\">2.  基本介绍</h1>\n<p><img src=\"https://vuex.vuejs.org/vuex.png\" alt=\"流程图\"></p>\n<p><code>Vuex</code> 的核心就是一个 <code>Store</code>, 管理着应用的全局状态。组件从 <code>store</code> 中读取数据，当  <code>store</code> 中数据变化时，组件也会一起更新。\n<code>Vuex</code> 中的数据需要通过 <code>Mutation</code> 进行显示更改，当然根据实际业务直接更改对象类型的 <code>state</code> 其实也可以。显示更改更方便我们定位问题和在 <code>devtools</code> 中进行展示</p>\n<p>项目地址：<a href=\"https://github.com/vuejs/vuex\">https://github.com/vuejs/vuex</a>\n构建工具： Rollup\n入口文件：src/index.js</p>\n<p>由于平时使用的3.x版本的 <code>Vuex</code> ,所以分支为 <strong>v3.6.2</strong></p>\n<h1 id=\"3-初始化\">3. 初始化</h1>\n<p>回想下平时我们是怎么使用Vuex, 我们使用 <code>Vue.use</code> 安装了 <code>Vuex</code> 插件，然后通过\n然后再来看 <code>Vuex</code> 导出的相关包</p>\n<pre><code class=\"language-JS\">Vue.use(Vuex);\nconst store = new Vuex.Store({\n    state,\n    getters,\n    mutations,\n    actions,\n})\n\n  \nexport default store;\n</code></pre>\n<p>首先我们查看入口文件文件</p>\n<pre><code class=\"language-JS\">export default {\n    Store, \n    install,\n    version: &#39;__VERSION__&#39;,\n    mapState,\n    mapMutations,\n    mapGetters,\n    mapActions,\n    createNamespacedHelpers,\n    createLogger\n}\n</code></pre>\n<p><code>Store</code> 就是我们初始化的类，<code>install</code> 就是 <code>Vue.use</code> 安装的逻辑，还有平时使用到的一些辅助函数。</p>\n<h2 id=\"31-vuex初始化\">3.1 Vuex初始化</h2>\n<p>看下 <code>install</code>的逻辑</p>\n<pre><code class=\"language-js\">export function install () {\n    if (Vue &amp;&amp; _Vue === Vue) {\n        if (__DEV__) {\n            console.error(&#39;[vuex] already installed. Vue.use(Vuex) should be called only once.&#39;)\n        }\n        return\n    }\n    Vue = _Vue\n    applyMixin(Vue)\n}Ï\n</code></pre>\n<p>在执行时会往 <code>Vue</code> 中混入一些逻辑，2.0中混入了 <code>beforeCreate</code> 函数的逻辑</p>\n<pre><code class=\"language-js\">Vue.mixin({ beforeCreate: vuexInit })\n</code></pre>\n<p>而 <code>vuexInit</code> 中的逻辑就是混入<code>$store</code>, 保证应用下的组件都可以访问到 <code>$store</code> 。</p>\n<pre><code class=\"language-js\">function vuexInit () {\n    const options = this.$options\n    // store injection\n    if (options.store) {\n        this.$store = typeof options.store === &#39;function&#39;\n        ? options.store()\n        : options.store\n    } else if (options.parent &amp;&amp; options.parent.$store) {\n        this.$store = options.parent.$store\n    }\n}\n</code></pre>\n<p>通过这里的逻辑就能解答我的[第一个疑问]了</p>\n<h2 id=\"32-store初始化\">3.2 Store初始化</h2>\n<p>Store初始化主要分为：</p>\n<ol>\n<li>Module注册，处理嵌套逻辑，形成tree</li>\n<li>Module安装，初始化 state,getters等</li>\n<li>初始化Store.vm</li>\n</ol>\n<h3 id=\"32-1-module注册\">3.2. 1 Module注册</h3>\n<p>初始化<code>Store</code>时我们会传入一个对象，里面包含 <code>state</code>,<code>mutations</code>,<code>getters</code> 等属性。现在我们就来看看 <code>Store</code> 这个类.</p>\n<pre><code class=\"language-js\">this._modules = new ModuleCollection(options)\n</code></pre>\n<p>整个 <code>options</code> 可以视为 Store的 root module, 在ModuleCollection中进行解析，如果有嵌套的 module ,该方法也会进行处理\n看一下模块注册的逻辑</p>\n<pre><code class=\"language-js\">register (path, rawModule, runtime = true) {\n    \n    const newModule = new Module(rawModule, runtime)\n\n    // 构建tree\n    if (path.length === 0) {\n        this.root = newModule\n    } else {\n        // slice(0, -1) 不包括最后一项\n        const parent = this.get(path.slice(0, -1))\n        parent.addChild(path[path.length - 1], newModule)\n    }\n\n    // 处理嵌套的模块\n    if (rawModule.modules) {\n        forEachValue(rawModule.modules, (rawChildModule, key) =&gt; {\n            this.register(path.concat(key), rawChildModule, runtime)\n        })\n    }\n}\n</code></pre>\n<p>其中 <code>path</code> 为 <code>store tree</code> 的路径，<code>rawModule</code> 为配置项， <code>runtime</code> 为是否运行时创建的模块。</p>\n<p>通过 Module 类中对模块进行初始化，判断当前 <code>path</code> 的长度，若为0则称为 <code>root module</code>, 否则就找到 父模块调用 <code>addChild</code> 方法形成父子逻辑。</p>\n<p>这样子模块可以通过路径找到父模块，父模块可以通过 <code>_children</code> <code>key</code> 找到子模块</p>\n<h3 id=\"322-module安装\">3.2.2 Module安装</h3>\n<pre><code class=\"language-js\">installModule(this, state, [], this._modules.root)\n</code></pre>\n<p>这个方法的核心逻辑为</p>\n<pre><code class=\"language-js\">// 获取命名空间，模块标识namespace 为true， 可以嵌套\nconst namespace = store._modules.getNamespace(path)\n\n\nif (!isRoot &amp;&amp; !hot) {\n    const parentState = getNestedState(rootState, path.slice(0, -1))\n    const moduleName = path[path.length - 1]\n    store._withCommit(() =&gt; {\n        Vue.set(parentState, moduleName, module.state)\n    })\n}\n// 挂载state\nconst local = module.context = makeLocalContext(store, namespace, path)\n\n  \n// 处理mutations,action,getter\nmodule.forEachMutation((mutation, key) =&gt; {\n    const namespacedType = namespace + key\n    registerMutation(store, namespacedType, mutation, local)\n})\nmodule.forEachAction((action, key) =&gt; {\n    const type = action.root ? key : namespace + key\n    const handler = action.handler || action\n    registerAction(store, type, handler, local)\n})\nmodule.forEachGetter((getter, key) =&gt; {\n    const namespacedType = namespace + key\n    registerGetter(store, namespacedType, getter, local)\n})\n// 嵌套安装\nmodule.forEachChild((child, key) =&gt; {\n    installModule(store, rootState, path.concat(key), child, hot)\n})\n</code></pre>\n<p>在 <code>makeLocalContext</code> 方法中实现上下文的注册，上下文包括了 <code>state</code>, <code>getters</code> , <code>dispatch</code>, <code>commit</code> 等。这几个属性除了 <code>state</code> 都处理了 <code>namespace</code> 的情况。这里讲一下 <code>state</code> 的获取逻辑就好了</p>\n<pre><code class=\"language-js\">Object.defineProperties(local, {\n    getters: {\n        get: noNamespace\n        ? () =&gt; store.getters\n        : () =&gt; makeLocalGetters(store, namespace)\n    },\n    state: {\n        get: () =&gt; getNestedState(store.state, path)\n    }\n\n})\n\nfunction getNestedState (state, path) {\n    return path.reduce((state, key) =&gt; state[key], state)\n}\n</code></pre>\n<p> 从<code>state</code> 开始，层层查找子模块 <code>state</code>，最终找到目标模块的 <code>state</code>.</p>\n<p> <code>registerMutation</code>, <code>registerAction</code> 等方法完成对 <code>mutation</code>, <code>action</code> 的注册</p>\n<h3 id=\"323-初始化storevm\">3.2.3 初始化Store.vm</h3>\n<pre><code class=\"language-js\">resetStoreVM(this, state)\n</code></pre>\n<p>resetStoreVM的具体逻辑是这样的</p>\n<pre><code class=\"language-js\">  \n\nfunction resetStoreVM (store, state, hot) {\n\n   const oldVm = store._vm\n   // bind store public getters\n   store.getters = {}\n\n   // reset local getters cache\n\n   store._makeLocalGettersCache = Object.create(null)\n\n   const wrappedGetters = store._wrappedGetters\n\n   const computed = {}\n\n   forEachValue(wrappedGetters, (fn, key) =&gt; {\n       computed[key] = partial(fn, store)\n       Object.defineProperty(store.getters, key, {\n           get: () =&gt; store._vm[key],\n           enumerable: true // for local getters\n       })\n   })\n\n   const silent = Vue.config.silent\n   Vue.config.silent = true\n   store._vm = new Vue({\n       data: {\n           $$state: state\n       },\n       computed\n   })\n   Vue.config.silent = silent\n\n\n   if (oldVm) {\n       if (hot) {\n           store._withCommit(() =&gt; {\n\n               oldVm._data.$$state = null\n\n           })\n   \n       }\n       Vue.nextTick(() =&gt; oldVm.$destroy())\n   }\n}\n</code></pre>\n<p>这里的流程就是从 <code>_wrappedGetters</code> 中取出对应 <code>gettter</code> 函数，挂在到 <code>store._vm </code>中，同时存入 <code>computed</code> 中，通过 <code>Vue</code> 的 <code>compute</code> ,和 <code>state</code> 产生依赖关系</p>\n<pre><code>store._vm = new Vue({\n       data: {\n           $$state: state\n       },\n       computed\n})\n</code></pre>\n<p> 然后 <code>store</code> 的 <code>state</code> 的 <code>getter</code> 是这么设置的</p>\n<pre><code class=\"language-js\">get state () {\n return this._vm._data.$$state\n}\n</code></pre>\n<p>因此获取 <code>state</code> 时，实际上访问的是vm的<code>$$state</code></p>\n<p>总体的逻辑来说就是这样的</p>\n<pre><code>根据 `key` 访问 `store.getters` 的某一个 `getter` 的时候，实际上就是访问了 `store._vm[key]`，也就是 `computed[key]`，在执行 `computed[key]` 对应的函数的时候，会执行 `rawGetter(local.state,...)` 方法，那么就会访问到 `store.state`，进而访问到 `store._vm._data.$$state`，这样就建立了一个依赖关系。当 `store.state` 发生变化的时候，下一次再访问 `store.getters` 的时候会重新计算\n</code></pre>\n<p>在上面的代码中还有 严格模式的校验</p>\n<pre><code class=\"language-js\">function enableStrictMode (store) {\n\n    store._vm.$watch(function () { return this._data.$$state }, () =&gt; {\n\n    if (__DEV__) {\n\n    assert(store._committing, `do not mutate vuex store state outside mutation handlers.`)\n\n    }\n\n    }, { deep: true, sync: true })\n}\n</code></pre>\n<p>如果处于严格模式,就会手动添加一个 同步的<code>watch</code>, 监听<code>$$state</code>的变化是否是 <code>mutation</code> 改变的，</p>\n<pre><code class=\"language-js\">_withCommit (fn) {\n  const committing = this._committing\n  this._committing = true\n  fn()\n  this._committing = committing\n}\n</code></pre>\n<p>_withCommit方法保证了通过Vuex自身提供的方法改变数据才能使 <code>_committing</code> 为 <code>true</code></p>\n<p>读到这里，关于 [1.4]和[1.6]的问题，已经有了答案，响应式是通过 <code>Vue</code> 实现的，模块是 <code>Store</code> 的基本单位，兼容层级的嵌套和命名空间。</p>\n<h1 id=\"4-api\">4. API</h1>\n<p>在 store 的初始化过程中完成了数据的存储，接下来就是通过 API来进行使用了。</p>\n<h2 id=\"41-mutation--commit\">4.1 Mutation &amp; commit</h2>\n<p>在初始化时，我们进行了 mutation 方法的初始化，可以通过 mutation 进行 state 的更改。</p>\n<pre><code class=\"language-js\">function registerMutation (store, type, handler, local) {\n  const entry = store._mutations[type] || (store._mutations[type] = [])\n  entry.push(function wrappedMutationHandler (payload) {\n    handler.call(store, local.state, payload)\n  })\n}\n</code></pre>\n<p>这里我们也能明白在 <code>mutation</code> 中改变的数据是当前模块的数据，访问的 <code>this</code> 是 <code>store</code> . 然后将每个 <code>mutation</code> 存入到<code> store._mutations[type]</code> 中</p>\n<p>然后我们再看看 commit, store 提供 commit 来提交 commit</p>\n<pre><code class=\"language-js\">commit (_type, _payload, _options) {\n\n    // 规范传入的参数\n    const {\n        type,\n        payload,\n        options\n    } = unifyObjectStyle(_type, _payload, _options)\n\n  \n\n    const mutation = { type, payload }\n    // 获取存放的方法\n    const entry = this._mutations[type]\n    // 执行mutation改变state\n    this._withCommit(() =&gt; {\n        entry.forEach(function commitIterator (handler) {\n            handler(payload)\n        })\n    })\n    // 提供给订阅者使用，一般是插件\n    this._subscribers\n    .slice() \n    .forEach(sub =&gt; sub(mutation, this.state))\n}\n</code></pre>\n<p>从这里可以看出，mutation必须是同步的，不然下面通知 订阅者 的逻辑会出错</p>\n<h2 id=\"42-action--dispatch\">4.2 Action &amp; dispatch</h2>\n<p>Action 和 Mutation的区别就是 Action是异步的，所以它们大部分逻辑还是差不多的，只是在异步处理和通知上有区别</p>\n<pre><code class=\"language-js\">...\n// 执行前hook\ntry {\n    this._actionSubscribers\n    .slice()\n    .filter(sub =&gt; sub.before)\n    .forEach(sub =&gt; sub.before(action, this.state))\n} catch (e) {\n}\n\n  \nconst result = entry.length &gt; 1\n? Promise.all(entry.map(handler =&gt; handler(payload)))\n: entry[0](payload)\n\n\nreturn new Promise((resolve, reject) =&gt; {\n    // 完成hook 和 error hook\n    result.then(res =&gt; {\n        this._actionSubscribers\n        .filter(sub =&gt; sub.after)\n        .forEach(sub =&gt; sub.after(action, this.state))\n        \n        resolve(res)\n    }, error =&gt; {\n        this._actionSubscribers\n        .filter(sub =&gt; sub.error)\n        .forEach(sub =&gt; sub.error(action, this.state, error))\n        \n        reject(error)\n    })\n})\n</code></pre>\n<h2 id=\"42-mapstate\">4.2 mapState</h2>\n<p>在 <code>src/helper.js</code>中</p>\n<pre><code class=\"language-js\">export const mapState = normalizeNamespace((namespace, states) =&gt; {\n\n    const res = {}\n\n    normalizeMap(states).forEach(({ key, val }) =&gt; {\n        // 组成getter函数\n        res[key] = function mappedState () {\n            let state = this.$store.state\n            let getters = this.$store.getters\n            // 有命名空间就使用模块的数据，不然就使用根的\n            // 这里的this 是指向组件的\n            if (namespace) {\n                const module = getModuleByNamespace(this.$store, \t\t&#39;mapState&#39;,namespace)\n                if (!module) {\n                    return\n                }\n                state = module.context.state\n                getters = module.context.getters\n            }\n\n        return typeof val === &#39;function&#39; ? val.call(this, state, getters): state[val]\n    }\n\n    // mark vuex getter for devtools\n        res[key].vuex = true\n\n    })\n    return res\n})\n</code></pre>\n<p>这里的主要逻辑是 得到一些getter函数，其中也包括对一些命名空间的处理。这里兼容了val是函数还是字符串的情况。</p>\n<p>接下来我们看看 <code>normalizeNamesapce</code> 函数干了啥，</p>\n<pre><code class=\"language-js\">function normalizeNamespace (fn) {\n    return (namespace, map) =&gt; {\n        if (typeof namespace !== &#39;string&#39;) {\n            map = namespace\n            namespace = &#39;&#39;\n        } else if (namespace.charAt(namespace.length - 1) !== &#39;/&#39;) {\n            namespace += &#39;/&#39;\n        }\n        return fn(namespace, map)\n    }\n}\n</code></pre>\n<p>其实对于 <code>namespace/state</code>做处理，拿到斜杠前的命名空间 然后对函数进行包裹，兼容传命名空间和不穿命名空间的两种情况。</p>\n<h2 id=\"43-mapmutations\">4.3 mapMutations</h2>\n<p>其实 <code>mapMutations</code> 的逻辑和 <code>mapState</code> 差不多，这里讲一下核心的逻辑就好了</p>\n<pre><code class=\"language-js\">\nres[key] = function mappedMutation (...args) {\n    let commit = this.$store.commit\n    // 没namespace就用store的顶级commit,不然就使用模块上下文自己的commit\n    if (namespace) {\n        const module = getModuleByNamespace(this.$store, &#39;mapMutations&#39;, namespace)\n        if (!module) return\n        commit = module.context.commit\n    }\n    // 然后执行commit函数，也支持val是函数的情况，将commit进行传入\n    return typeof val === &#39;function&#39;\n    ? val.apply(this, [commit].concat(args))\n\n    : commit.apply(this.$store, [val].concat(args))\n\n}\n</code></pre>\n<p>其他的 <code>mapGetters</code>, <code>mapActions</code> 的逻辑都与其类似。 </p>\n<h1 id=\"5-插件\">5. 插件</h1>\n<p>插件平时用的还是很少的，也就学习教程时知道一个 <code>logger</code> 插件，还有 <code>Vuex 持久化</code>的插件。\n现在就顺便研究下插件机制, 显示插件激活</p>\n<pre><code class=\"language-js\">plugins.forEach(plugin =&gt; plugin(this))\n</code></pre>\n<p>代码其实就是将 <code>store</code> 传递给插件，然后插件调用 <code>store.subscribe</code> 订阅 <code>mutation</code> 事件，或者订阅 <code>action</code> 事件。</p>\n<p>看了这么多源码，想一下 持久化插件会怎么做呢？ </p>\n<p>我觉得可以在每次数据改变后 将当前 <code>state</code> 存到 <code>localStorage</code> 中，当 <code>store</code> 在激活插件时，从 <code>localStorage</code> 中拿到旧的数据，然后改变 <code>$$state</code></p>\n<p>看了下源码果然逻辑差不多 <a href=\"https://github.com/robinvdvleuten/vuex-persistedstate/blob/master/src/index.ts\">Vuex-persistedstate</a></p>\n<h1 id=\"6-总结\">6. 总结</h1>\n<p>看完源码后我的6个疑问解决了5个，收获还是很大的。对于自己平时的开发，如果状态比较多的话，子模块和命名空间的确很好用。毕竟 Vuex 花了很大精力去处理这块逻辑。</p>\n<p>还有插件的设计，也让我学会了如何去制作 Vuex 插件和 设计插件系统</p>\n<p>当然还有最后的疑问，为啥需要Mutation，而不是直接使用Action呢？像 <a href=\"https://pinia.vuejs.org/\">pinia</a> 中就放弃了Mutation.</p>\n<p>我其实也有了答案，正如作者说的，Mutation其实是为了更好的追踪状态的改变，方便devtools去捕捉，同时数据更改后能够及时同步插件，保证插件获取的数据是正确的。</p>\n<p>当然直接使用Action也是可以，因为Action也能够通知订阅者。且用户直接更改数据也不会影响响应式的功能。所以这也是为什么 Mutation 被放弃的原因。</p>\n"
}