{
    "title": "SEO需求，Nuxt SSG练手",
    "excerpt": "一. 业务背景 部门官网和主应用是一个 SPA 的服务。由于业务扩展，希望能够被搜索引擎收录到，所以官网需要做 SEO。 二. 技术选型 由于直接在原主应用上做 SSR，改动成本太大，决定直接使用现成的 SSR 框架。 Next.js 与 ...",
    "updated": "2022-06-27 16:33:15 ",
    "created": "2022-06-27 16:33:15 ",
    "avatar": "https://avatars.githubusercontent.com/u/26271337?v=4",
    "id": 16,
    "content": "<h1 id=\"一-业务背景\">一. 业务背景</h1>\n<p>部门官网和主应用是一个 <code>SPA</code> 的服务。由于业务扩展，希望能够被搜索引擎收录到，所以官网需要做 <code>SEO</code>。</p>\n<h1 id=\"二-技术选型\">二. 技术选型</h1>\n<p>由于直接在原主应用上做 <code>SSR</code>，改动成本太大，决定直接使用现成的 <code>SSR</code> 框架。</p>\n<p><code>Next.js</code> 与 <code>Nuxt</code> 都是前端比较流行的 <code>SSR</code> 框架，且都支持 <code>SSG</code>.。加上旧代码是 <code>Vue</code> 写的，直接迁移到 <code>Nuxt</code> 是比较方便的，因此最终选择了 <code>Nuxt</code>.</p>\n<p><code>SSR</code> 和 <code>SSG</code> 都能够起到 <code>SEO</code>  的作用，但是 <code>SSR</code> 需要在服务器特意启动 <code>node</code> 服务，而 <code>SSG</code> 只需要部署在 nginx 代理的目录下即可。</p>\n<p>因此最终选型： <code>Nuxt</code> + <code>SSG</code></p>\n<h1 id=\"三-开发过程\">三. 开发过程</h1>\n<h2 id=\"31-路由和布局\">3.1 路由和布局</h2>\n<p><code>Nuxt</code> 框架使用约定式路由，即 <code>pages</code> 文件夹下的 <code>Vue</code> 组件直接成为路由。</p>\n<pre><code class=\"language-shell\">- pages\n    # /\n    - index.vue \n    - foo\n        # /foo/bar\n        - bar.vue \n</code></pre>\n<p>以下划线开头的文件，成为<strong>动态路由</strong></p>\n<pre><code class=\"language-shell\"># news/:post\n- news\n    - _post.vue\n</code></pre>\n<p>布局文件在 <code>layouts</code> 文件下, 包裹 <code>Nuxt</code> 组件即可</p>\n<pre><code class=\"language-tsx\">// default.vue\n&lt;div&gt;\n    ...\n        &lt;Nuxt&gt;\n    ...\n&lt;/div&gt;\n</code></pre>\n<p>知道这些基本的配置，将旧代码迁移过来，一般就能直接用了</p>\n<h2 id=\"32-插件\">3.2 插件</h2>\n<p>当我们需要引入第三方库时，并没有向 <code>Vue</code> 中那样有个入口文件可以使用。我们需要在 <code>plugins</code> 文件夹下写插件。例如部分引入 <code>element-ui</code></p>\n<pre><code class=\"language-ts\">// plugins/element.js\nimport Vue from &#39;vue&#39;\n\nconst components = [...]\n                    \nconst Element = {\n    install(Vue) {\n        components.forEach(c =&gt; Vue.component(c.name, c))\n    }\n}\nVue.use(Element)\n</code></pre>\n<p>然后在 <code>nuxt.config.js</code> 进行引入</p>\n<pre><code>plugins: [\n    &#39;./plugins/element.js&#39;\n]\n</code></pre>\n<p>如果我们要对 <code>axios</code> 做扩展，也可以写一个插件 </p>\n<pre><code class=\"language-ts\">import host from &#39;../env&#39;\nexport default function({$axios,},) {\n    $axios.setBaseURL(`${host}/...`)\n    $axios.onResponse(res =&gt; {\n        ...\n    })\n}\n</code></pre>\n<p>当然 <code>Nuxt</code> 提供的插件能力强大， 我们可以通过插件往实例中添加属性</p>\n<pre><code class=\"language-ts\">export default function({}, inject) {\n    inject(...)\n}\n</code></pre>\n<h2 id=\"33-页面文件\">3.3 页面文件</h2>\n<h3 id=\"331-asyncdata\">3.3.1 asyncData</h3>\n<p>和普通的 <code>Vue</code> 开发不同，<code>Nuxt</code> 中 <code>Vue</code> 组件获取数据需要用特定的方法 <code>asyncData</code>, 方便客户端和服务端都能使用</p>\n<pre><code class=\"language-ts\">async asyncData({params , $axios}) {\n    const { id } = params\n    const data = await $axios.get(`...`)\n    return {\n        data\n    }\n}\n</code></pre>\n<p><code>asyncData</code> 返回的数据，可以通过实例获取，例如 <code>this.data</code>。</p>\n<p><code>Nuxt</code> 同时也提供 <code>fetch</code> 函数用来获取数据。</p>\n<h3 id=\"332-processbrowser\">3.3.2 process.browser</h3>\n<p>在组件中，如果有些方法需要放到 <code>created</code> 周期去做的，需要注意判断下环境，支持目标环境支持的操作</p>\n<pre><code class=\"language-ts\">if(process.browser) {\n    ...\n}\n</code></pre>\n<h3 id=\"333-head\">3.3.3 head</h3>\n<p>如果当前页面需要额外的 <code>meta</code> 信息，可以通过 <code>head</code> 函数进行定义</p>\n<pre><code class=\"language-ts\">head() {\n    return {\n        meta: [\n            {\n                hid: &#39;keywords&#39;,\n                name: &#39;keywords&#39;,\n                content: &#39;...&#39;\n            }\n        ]\n    }\n\n}\n</code></pre>\n<h1 id=\"四-nuxtconfigjs\">四. nuxt.config.js</h1>\n<p><code>nuxt.config.js</code> 是 <code>Nuxt</code> 应用的配置文件,现在初略讲一下重要的字段。</p>\n<ol>\n<li><strong>target</strong><br>构建的目标 <code>server</code> / <code>static</code> </li>\n<li><strong>head</strong>\n定义 <code>head</code> 标签中信息,支持定义 <code>meta</code>, <code>link</code>, <code>script</code> 等</li>\n<li><strong>css</strong>\n全局 CSS 定义</li>\n<li><strong>components</strong>\n组件自动导入功能开启，不需要写引入语句</li>\n<li><strong>env</strong>\n环境变量</li>\n<li>** router **\n路由配置<pre><code class=\"language-ts\">router: {\n base: &#39;&#39;,\n extendRoutes() {}// 扩展路由\n}\n</code></pre>\n这里需要注意下，<code>SSG</code> 的页面存在路由问题。如果某个路由页面刷新，会找不到地址，这里需要对路由处理下。\n```ts\nrouter: {\n extendRoutes(routes,) {\n routes.forEach(route =&gt; {\n     const alias  = route.path.length &gt; 1 <code>${route.path}/index.html</code>: &#39;/index.html&#39;\n     route.alias = alias\n \n })\n }</li>\n</ol>\n<p>}</p>\n<pre><code>\n\n7. **build**\n`webpack` 的处理, 增加规则，引入插件等\n```js\nbuild: {\n    extend(config) {\n        config.module.rules...\n        return config\n    },\n    babel: {\n        plugins: [...]\n    }\n\n}\n</code></pre>\n<ol start=\"8\">\n<li><strong>generate</strong>\n配置 <code>SSG</code> 的逻辑,例如我这里请求接口生成路由\n```js\ngenerate: {\n routes() {\n axios.get(&#39;...&#39;).then(res =&gt; {\n     return res.data.map(r =&gt; ({\n         route: <code>/news/${r.id}</code>\n     }))\n \n })\n }</li>\n</ol>\n<p>}</p>\n<p>```\n这里声明了路由文件的数量，构建时会调用对应组件的 <code>asyncData</code> 方法传入参数，然后生成静态文件</p>\n<h1 id=\"五-总结\">五. 总结</h1>\n<p>总的来说 <code>Nuxt</code> 的开发体验还是比较好的，毕竟是框架上面的框架，各种插件和模块都比较齐全。能够快速实现 <code>SSR</code> 和 <code>SSG</code>, 就算普通开发 <code>SPA</code> 的体验也是比较好的。</p>\n"
}