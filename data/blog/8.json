{
    "title": "Vue Router 源码学习",
    "excerpt": "1. 我的疑问 Vue Router 的使用频率还是很高的，作为开发者，我们可能知道 hash路由和 history路由 的区别和实现原理。但是一些还是东西是值得理解的。 内置组件 router-view 是怎么实现的 路由守卫是怎么实现的...",
    "updated": "2022-06-13 16:35:26 ",
    "created": "2022-06-13 16:35:26 ",
    "avatar": "https://avatars.githubusercontent.com/u/26271337?v=4",
    "id": 8,
    "content": "<h1 id=\"1-我的疑问\">1. 我的疑问</h1>\n<p>Vue Router 的使用频率还是很高的，作为开发者，我们可能知道 hash路由和 history路由 的区别和实现原理。但是一些还是东西是值得理解的。</p>\n<ol>\n<li>内置组件 router-view 是怎么实现的</li>\n<li>路由守卫是怎么实现的</li>\n<li>和Transition是怎么搭配合作的</li>\n<li>routes 数据是怎么解析的</li>\n<li>和keep-alive 是怎么配合</li>\n</ol>\n<h1 id=\"2-基本介绍\">2. 基本介绍</h1>\n<p>这里就不介绍基本的使用</p>\n<p>项目地址：<a href=\"https://github.com/vuejs/vue-router\">https://github.com/vuejs/vue-router</a>\n构建工具： Rollup\n入口文件：src/index.js</p>\n<h1 id=\"3--入口文件分析\">3.  入口文件分析</h1>\n<h2 id=\"31-install\">3.1 install</h2>\n<p>看下 install 函数执行的逻辑</p>\n<pre><code class=\"language-js\">export function install (Vue) {\n    // 避免重复注册\n    if (install.installed &amp;&amp; _Vue === Vue) return\n    install.installed = true\n    _Vue = Vue\n    const isDef = v =&gt; v !== undefined\n    // 暂时不知道少用\n    const registerInstance = (vm, callVal) =&gt; {\n        let i = vm.$options._parentVnode\n        if (\n            isDef(i) &amp;&amp; isDef(i = i.data) &amp;&amp; isDef(i = i.registerRouteInstance)\n        ){\n            i(vm, callVal)\n        }\n    }\n    // 混入逻辑，\n    Vue.mixin({\n        beforeCreate () {\n            if (isDef(this.$options.router)) {\n                // 自身\n                this._routerRoot = this\n                // 路由实例\n                this._router = this.$options.router\n                this._router.init(this)\n                // 定义route,指向当前激活路由\n                Vue.util.defineReactive(\n                    this, &#39;_route&#39;,\n                    this._router.history.current)\n            } else {\n                // 由于是树形结构，因此子组件会找到离自己最近的 带有router的组件\n                this._routerRoot = \n                    (this.$parent &amp;&amp; this.$parent._routerRoot) || this\n            }\n            registerInstance(this, this)\n        },\n        destroyed () {\n            registerInstance(this)\n        }\n    })\n\n \n    // 定义全局属性\n    Object.defineProperty(Vue.prototype, &#39;$router&#39;, {\n        get () { return this._routerRoot._router }\n    })\n    Object.defineProperty(Vue.prototype, &#39;$route&#39;, {\n        get () { return this._routerRoot._route }\n    })\n    // 组件注册\n    Vue.component(&#39;RouterView&#39;, View)\n    Vue.component(&#39;RouterLink&#39;, Link)\n}\n</code></pre>\n<p>相关注释我都写在代码中了，主要逻辑就是在组件中混入了路由的属性，定义全局的属性，注册了两个内置组件。</p>\n<p>这里比较巧妙的是通过树形结构的特性，保证了拥有 <code>options.router</code> 的组件进行了路由初始化，子组件根据父组件层层查找，找到离自己最近的带有 <code>router</code> 的组件。</p>\n<p>然后 <code>registerInstance</code> 方法暂时不知道用法，</p>\n<h2 id=\"32-vuerouter\">3.2 VueRouter</h2>\n<p><code>VueRouter</code> 类在 <code>src/index.js</code> 中，默认导出的就是 <code>VueRouter</code>, 我们在业务开发时也通过实例化 <code>VueRouter</code> 来生成 <code>router</code> 给应用使用。</p>\n<h3 id=\"321-构造函数\">3.2.1 构造函数</h3>\n<pre><code class=\"language-js\">constructor (options: RouterOptions = {}) {\n  this.app = null\n  this.apps = []\n  this.options = options\n  this.beforeHooks = []\n  this.resolveHooks = []\n  this.afterHooks = []\n    \n  this.matcher = createMatcher(options.routes || [], this)\n    \n  // 根据options结合实际浏览器确定 路由模式\n  let mode = options.mode || &#39;hash&#39;\n  this.fallback = mode === &#39;history&#39; &amp;&amp; !supportsPushState &amp;&amp; options.fallback !== false\n  if (this.fallback) {\n    mode = &#39;hash&#39;\n  }\n    // 如果不在浏览器则为 abstract模式\n  if (!inBrowser) {\n    mode = &#39;abstract&#39;\n  }\n  this.mode = mode\n  // 根据路由模式生成 history 对象\n  switch (mode) {\n    case &#39;history&#39;:\n      this.history = new HTML5History(this, options.base)\n      break\n    case &#39;hash&#39;:\n      this.history = new HashHistory(this, options.base, this.fallback)\n      break\n    case &#39;abstract&#39;:\n      this.history = new AbstractHistory(this, options.base)\n      break\n    default:\n      if (process.env.NODE_ENV !== &#39;production&#39;) {\n        assert(false, `invalid mode: ${mode}`)\n      }\n  }\n}\n</code></pre>\n<p>这里主要的逻辑就是通过<code> options.router</code> 生成 <code>matcher</code>, 和通过路由模式生成对应的 <code>history</code>对象. \n通过这里我才知道原来 路由还有 <code>abstract</code> 模式, 提供给服务端或者ssr模式使用，应该和V4版本的 <code>Memory mode</code>是一样的。</p>\n<h3 id=\"322-init\">3.2.2 init</h3>\n<p>在 <code>install</code>的过程中，<code>VueRouter</code> 往 <code>Vue</code> 中 <code>beforeCreated</code> 逻辑, 对有 <code>router</code> 的 <code>options</code> 进行了路由初始化</p>\n<pre><code>this._router.init(this)\n</code></pre>\n<p>因此我们再看看 <code>router</code> 的 <code>init</code> 方法</p>\n<pre><code class=\"language-js\">init (app: any) {\n  // 将当前组件推入 app 中\n  this.apps.push(app)\n  if (this.app) {\n    return\n  }\n  this.app = app\n        \n\n  const history = this.history\n  // 属于hash 和 history 模式\n  if (history instanceof HTML5History || history instanceof HashHistory) {\n     // scrollBehavior支持\n       const handleInitialScroll = routeOrError =&gt; {\n        const from = history.current\n        const expectScroll = this.options.scrollBehavior\n        const supportsScroll = supportsPushState &amp;&amp; expectScroll\n        if (supportsScroll &amp;&amp; &#39;fullPath&#39; in routeOrError) {\n            handleScroll(this, routeOrError, from, false)\n        }\n    }\n    const setupListeners = routeOrError =&gt; {\n        history.setupListeners()\n        handleInitialScroll(routeOrError)\n    }\n    // 切换到当前链接对应的路由\n    history.transitionTo(\n        history.getCurrentLocation(),\n        setupListeners,\n        setupListeners\n    )\n  }\n  // 路由更新后，更新组件的_route\n  history.listen(route =&gt; {\n    this.apps.forEach((app) =&gt; {\n      app._route = route\n    })\n  })\n}\n</code></pre>\n<p>初始化时将当前组件进行保存，将<strong>当前路由</strong>切换到<strong>当前链接</strong>对应路由，也设置了订阅，当 <code>history</code> 改变时，会更新组件的 <code>route</code>。</p>\n<h3 id=\"323-transitionto\">3.2.3 transitionTo</h3>\n<p>看下 <code>tansitionTo</code> 的实际逻辑</p>\n<pre><code class=\"language-js\">// 匹配到路由\nroute = this.router.match(location, this.current)\nconst prev = this.current\n\n// 进行切换动画\nthis.confirmTransition(\n    route,\n    () =&gt; {\n        // 更新当前路由\n        this.updateRoute(route)\n        onComplete &amp;&amp; onComplete(route)\n        // 更改url\n        this.ensureURL()\n        // hook\n        this.router.afterHooks.forEach(hook =&gt; {\n            hook &amp;&amp; hook(route, prev)\n        })\n        // 初始化回调\n        if (!this.ready) {\n            ...\n        }\n    },\n    err =&gt; {\n    // 错误处理\n})\n\n\nconfirmTransition (route: Route, onComplete: Function, onAbort?: Function) {\n    const current = this.current\n    this.pending = route\n    // 错误处理\n    const abort = err =&gt; {}\n    // 当前路由重复导航处理\n    if (isDuplicatedRoute) {\n        this.ensureURL()\n        if (route.hash) {\n            handleScroll(this.router, current, route, false)\n        }\n        return abort(createNavigationDuplicatedError(current, route))\n    }\n    \n    const { updated, deactivated, activated } = resolveQueue(\n        this.current.matched,\n        route.matched\n    )\n    const queue: Array&lt;?NavigationGuard&gt; = [].concat(\n        // in-component leave guards\n        extractLeaveGuards(deactivated),\n        // global before hooks\n        this.router.beforeHooks,\n        // in-component update hooks\n        extractUpdateHooks(updated),\n        // in-config enter guards\n        activated.map(m =&gt; m.beforeEnter),\n        // async components\n        resolveAsyncComponents(activated)\n    )\n    const iterator = (hook: NavigationGuard, next) =&gt; {\n        if (this.pending !== route) {\n            return abort(createNavigationCancelledError(current, route))\n        }\n        try {\n            hook(route, current, (to: any) =&gt; {\n                if (to === false) {\n                    // next(false) -&gt; abort navigation, ensure current URL\n                    this.ensureURL(true)\n                    abort(createNavigationAbortedError(current, route))\n                } else if (isError(to)) {\n                    this.ensureURL(true)\n                    abort(to)\n                } else if (\n                    typeof to === &#39;string&#39; ||\n                    (typeof to === &#39;object&#39; &amp;&amp;\n                    (typeof to.path === &#39;string&#39; || typeof to.name === &#39;string&#39;))\n                ) {\n                    // next(&#39;/&#39;) or next({ path: &#39;/&#39; }) -&gt; redirect\n                    abort(createNavigationRedirectedError(current, route))\n                    if (typeof to === &#39;object&#39; &amp;&amp; to.replace) {\n                        this.replace(to)\n                    } else {\n                        this.push(to)\n                    }\n                } else {\n                    // confirm transition and pass on the value\n                    next(to)\n                }\n            })\n        } catch (e) {\n            abort(e)\n        }\n    }\n\n    runQueue(queue, iterator, () =&gt; {\n        // wait until async components are resolved before\n        // extracting in-component enter guards\n        const enterGuards = extractEnterGuards(activated)\n        const queue = enterGuards.concat(this.router.resolveHooks)\n        runQueue(queue, iterator, () =&gt; {\n            if (this.pending !== route) {\n                return abort(createNavigationCancelledError(current, route))\n            }\n            this.pending = null\n            onComplete(route)\n            if (this.router.app) {\n                this.router.app.$nextTick(() =&gt; {\n                    handleRouteEntered(route)\n                })\n            }\n        })\n    })\n}\n</code></pre>\n<p>这里主要执行 <code>confirmTransition</code> 方法，主要逻辑分为几步：</p>\n<ol>\n<li>检查是否重复路由，进行处理</li>\n<li>用 <code>reolveQuene</code> 筛选出当前路由和跳转路由的差异</li>\n<li>然后对迭代一个队列，队列包含<ol>\n<li>激活失效组件 <code>beforeLeave</code> 路由守卫</li>\n<li>全局路由 <code>beforHooks</code></li>\n<li>重用组件 <code>update</code> 路由守卫</li>\n<li>激活路由 配置的<code>beforeEnter hook</code></li>\n<li>处理异步组件加载逻辑\n如果顺序执行中有一个任务失败，则不会继续下面的任务</li>\n</ol>\n</li>\n<li>队列跑完之后，执行新的队列任务。队列包括<ol>\n<li>激活组件的  <code>beforeEnter hook</code></li>\n<li>全局路由的  <code>resolveHooks</code>\n 执行完成后，在 <code>nextTick</code> 后执行路由完成后的回调操作，调用全局的 <code>afterEach</code> 钩子。</li>\n</ol>\n</li>\n</ol>\n<h3 id=\"324-matcher\">3.2.4 matcher</h3>\n<p>上面的路由切换方法中，进场会比较 <code>route</code> 的 <code>matched</code> 属性，而在构造函数中也有</p>\n<pre><code class=\"language-js\">this.matcher = createMatcher(options.routes || [], this)\n</code></pre>\n<p>因此我们来研究下 <code>matcher</code></p>\n<pre><code class=\"language-js\">function createMatcher (\nroutes: Array&lt;RouteConfig&gt;,\nrouter: VueRouter\n): Matcher {\n\nconst { pathList, pathMap, nameMap } = createRouteMap(routes)\n...\nreturn {\n    match,\n    addRoute,\n    getRoutes,\n    addRoutes\n}\n</code></pre>\n<p>首先是根据传入的 <code>routes</code> 通过 <code>createRouteMap</code> 解析为 <code>list</code> 和 <code>map</code> .</p>\n<ul>\n<li>将用户传入的配置进行遍历，对每个路由生成 RouteRecord 存放到 pathList</li>\n<li>pathMap, nameMap 是存放了 path 和 name 对 RouteRecord 的映射</li>\n</ul>\n<pre><code class=\"language-js\">const record: RouteRecord = {\n   path: normalizedPath, // 规范后的路径\n   regex: compileRouteRegex(normalizedPath, pathToRegexpOptions), // 路径对应正则\n   components: route.components || { default: route.component }, // 组件\n   instances: {},\n   name,\n   parent,\n   matchAs,\n   redirect: route.redirect,\n   beforeEnter: route.beforeEnter,\n   meta: route.meta || {},\n   props: route.props == null\n     ? {}\n     : route.components\n       ? route.props\n       : { default: route.props }\n }\n</code></pre>\n<p>在平时的业务开发中，路由的配置不是固定的，根据用户的权限生产对应的路由才是合理的。因此会使用两个方法：</p>\n<ol>\n<li><p>addRoutes</p>\n<pre><code>function addRoutes (routes) {\n  createRouteMap(routes, pathList, pathMap, nameMap)\n}\n</code></pre>\n</li>\n<li><p>addRoute\n```js\nfunction addRoute (parentOrRoute, route) {\n const parent = (typeof parentOrRoute !== &#39;object&#39;) ? nameMap[parentOrRoute] : undefined</p>\n<p> createRouteMap([route || parentOrRoute], pathList, pathMap, nameMap, parent)\n if (parent &amp;&amp; parent.alias.length) {\n createRouteMap(\n     parent.alias.map(alias =&gt; ({ path: alias, children: [route] })),\n     pathList,\n     pathMap,\n     nameMap,\n     parent\n )\n }</p>\n</li>\n</ol>\n<p>}</p>\n<pre><code>逻辑都很简单，直接调用 `createRouteMap` 的方法即可。在添加单个 `route` 时则会处理父级路由和别名的相关逻辑。\n\n`createMatcher` 的返回值中还包括 `match` 方法, 通过这个方法将 `Location` 转化为 `Route`. 这里的 `Location` 就是我们平时使用 push 等方法传入的参数。\n```ts\n type Location = {\n    _normalized?: boolean;\n    name?: string;\n    path?: string;\n    hash?: string;\n    query?: Dictionary&lt;string&gt;;\n    params?: Dictionary&lt;string&gt;;\n    append?: boolean;\n    replace?: boolean;\n}\n\n type RawLocation = string | Location\n</code></pre>\n<p>现在看看 match 方法的执行逻辑</p>\n<pre><code class=\"language-js\">function match (\n    raw: RawLocation,\n    currentRoute?: Route,\n    redirectedFrom?: Location\n): Route {\n    const location = normalizeLocation(raw, currentRoute, false, router)\n    const { name } = location\n    if (name) {\n        const record = nameMap[name]\n\n        if (process.env.NODE_ENV !== &#39;production&#39;) {\n            warn(record, `Route with name &#39;${name}&#39; does not exist`)\n        }\n\n        if (!record) return _createRoute(null, location)\n\n        const paramNames = record.regex.keys\n        .filter(key =&gt; !key.optional)\n        .map(key =&gt; key.name)\n\n        if (typeof location.params !== &#39;object&#39;) {\n        location.params = {}\n        }\n\n        if (currentRoute &amp;&amp; typeof currentRoute.params === &#39;object&#39;) {\n            for (const key in currentRoute.params) {\n                if (!(key in location.params) &amp;&amp; paramNames.indexOf(key) &gt; -1) {\n                    location.params[key] = currentRoute.params[key]\n                }\n            }\n        }\n\n        location.path = fillParams(record.path, location.params, `named route &quot;${name}&quot;`)\n\n        return _createRoute(record, location, redirectedFrom)\n\n    } else if (location.path) {\n        location.params = {}\n        for (let i = 0; i &lt; pathList.length; i++) {\n            const path = pathList[i]\n            const record = pathMap[path]\n            if (matchRoute(record.regex, location.path, location.params)) {\n                return _createRoute(record, location, redirectedFrom)\n            }\n        }\n    }\n    // no match\n    return _createRoute(null, location)\n}\n</code></pre>\n<ul>\n<li>如果 <code>location</code> 包含 <code>name</code> 那么在 <code>nameMap</code> 中通过 <code>name</code> 取到路由</li>\n<li>如果包含 <code>path</code> 则通过遍历 <code>pathList</code> ， 正则匹配到对应的路由\n从这里我们可以知道，如果传递 <code>name</code> 来获取路由是比较方便的，<code>path</code> 的话会进行比较匹配，写在前面会被优先匹配到的</li>\n</ul>\n<p>最终的到的东西就是一个 Route对象</p>\n<pre><code class=\"language-js\">const route: Route = {\n    name: location.name || (record &amp;&amp; record.name),\n    meta: (record &amp;&amp; record.meta) || {},\n    path: location.path || &#39;/&#39;,\n    hash: location.hash || &#39;&#39;,\n    query,\n    params: location.params || {},\n    fullPath: getFullPath(location, stringifyQuery),\n    matched: record ? formatMatch(record) : [] // 这里通过遍历父级，得到完整的路径数组\n  }\n</code></pre>\n<p>由于 这个对象最终被 Object.freeze() ,因此实际使用时，我们无法更改上面的属性</p>\n<h1 id=\"4-内置组件\">4 内置组件</h1>\n<h2 id=\"4-1-router-link\">4. 1 router-link</h2>\n<p>router-link 自动处理了 a 标签 点击跳转的情况，在点击时会触发路由跳转的事件</p>\n<pre><code class=\"language-js\">const handler = e =&gt; {\n    // 默认事件\n    if (guardEvent(e)) {\n        if (this.replace) {\n        router.replace(location, noop)\n\n        } else {\n\n        router.push(location, noop)\n\n        }\n    }\n}\n</code></pre>\n<h2 id=\"42-router-view\">4.2 router-view</h2>\n<pre><code class=\"language-js\">render (_, { props, children, parent, data }) {\n    // routerView标识\n    data.routerView = true\n    const h = parent.$createElement\n    const name = props.name\n    const route = parent.$route\n\n\n  \n    let depth = 0\n    let inactive = false\n    while (parent &amp;&amp; parent._routerRoot !== parent) {\n        const vnodeData = parent.$vnode ? parent.$vnode.data : {}\n        if (vnodeData.routerView) {\n            depth++\n        }\n        // keep-alive 逻辑\n        if (vnodeData.keepAlive &amp;&amp; parent._directInactive &amp;&amp; parent._inactive) {\n            inactive = true\n        }\n        parent = parent.$parent\n\n    }\n    // 得到routerview的深度，确定当前的路由\n    data.routerViewDepth = depth\n\n    // render previous view if the tree is inactive and kept-alive\n    if (inactive) {\n        const cachedData = cache[name]\n        const cachedComponent = cachedData &amp;&amp; cachedData.component\n\n        if (cachedComponent) {\n            if (cachedData.configProps) {\n                fillPropsinData(cachedComponent, data, cachedData.route, cachedData.configProps)\n            }\n            return h(cachedComponent, data, children)\n        } else {\n            return h()\n        }\n    }\n\n    const matched = route.matched[depth]\n    const component = matched &amp;&amp; matched.components[name]\n    // cache component\n    cache[name] = { component }\n\n  \n    // 这个方法也是在初始化的时候进行的调用\n    // 用来设置当前路由匹配的组件实例\n    data.registerRouteInstance = (vm, val) =&gt; {\n        const current = matched.instances[name]\n        if (\n        (val &amp;&amp; current !== vm) ||\n        (!val &amp;&amp; current === vm)\n        ) {\n            matched.instances[name] = val\n        }\n    }\n    // hook注入\n    data.hook.prepatch = (_, vnode) =&gt; {\n        matched.instances[name] = vnode.componentInstance\n    }\n    data.hook.init = (vnode) =&gt; {\n        if (vnode.data.keepAlive &amp;&amp;\n        vnode.componentInstance &amp;&amp;\n        vnode.componentInstance !== matched.instances[name]\n        ) {\n        matched.instances[name] = vnode.componentInstance\n        }\n        handleRouteEntered(route)\n    }\n\n    const configProps = matched.props &amp;&amp; matched.props[name]\n    return h(component, data, children)\n\n}\n</code></pre>\n<p>主要逻辑就是：</p>\n<ol>\n<li>标识当前路由为 routerview</li>\n<li>往父级遍历，得到当前的 routerview 深度，确定 route</li>\n<li>兼容 keep-alive 的逻辑，处理缓存逻辑</li>\n<li>渲染组件</li>\n</ol>\n<h1 id=\"5-最后总结\">5. 最后总结</h1>\n<p>看完核心逻辑后，我最初的疑问基本得到了解答。感觉还是挺有收获的。知道了路由的第三种模式，路由切换的整体过程，路由的匹配逻辑。也了解了 router-view 这种函数式组件的实现。\n我还有一个问题未得到答案</p>\n<pre><code>3. 和Transition是怎么搭配合作的\n</code></pre>\n<p>看来只有到时候看 Vue 源码时才能有收获了.</p>\n"
}