{
    "title": "简单又强大的状态管理 - Zustand",
    "excerpt": "一. 写在前面 React 生态的状态管理库有很多，比如Redux ，Recoil ，Mobx，自身的 context 也可以用来进行状态管理。 首先 Redux 实在说不上是一个合格的状态管理库，功能太基础，结合业务必须使用插件。而且需要...",
    "updated": "2022-07-07 16:11:21 ",
    "created": "2022-07-07 16:11:21 ",
    "avatar": "https://avatars.githubusercontent.com/u/26271337?v=4",
    "id": 20,
    "content": "<h1 id=\"一-写在前面\">一. 写在前面</h1>\n<p>React 生态的状态管理库有很多，比如Redux ，Recoil ，Mobx，自身的 context  也可以用来进行状态管理。</p>\n<p>首先 Redux 实在说不上是一个合格的状态管理库，功能太基础，结合业务必须使用插件。而且需要写的模版代码太多了，开发体验一般般。</p>\n<p>而 Mobx 也不太行，在 class 组件流行时，通过装饰器写 Mobx 还是很爽的。但是 hooks 流行的今天，呃，就这样吧。</p>\n<p><a href=\"https://github.com/pmndrs/zustand\">Zustand</a> 是这么多状态管理库中让我眼前一亮的库。它的代码很少，功能很多。</p>\n<h1 id=\"二-安装\">二. 安装</h1>\n<pre><code class=\"language-shell\">npm install zustand \n</code></pre>\n<h1 id=\"三-快速使用\">三. 快速使用</h1>\n<h2 id=\"31-定义store\">3.1 定义store</h2>\n<pre><code class=\"language-ts\">import create from &#39;zustand&#39;\n\nconst useStore = create((set) =&gt; ({\n  bears: 0,\n  increasePopulation: () =&gt; set((state) =&gt; ({ bears: state.bears + 1 })),\n  removeAllBears: () =&gt; set({ bears: 0 }),\n}))\n</code></pre>\n<p>在 create 时， set 有几种用法</p>\n<ul>\n<li><code>set(obj)</code>  obj 会合并到 state中</li>\n<li><code>set(state =&gt; obj)</code>  函数返回值合并到 state 中</li>\n<li><code>set(obj, true) </code> obj 会取代当前 state</li>\n</ul>\n<p>create 函数中的第二个参数是 <code>get</code>， 我们可以通过 get 获取当前的 state</p>\n<h2 id=\"32-在组件中使用\">3.2 在组件中使用</h2>\n<pre><code class=\"language-ts\">function BearCounter() {\n  const bears = useStore((state) =&gt; state.bears)\n  return &lt;h1&gt;{bears} around here ...&lt;/h1&gt;\n}\n\nfunction Controls() {\n  const increasePopulation = useStore((state) =&gt; state.increasePopulation)\n  return &lt;button onClick={increasePopulation}&gt;one up&lt;/button&gt;\n}\n</code></pre>\n<p>上面都是我从官网中 copy 的代码，实际开发也就是这么写的。可以看出，它的代码真的非常的少，我需要什么，我就定义什么。</p>\n<h1 id=\"四-优势\">四. 优势</h1>\n<p>和 redux 比：</p>\n<ol>\n<li>简单</li>\n<li>hooks 友好</li>\n<li>不需要 context provider</li>\n<li>可以和组件渲染解耦，只更改状态\n```ts\nconst useStore = create(set =&gt; ({ scratches: 0, ... }))</li>\n</ol>\n<p>function Component() {\n  const scratchRef = useRef(useStore.getState().scratches)\n  useEffect(() =&gt; useStore.subscribe(\n    state =&gt; (scratchRef.current = state.scratches)\n  ), [])</p>\n<pre><code>\n和 context 比：\n1. 更少的模版代码\n2. 只在数据变化时更新组件\n3. 集中的、基于操作的状态管理\n\n# 五. 插件\n```ts\nconst log = (config) =&gt; (set, get, api) =&gt;\n  config(\n    (...args) =&gt; {\n      console.log(&#39;  applying&#39;, args)\n      set(...args)\n      console.log(&#39;  new state&#39;, get())\n    },\n    get,\n    api\n  )\n\nconst useStore = create(\n  log((set) =&gt; ({\n    bees: false,\n    setBees: (input) =&gt; set({ bees: input }),\n  }))\n)\n</code></pre>\n<p><code>Zustand</code>的插件也很简单，就是定义一个函数。 上面这个 log 插件也逻辑很清晰，在create 内执行时，对set 方法进行覆写，实现 log 的效果</p>\n<p>我在RN 中开发中需要对数据进行持久化，于是我可以这么写</p>\n<pre><code class=\"language-ts\">TODO\n</code></pre>\n<h1 id=\"六-总结\">六. 总结</h1>\n<p>Zustand 是一个优秀的数据管理库，可以很好的管理应用的状态。逻辑简单，可定制化强。开发 React 应用，Zustand 是不错的选择。</p>\n"
}