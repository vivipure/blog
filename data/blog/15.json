{
    "title": "Vue 源码学习 (2) - Vue 初始化",
    "excerpt": "_init 当我们使用 Vue 2 时，我们会用 Vue 实例化一个应用 `ts const app = new Vue({ render: h => h(App) }).$mount('#app') ` Vue 是一个构造函数，实例化时会...",
    "updated": "2022-07-03 16:39:06 ",
    "created": "2022-06-26 11:36:24 ",
    "avatar": "https://avatars.githubusercontent.com/u/26271337?v=4",
    "id": 15,
    "content": "<h1 id=\"_init\">_init</h1>\n<p>当我们使用 <code>Vue 2</code> 时，我们会用 <code>Vue</code> 实例化一个应用</p>\n<pre><code class=\"language-ts\">const app = new Vue({\n    render: h =&gt; h(App)\n}).$mount(&#39;#app&#39;)\n</code></pre>\n<p> <code>Vue</code>  是一个构造函数，实例化时会调用 <code>this._init(options)</code> 方法.</p>\n<pre><code class=\"language-ts\">function Vue(options) {\n    this._init(options)\n}\n</code></pre>\n<p>找到 <code>core/instance/init.ts</code>文件中，<code>initMixin</code>函数执行时挂载了 <code>_init</code>方法</p>\n<pre><code class=\"language-ts\">Vue.prototype._init = function (options?: Record&lt;string, any&gt;) {\nconst vm: Component = this\n    // a uid\n    vm._uid = uid++\n    if (options &amp;&amp; options._isComponent) {\n        initInternalComponent(vm, options as any)\n    } else {\n        vm.$options = mergeOptions(\n        resolveConstructorOptions(vm.constructor as any),\n        options || {},\n        vm\n        )\n    }\n    initLifecycle(vm)\n    initEvents(vm)\n    initRender(vm)\n    callHook(vm, &#39;beforeCreate&#39;)\n    initInjections(vm) \n    initState(vm)\n    initProvide(vm) \n    callHook(vm, &#39;created&#39;)\n\n    if (vm.$options.el) {\n        vm.$mount(vm.$options.el)\n    }\n}\n</code></pre>\n<p>这里的逻辑我大致讲一下，</p>\n<ol>\n<li><code>uid</code> 递增</li>\n<li>往实例上加一些属性标识</li>\n<li><code>$options</code> 初始化，合并 <code>extend</code>, <code>mixin</code> 等</li>\n<li>初始化声明周期，初始化 <code>render</code></li>\n<li><code>beforeCreate</code></li>\n<li>初始化 <code>inject</code></li>\n<li>初始化 <code>props</code> -&gt; <code>methods</code> -&gt; <code>data</code> -&gt; <code>computed</code> -&gt; <code>watch</code></li>\n<li>初始化 <code>provide</code></li>\n<li><code>created</code></li>\n<li>开始 <code>$mount</code></li>\n</ol>\n<h1 id=\"mount\">$mount</h1>\n<p>上面的流程大致过下，接下来我们看看 <code>$mount</code> 执行的过程。</p>\n<p>在 <code>web/runtime-with-compiler.ts</code>中我们讲过，这里将 <code>compileToFunctions</code> 函数引入进来，用于讲 <code>template</code> 转化成 <code>render</code> 函数，这里我们也讲一下详细的逻辑</p>\n<pre><code class=\"language-ts\">// 不能挂在到 html 或者 body 下\nif (el === document.body || el === document.documentElement)\n    return \nif (!options.render) {\n    // 如果template存在\n        // 字符串 \n            // 直接解析\n            // 通过id 获取元素，然后获取innerHTML\n        // 元素 获取 innerHTML\n    // 如果templet 不存在 ，el 存在 获取 outerHTML\n    \n    // 执行compileToFunctions 得到render\n    \n    // 执行缓存的原方法\n    return mount.call(this, el, hydrating)\n}\n</code></pre>\n<p>来到 <code>web/runtime/index.ts</code>， 这里就是 <code>runtime</code> 时<code> $mount</code> 方法</p>\n<pre><code class=\"language-ts\">Vue.prototype.$mount = function (\n    el?: string | Element,\n    hydrating?: boolean\n\n    ): Component {\n    el = el &amp;&amp; inBrowser ? query(el) : undefined\n    return mountComponent(this, el, hydrating)\n}\n</code></pre>\n<p>这里调用了 <code>core/instance/lifecycle</code>的 <code>mountComponent</code> 方法</p>\n<pre><code class=\"language-ts\">export function mountComponent(\nvm: Component,\nel: Element | null | undefined,\nhydrating?: boolean\n): Component {\n    // 声明 $el，检查render\n    vm.$el = el\n    if (!vm.$options.render) {\n        vm.$options.render = createEmptyVNode\n    }\n    \n    callHook(vm, &#39;beforeMount&#39;)\n    \n    let updateComponent = () =&gt; {\n        vm._update(vm._render(), hydrating)\n    }\n    const watcherOptions: WatcherOptions = {\n        before() {\n            if (vm._isMounted &amp;&amp; !vm._isDestroyed) {\n                callHook(vm, &#39;beforeUpdate&#39;)\n            }\n        }\n    }\n\n    new Watcher(\n        vm,\n        updateComponent,\n        noop,\n        watcherOptions,\n        true /* isRenderWatcher */\n    )\n    if (vm.$vnode == null) {\n        const preWatchers = vm._preWatchers\n        if (preWatchers) {\n            for (let i = 0; i &lt; preWatchers.length; i++) {\n                preWatchers[i].run()\n            }\n        }\n        vm._isMounted = true\n        callHook(vm, &#39;mounted&#39;)\n    }\n\n    return vm\n\n}\n</code></pre>\n<p>这里实例化了一个 渲染的 <code>Watcher</code>, 在它的回调中会调用 <code>updateComponent</code> 方法，执行 <code>_render</code>，<code>_update</code> 更新 <code>DOM</code></p>\n<p>这里还有一个判断 <code>vm.$node === null</code>, 这里 <code>$node</code> 表示父 <code>vnode</code>，为 <code>null</code> 则表示为根结点的实例.</p>\n<p>Watcher 我们先不看，这主要是响应式原理和依赖收集相关的部分，我们继续看 <code>_render</code> , <code>_update</code> 方法的逻辑.</p>\n<h1 id=\"_render\">_render</h1>\n<p>在 <code>instance/render.ts</code>中，<code>renderMixin</code> 函数注册了 <code>_render</code> 方法.</p>\n<pre><code class=\"language-ts\">Vue.prototype._render = function (): VNode {\n    const vm: Component = this\n    const { render, _parentVnode } = vm.$options\n\n    vm.$vnode = _parentVnode!\n    let vnode = render.call(vm._renderProxy, vm.$createElement)\n    \n    // set parent\n    vnode.parent = _parentVnode\n    return vnode\n}\n</code></pre>\n<p><code>_render</code> 函数调用 <code>render</code> 生成 <code>vnode</code> 进行返回</p>\n<p>平时我们使用 <code>render</code> 函数时是这么写的：</p>\n<pre><code class=\"language-js\">render: h =&gt; h(&#39;div&#39;, {}, &#39;&#39;)\n</code></pre>\n<p>这里的 <code>h</code> 就对应了 <code>vm.$reateElement</code>, 而 <code>renderProxy</code> 就是响应式的数据</p>\n<p>其中 <code>vm.$createElement</code> 在 <code>initRender</code> 时进行了注册，实际上也是对 <code>createElement</code> 方法进行了封装。</p>\n<h1 id=\"createelement\">createElement</h1>\n<p>在 <code>core/vdom/create-element.ts</code>中定义了 <code>createElement</code> 函数，该函数是对 <code>_createElement</code> 的封装，让参数更加灵活</p>\n<pre><code class=\"language-ts\">export function _createElement(\n    context: Component,\n    tag?: string | Component | Function | Object,\n    data?: VNodeData,\n    children?: any,\n    normalizationType?: number\n): VNode | Array&lt;VNode&gt; {\n\n    // 处理 :is\n    if (isDef(data) &amp;&amp; isDef(data.is)) {\n        tag = data.is\n    }\n\n    if (normalizationType === ALWAYS_NORMALIZE) {\n        children = normalizeChildren(children)\n    } else if (normalizationType === SIMPLE_NORMALIZE) {\n        children = simpleNormalizeChildren(children)\n    }\n\n    let vnode, ns\n    if (typeof tag === &#39;string&#39;) {\n        let Ctor\n        if (config.isReservedTag(tag)) {\n            vnode = new VNode(\n                config.parsePlatformTagName(tag),\n                data,\n                children,\n                undefined,\n                undefined,\n                context\n            )\n\n        } else if (...) {\n            vnode = createComponent(Ctor, data, context, children, tag)\n        } else {\n            vnode = new VNode(tag, data, children, undefined, undefined, context)\n\n        }\n    } else {\n        // direct component options / constructor\n        vnode = createComponent(tag as any, data, context, children)\n    }\n\n    return vnode\n}\n</code></pre>\n<p>这里主要执行的逻辑是，先将 <code>children</code> 规范为 <code>VNode</code> 数组，<code>normalizationType</code> 标识规范类型。</p>\n<p>然后创建 <code>VNode</code>, 对 <code>tag</code> 进行判断,</p>\n<ul>\n<li>. 如果是 <code>tag</code> 是 <code>string</code> 类型<ul>\n<li>. 内置 <code>HTML</code> 元素的话，直接创建普通 <code>node</code></li>\n<li>. 已经注册过的组件名，则使用 <code>createComponent</code> 创建组件 <code>VNode</code></li>\n<li>. 创建未知标签的 <code>vnode</code></li>\n</ul>\n</li>\n<li>. 如果是 <code>component</code> 类型，直接创建 <code>component</code> 组件 <code>VNode</code></li>\n</ul>\n<p>到这里我们大致讲完了 <code>createElement</code> 的逻辑了。</p>\n<h1 id=\"update\">update</h1>\n<p>在 <code>mountComponent</code>方法中，<code>_render</code>执行完成后，会执行<code>_update</code> 方法</p>\n<pre><code class=\"language-ts\">vm._update(vm._render(), hydrating)\n</code></pre>\n<p>查看 <code>_update</code> 方法</p>\n<pre><code class=\"language-ts\">Vue.prototype._update = function (vnode: VNode, hydrating?: boolean) {\n    const vm: Component = this\n    const prevEl = vm.$el\n    const prevVnode = vm._vnode\n    const restoreActiveInstance = setActiveInstance(vm)\n    vm._vnode = vnode\n\n\n    if (!prevVnode) {\n        // initial render\n        vm.$el = vm.__patch__(vm.$el, vnode, hydrating, false)\n    } else {\n        vm.$el = vm.__patch__(prevVnode, vnode)\n    }\n\n    restoreActiveInstance()\n\n    // update __vue__ reference\n    if (prevEl) {\n    prevEl.__vue__ = null\n    }\n    if (vm.$el) {\n    vm.$el.__vue__ = vm\n    }\n\n    // if parent is an HOC, update its $el as well\n    if (vm.$vnode &amp;&amp; vm.$parent &amp;&amp; vm.$vnode === vm.$parent._vnode) {\n        vm.$parent.$el = vm.$el\n    }\n\n}\n</code></pre>\n<p>这里的核心逻辑是 <code>__patch__</code> 方法. 由于 <code>Vue</code> 不只面向 <code>web</code> 平台， 也会处理其他平台的逻辑，例如<strong>死去的</strong> <code>Weex</code>. 而且在 <code>Vue SSR</code> 时，也是不需要 <code>patch的</code>。这里我们看 <code>web</code> <code>端的patch</code> 方法。</p>\n<pre><code class=\"language-ts\">\nfunction createPatchFunction({ nodeOps, modules }) {\n    return function patch(oldVnode, vnode, hydrating, removeOnly) {\n\n    let isInitialPatch = false\n    const insertedVnodeQueue: any[] = []\n\n    if (isUndef(oldVnode)) {\n        isInitialPatch = true\n        createElm(vnode, insertedVnodeQueue)\n    } else {\n        const isRealElement = isDef(oldVnode.nodeType)\n        oldVnode = emptyNodeAt(oldVnode)\n        // replacing existing element\n        const oldElm = oldVnode.elm\n        const parentElm = nodeOps.parentNode(oldElm)\n        // create new node\n        createElm(\n            vnode,\n            insertedVnodeQueue,\n            oldElm._leaveCb ? null : parentElm,\n            nodeOps.nextSibling(oldElm)\n        )\n\n        // update parent placeholder node element, recursively\n        if (isDef(vnode.parent)) {\n            let ancestor = vnode.parent\n            const patchable = isPatchable(vnode)\n            while (ancestor) {\n                for (let i = 0; i &lt; cbs.destroy.length; ++i) {\n                    cbs.destroy[i](ancestor)\n                }\n                ancestor.elm = vnode.elm\n\n                if (patchable) {\n                    for (let i = 0; i &lt; cbs.create.length; ++i) {\n                        cbs.create[i](emptyNode, ancestor)\n                    }\n\n                    const insert = ancestor.data.hook.insert\n                    if (insert.merged) {\n                        for (let i = 1; i &lt; insert.fns.length; i++) {\n                            insert.fns[i]()\n                        }\n                    }\n                } else {\n                    registerRef(ancestor)\n                }\n            ancestor = ancestor.parent\n            }\n        }\n\n        if (isDef(parentElm)) {\n            removeVnodes([oldVnode], 0, 0)\n        } else if (isDef(oldVnode.tag)) {\n            invokeDestroyHook(oldVnode)\n        }\n\n        invokeInsertHook(vnode, insertedVnodeQueue, isInitialPatch)\n        return vnode.elm\n    }\n}\n</code></pre>\n<p>这里主要通过 <code>cretateElem</code> 创建元素</p>\n<pre><code class=\"language-ts\">if (isDef(vnode.elm) &amp;&amp; isDef(ownerArray)) {\n    vnode = ownerArray[index] = cloneVNode(vnode)\n}\n\nconst data = vnode.data\nconst children = vnode.children\nconst tag = vnode.tag\nif (isDef(tag)) {\n    vnode.elm = vnode.ns\n    ? nodeOps.createElementNS(vnode.ns, tag)\n    : nodeOps.createElement(tag, vnode)\n    \n    setScope(vnode)\n    createChildren(vnode, children, insertedVnodeQueue)\n    if (isDef(data)) {\n        invokeCreateHooks(vnode, insertedVnodeQueue)\n    }\n    insert(parentElm, vnode.elm, refElm)\n\n} else if (isTrue(vnode.isComment)) {\n    vnode.elm = nodeOps.createComment(vnode.text)\n    insert(parentElm, vnode.elm, refElm)\n} else {\n    vnode.elm = nodeOps.createTextNode(vnode.text)\n    insert(parentElm, vnode.elm, refElm)\n\n}\n</code></pre>\n<p>这里的逻辑就是通过 <code>VNode</code> 创建正式的 <code>DOM</code> 然后插入到它的父节点中。</p>\n<p>这里先创建 <code>elm</code> 元素，然后创建 <code>children</code>，遍历子节点，递归调用 <code>createElm</code>, 然后调用 <code>invokeCreateHook</code>。</p>\n<p>最后调用 <code>insert</code> 方法插入到 父节点，所以插入节点的顺序是 子&gt;父 的。</p>\n<h1 id=\"总结\">总结</h1>\n<p>最后回顾下整个 Vue 初始化的流程：</p>\n<ol>\n<li><code>init</code> 初始化声明周期，数据</li>\n<li><code>$mount</code> 开始挂载</li>\n<li><code>compile  template to render fn</code></li>\n<li><code>render</code> 生成 <code>VNode</code></li>\n<li><code>patch VNode</code>  到 <code>DOM</code> 上</li>\n</ol>\n<p>从 <code>patch</code> 的过程我们也知道了从 虚拟节点 到 DOM 的一个生成逻辑，所以有一个常见的面试题，就是父子组件的生命周期问题，这个问题的答案现在就很简单了</p>\n<pre><code>父亲：F  子组件： C\n\nF beforeCreate -&gt; created -&gt; beforeMount -&gt; C beforeCreate -&gt; created -&gt; beforeMount -&gt; Mounted -&gt; F Mounted\n</code></pre>\n<p>上面我们大致讲了下 <code>patch</code> 的过程，很多关于 新旧节点的比较逻辑，diff 算法优化并没有细聊。后续会有文章, 我们接着聊。</p>\n"
}