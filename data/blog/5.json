{
    "title": "Vue2 组件开发",
    "excerpt": "TL,DR Vue2 作为平时开发中最常用的框架，我在进行业务开发时对于组件拆分和设计还是比较有心得的。开发体验也还算友好，但是还是存在很多问题。本文会介绍一些常用的技巧和框架本身存在的一些问题。 一. 基本知识 1.1 组件使用 Vue中...",
    "updated": "2022-06-09 16:04:58 ",
    "created": "2022-06-05 15:32:49 ",
    "avatar": "https://avatars.githubusercontent.com/u/26271337?v=4",
    "id": 5,
    "content": "<h1 id=\"tldr\">TL,DR</h1>\n<p>Vue2 作为平时开发中最常用的框架，我在进行业务开发时对于组件拆分和设计还是比较有心得的。开发体验也还算友好，但是还是存在很多问题。本文会介绍一些常用的技巧和框架本身存在的一些问题。</p>\n<h1 id=\"一-基本知识\">一. 基本知识</h1>\n<h2 id=\"11-组件使用\">1.1 组件使用</h2>\n<p>Vue中组件使用十分的简单，<code>import</code>+<code>components中声明</code>+<code>template中使用</code>，当然也可以在全局中进行注册。</p>\n<h2 id=\"12-组件开发\">1.2 组件开发</h2>\n<p>在开发中，Vue的每个<code>SFC</code> 都是一个组件。Vue2 通过声明Options来定义组件。</p>\n<h2 id=\"13-状态管理\">1.3 状态管理</h2>\n<p>在组件中，我们在数据变化后更新 View , View 控制数据的变化, <code>data-view-action</code>  可以简单概述组件中整体变化的一个过程。</p>\n<p>但是在实际的开发场景中，往往是多个组件公用一些状态，可能是兄弟组件，也有可能是层级差别较大的组件。</p>\n<p>如果涉及组件较少，<code>event-bus</code>也能够用。如果需要共享数据的组件较多的话，选择状态管理库会比较合适。</p>\n<h1 id=\"二-高级技巧\">二. 高级技巧</h1>\n<p>没错，稍微讲下基础知识就直接来到高级技巧了。</p>\n<h2 id=\"21-extends\">2.1 extends</h2>\n<blockquote>\n<p>优雅其实很简单</p>\n</blockquote>\n<p>当我们平时使用UI库时会根据业务需求进行改造组件，简单的样式更改通过样式穿透和重置就能处理。对于业务逻辑的修改，很多同学可能会直接复制文件进行更改，这是一个办法。</p>\n<p>之前项目时，我通过手动实现方法继承和覆盖，但还是比较的麻烦</p>\n<pre><code class=\"language-jsx\">export default {\n    componets: {\n        ComponentA,\n    },\n    render(h) {\n        return h(ComponentA,\n            {\n                props: this.$attrs,\n                on: this.listeners,\n                ref: &#39;A&#39;,\n            },...)\n    },\n    mounted() {\n        for (let key in this.$refs.A) {\n        if (!(key in this) &amp;&amp; typeof this.$refs.A[key] === &#39;function&#39;) {\n            this[key] = this.$refs.table[key]\n        }\n    }\n    }\n}\n</code></pre>\n<p>使用<code>extends</code> 就很简单，<a href=\"https://v2.vuejs.org/v2/api/#extends\">extends</a> 的用法就是扩展一个组件</p>\n<pre><code class=\"language-jsx\">// componentB\nexport default {\n    extends: ComponentA,\n    ...\n}\n</code></pre>\n<p>通用extends就是继承一个组件，可以覆盖和扩展一些方法,当然也可以更改视图的一些展示。</p>\n<h2 id=\"22-mixin\">2.2 Mixin</h2>\n<blockquote>\n<p>逻辑隔离还是公用，它都可以</p>\n</blockquote>\n<p><code>mixin</code> 常用来做一些逻辑的抽离。这里我举一个我实际开发中的使用场景。 </p>\n<p>eg: 当前有一个列表展示数据，每个数据都有10几种操作，会调用不同的弹窗，接口，提醒等。与此同时列表还要支持两种展示方式，卡片和Table.</p>\n<p>在这个需求里，我通过minix对每一种操作进行拆分，每一个操作都是单独的mixin。每个minxin里面都包含操作对应的展示校验逻辑和实际的业务逻辑。</p>\n<p>对于每个mixin中的公用的函数和状态，就放在混入的组件中，进行公用即可。</p>\n<p>最后将所有操作形成的数组传入到列表的展示项中，实现了不同的展示形式公用相同的逻辑，避免了代码的重复。</p>\n<p>好处： 不同的业务逻辑进行了隔离，避免了组件的膨胀，很好的支持修改和扩展</p>\n<p>坏处： minix的缺点也比较明显，只能公用逻辑。视图还是需要放到主组件中，这会造成视图和逻辑分离的问题。因此在进行视图操作和公用状态的处理时，需要进行仔细核对。</p>\n<p>实际场景中可以根据需求封装mixin, 可以封装成函数处理不同数据的场景，可以在mixin中开发公用的逻辑，维护公用的状态。</p>\n<h2 id=\"23-vueextend\">2.3 Vue.extend</h2>\n<blockquote>\n<p>说是银弹，未尝不可 </p>\n</blockquote>\n<p>在使用Element-ui时，我们可以通过函数的形式调用组件。在翻看代码后，我知道了Vue.extend这个方法。其实Vue源码中，Vue组件在实际使用时也会通过这个方法进行组件的生产，这里我们就不深入聊下去了。</p>\n<p>介绍下这个方法，Vue.extend可以将组件转化为一个构造函数，通过实例化构造函数，就能生成组件。</p>\n<p>因此我们可以通过Vue.extend将对应的组件转化构造函数，然后封装一个函数进行组件的生成，挂载和更新等操作。常用的一些弹窗组件都可以通过这种形式进行开发</p>\n<pre><code class=\"language-jsx\">import Vue from &#39;vue&#39;\n\nexport const componetToFunction = function (componet) {\n    return function (options = {}) {\n        let parent = document.body\n        const ComponetConstructor = Vue.extend(componet)\n        const dom = document.createElement(&#39;div&#39;)\n        parent.appendChild(dom)\n        const instance = new ComponetConstructor({\n            props: options,\n        })\n\n        for (let prop in options) {\n            if (options.hasOwnProperty(prop)) {\n                instance[prop] = options[prop]\n            }\n        }\n\n        instance.$mount(dom)\n\n        return instance\n    }\n}\n\n// 使用时\nconst renderA = componetToFunction(ComponentA)\nrenderA({a:1,b:2})\n</code></pre>\n<p>当然你也可以通过 闭包实现单例和组件更新等逻辑，根据具体场景进行使用。非常好用</p>\n<p>关于Vue.extend的坑，我也专门有进行总结，<a href=\"https://github.com/vivipure/TIL/issues/8\">链接在这</a></p>\n<h2 id=\"24-slot\">2.4 Slot</h2>\n<blockquote>\n<p>基本知识，你知我知</p>\n</blockquote>\n<p>插槽其实也不用多介绍了，更多的场景还是布局的复用。知道具名插槽，默认插槽和作用域插槽各种使用方法即可</p>\n<h2 id=\"25-v-model\">2.5 v-model</h2>\n<blockquote>\n<p>表单再复杂，有它我不怕</p>\n</blockquote>\n<p>在Vue中我们可以通过v-model指令实现双向绑定。它的原理其实也很简单，其实就是作为语法糖封装了value和updateValue的逻辑。</p>\n<p>在Vue中也允许我们自定义v-model。</p>\n<pre><code class=\"language-jsx\">props:[&#39;value&#39;],\nmodel: {\n    prop: &#39;value&#39;,\n    event: &#39;update:value&#39;\n},\nmethods: {\n    update(value) {\n        this.$emit(&#39;update:value&#39;, value)\n    }\n}\n</code></pre>\n<p>通过model声明组件v-model绑定的值和更新值的事件即可。 因此在做一些富文本输入框，图片上传组件之类输入的组件时，使用v-model会比较合适。</p>\n<p>在我平时的开发中，我会用来做表单的抽离。例如</p>\n<pre><code class=\"language-jsx\">&lt;AreaSelect v-model=&quot;config&quot; /&gt;\n&lt;TimeSelect v-model=&quot;config&quot; /&gt;\n</code></pre>\n<p>当新增的组件需要改好几个值时，也能通过这种方式进行开发，v-model支持更改对象。不过我常常使用data保存对应的引用值直接进行更改，不会进行报错，也比较简单。</p>\n<p>同时注意watch下props传入的值，数据更改后要即使更改data中的值。还有分发事件时，要先触发model的事件，在分发change的事件，不然外部在使用change时拿不到正确的值。</p>\n<p>如果你像我一样在表单中使用的话，记得写验证和清除验证相关的方法供父组件进行使用</p>\n<h2 id=\"26-directives\">2.6 directives</h2>\n<blockquote>\n<p>指令：执行</p>\n</blockquote>\n<p>自定义指令的具体写法我就不写了，也很简单。说一下常用的场景吧，例如对dom的一些操作，输入处理，还有事件绑定都可以通过指令的方式进行处理。</p>\n<p>我的开发中就使用过埋点，拖拽，节流等指令。</p>\n<p>这里需要注意一个点，如果指令需要维持一些数据的话，可以绑定到el上。</p>\n<h2 id=\"27-providereject\">2.7 provide/reject</h2>\n<p>可以通过provide和reject让组件跨级别共享状态，类似React.context. </p>\n<p>如果需要往自组件传递太多的数据，可以考虑用这种方式，而不是用<code>props</code></p>\n<ol>\n<li>需要注意的是如果组件之间存在其他的provide和reject会使reject受到最近的的provide数据。</li>\n<li>共享的数据不是响应式的，可以通过函数的方式进行获取</li>\n</ol>\n<h1 id=\"3-还有点东西\">3. 还有点东西</h1>\n<ol>\n<li>弹窗组件最好放在body下，毕竟fixed会受到css样式的影响，要保证好遮罩层的层级</li>\n<li>弹窗组件如果不是必要，就单独放一个文件吧</li>\n<li>别让组件拥有太多状态，而是不同状态对应不同的组件</li>\n<li>如果一个值传递的层级太深，就把它放到全局状态吧</li>\n</ol>\n<h1 id=\"4-最后再说说\">4. 最后再说说</h1>\n<p>Vue2作为渐进式框架，无论是小应用还是大应用，组件开发是完全能够cover的住的。</p>\n<p>但是Vue Options Api中数据和方法的隔离【物理行数的隔离】导致可读性较差。</p>\n<p>与此同时TS支持较弱，导致开发时组件的传值无法智能提醒。</p>\n<p>mixin不是好的实现方式，视图和数据的分离导致可读性变差。</p>\n<p>好在Vue3来了，TS + Composition Api 让开发体验大大提升，后面将会有文章介绍下Vue3的相关特性。</p>\n"
}