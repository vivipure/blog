{
    "title": "TypeScript  tricks",
    "excerpt": "Utility Types Omit Omit 可以忽略对象类型中的某些属性 `ts type User = { name: string age: number id: string } type SimpleUser = Omit ` ...",
    "updated": "2022-10-28 01:55:18 ",
    "created": "2022-07-12 15:57:04 ",
    "avatar": "https://avatars.githubusercontent.com/u/26271337?v=4",
    "id": 19,
    "content": "<h1 id=\"utility-types\">Utility Types</h1>\n<h2 id=\"omit\">Omit</h2>\n<p><code>Omit</code> 可以忽略<code>对象类型</code>中的某些属性</p>\n<pre><code class=\"language-ts\">type User = {\n  name: string\n  age: number\n  id: string\n}\n\ntype SimpleUser = Omit&lt;User, &quot;name&quot; &gt;\n</code></pre>\n<p>等同于</p>\n<pre><code class=\"language-ts\">type SimpleUser = {\n     age: number;\n     id: string;\n}\n</code></pre>\n<p>自身实现,利用Exclude 剔除属性</p>\n<pre><code class=\"language-ts\">type OwnOmit&lt;T , P extends keyof T&gt; = {\n  [K in Exclude&lt;keyof T, P&gt;]: T[K]\n}\n</code></pre>\n<h2 id=\"pick\">Pick</h2>\n<p><code>Pick</code> 的功能和 <code>Omit</code> 相反，<code>Pick</code> 筛选出 <code>对象类型</code>中需要的属性</p>\n<pre><code class=\"language-ts\">type SimpleUser = Pick&lt;User, &quot;name&quot; &gt;\n</code></pre>\n<p>等同于</p>\n<pre><code class=\"language-ts\">type SimpleUser = {\n     name: string;\n}\n</code></pre>\n<p>本身的实现也很简单</p>\n<pre><code class=\"language-ts\">type OwnPick&lt;T , P extends keyof T&gt; = {\n  [K in P]: T[K]\n}\n</code></pre>\n<h2 id=\"exclude\">Exclude</h2>\n<p><code>Omit</code>的实现有用到 Exclude, 它的作用就是将第一个类型中，符合第二个类型中条件的类型剔除</p>\n<p>对于 对象类型等，第二个类型是第一个类型的子集也可以达到效果</p>\n<pre><code class=\"language-ts\">type TextExclude = Exclude&lt;&#39;number&#39; | &#39;age&#39;, &#39;age&#39;&gt; // &#39;number&#39;\n</code></pre>\n<p>自身实现</p>\n<pre><code class=\"language-ts\">type MyExclude&lt;T, U&gt; = T extends U ? never : T\n</code></pre>\n<h2 id=\"extract\">Extract</h2>\n<p><code>Extract</code>的功能和 <code>Exclude</code> 相反, 它的作用就是将第一个类型中，符合第二个类型筛选的类型保留</p>\n<pre><code class=\"language-ts\">type TextExclude = Exclude&lt;&#39;number&#39; | &#39;age&#39;, &#39;age&#39;&gt; //  &#39;age&#39;\n</code></pre>\n<p>自身实现</p>\n<pre><code class=\"language-ts\">type MyExclude&lt;T, U&gt; = T extends U ? T:  never\n</code></pre>\n<h2 id=\"partial\">Partial</h2>\n<p> <code>Partial</code>可以让<code>对象类型</code>的每个属性变为可选</p>\n<pre><code class=\"language-ts\">type UserPartial = Partial&lt;User&gt;\n</code></pre>\n<p>等同于</p>\n<pre><code class=\"language-ts\">type UserPartial = {\n    name?: string | undefined;\n    age?: number | undefined;\n    id?: string | undefined;\n}\n</code></pre>\n<p>自身实现</p>\n<pre><code class=\"language-ts\">type OwnPartial&lt;T&gt; = {\n  [K in keyof T]?: T[K]\n}\n</code></pre>\n<h2 id=\"required\">Required</h2>\n<p><code>Required</code>可以让<code>对象类型</code>的的每个属性都变为必须</p>\n<pre><code class=\"language-ts\">type UserRequired = Required&lt;UserPartial&gt;\n</code></pre>\n<p>等同于</p>\n<pre><code class=\"language-ts\">type UserRequired = {\n    name: string;\n    age: number;\n    id: string;\n}\n</code></pre>\n<p><code>Required</code> 的实现 使用了 <code>-?</code> ，语法奇怪但是很好理解</p>\n<pre><code class=\"language-ts\">type OwnRequired&lt;T&gt; = {\n  [K in keyof T]-?: T[K]\n}\n</code></pre>\n<h2 id=\"record\">Record</h2>\n<p><code>Record</code> 可以定义<code>对象类型</code> 键和值的类型</p>\n<pre><code class=\"language-ts\">type A = Record&lt;string, {name: string}&gt;\n</code></pre>\n<p>自身实现</p>\n<pre><code class=\"language-ts\">type OwnRecord&lt;Key extends number | string | symbol , Value&gt; = {\n  [key in Key]: Value\n}\n</code></pre>\n<h2 id=\"returntype\">ReturnType</h2>\n<p><code>ReturnType</code> 可以返回<code>函数类型</code>的返回值类型</p>\n<pre><code class=\"language-ts\">function test(username: string, password: string) {\n  return { username, password }\n}\n\ntype TestReturnType = ReturnType&lt;typeof test&gt;\n</code></pre>\n<p>等同于</p>\n<pre><code class=\"language-ts\">type TestReturnType = {\n    username: string;\n    password: string;\n}\n</code></pre>\n<p>自身实现</p>\n<pre><code class=\"language-ts\">type OwnReturnType&lt;T extends (...args: any[]) =&gt; any&gt; = T extends (...args: any[]) =&gt; infer R ? R: unknown\n</code></pre>\n<h2 id=\"parameters\">Parameters</h2>\n<p><code>Parameters</code> 可以返回 <code>函数类型</code>的参数类型</p>\n<pre><code class=\"language-ts\">function test(username: string, password: string) {\n  return { username, password }\n}\n\ntype TestParameterType = Parameters&lt;typeof test&gt;\n</code></pre>\n<p>等同于</p>\n<pre><code class=\"language-ts\">type TestParameterType = [username: string, password: string, age: number]\n</code></pre>\n<p>它的实现也是通过 <code>infer </code>来进行实现</p>\n<pre><code class=\"language-ts\">type OwnParameters&lt;T extends (...args: any[]) =&gt; any&gt; = T extends (...args: infer P) =&gt; any ? P : unknown\n</code></pre>\n<h2 id=\"awaited\">Awaited</h2>\n<p>对于 <code>async</code> 函数或者返回一个 <code>promise</code>值时， 我们可以通过 <code>Awaited</code> 得到未被<code>Promise</code>包裹的类型</p>\n<pre><code class=\"language-ts\">async function testUser() {\n  return 2\n}  \n\n\ntype TestUserResult1 = ReturnType&lt;typeof testUser&gt; // Promise&lt;number&gt;\n\ntype TestUserResult = Awaited&lt;ReturnType&lt;typeof testUser&gt;&gt; // number\n</code></pre>\n"
}