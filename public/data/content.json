{
    "1": {
        "content": "<h3 id=\"写博客的原因\">写博客的原因</h3>\n<p>主要是对自己平时的工作做技术沉淀，用有道云笔记其实也够用。但是我还是希望能够在公共平台进行发布，希望自己遇到的一些问题和解决方案可以对其他人有些帮助。</p>\n<h3 id=\"技术选型\">技术选型</h3>\n<p>对自己的技术博客选型了很久，最后还是选择了github。主要原因还是因为懒，github issues作为CMS完全够用了。后续配合SSG生产静态网页是比较好的方案了。</p>\n<h3 id=\"写在最后\">写在最后</h3>\n<p>现在是2022年的1月，希望从今年开始能够经常进行写作，提高自己的文字表达能力。</p>\n",
        "title": "第一篇博客",
        "created": "2022-01-16 13:10:28  ",
        "updated": "2022-05-25 13:32:29 ",
        "excerpt": "写博客的原因 主要是对自己平时的工作做技术沉淀，用有道云笔记其实也够用。但是我还是希望能够在公共平台进行发布，希望自己遇到的一些问题和解决方案可以对其他人有些帮助。 技术选型 对自己的技术博客选型了很久，最后还是选择了github。主要原因...",
        "avatar": "https://avatars.githubusercontent.com/u/26271337?v=4",
        "id": "1"
    },
    "2": {
        "content": "<p>现代前端开发都讲究模块化开发，作为打包界的扛把子，Webpack对与整个前端生态有着巨大的影响。但是随着Vite,ESBuild等后起之秀的崛起，webpack本身存在的问题就愈发明显。无论是繁琐的配置文件，还是奇慢无比的构建速度都令人望而却步。 </p>\n<p>Webpack官方也知道自身的问题，于是Webpack 5 来了</p>\n<h1 id=\"1-它的变化\">1. 它的变化</h1>\n<p>版本来到了5，Webpack有了以下这些变化：</p>\n<h2 id=\"11-基于文件系统的缓存\">1.1 基于文件系统的缓存</h2>\n<pre><code class=\"language-jsx\">{\n    cache: &quot;filesystem&quot;\n}\n</code></pre>\n<p>新增的缓存的功能让开发者在首次构建后享受缓存带来的构建速度提升（是的，首次还是很慢），实际测试后，无论是直接构建还是热更新开发，首次之后的重新构建时间只有几秒，热更新甚至少于1s.</p>\n<p>开启了这个功能之后，会在<code>node_modules</code>文件下多一个<code>.cache</code>的文件夹，里面会存放之前构建产生的缓存。但是这个功能还是存在问题，由于缓存的存在，<strong>新添加的插件或者热更新被打断后重新运行都有几率报错</strong>。遇到这个问题，删除<code>.cache</code>文件夹就好了\n<img src=\"https://user-images.githubusercontent.com/26271337/168218613-bf34cc73-facf-4c9c-a66c-f0c73ba3fdd5.png\" alt=\"image\"></p>\n<h2 id=\"12-asset-modules\">1.2 Asset Modules</h2>\n<p>Webpack 5 新增了Asset Module,取代了之前版本需要下载的 <code>raw-load,</code> <code>url-loader</code>, <code>file-loader</code>.</p>\n<p>Asset Modules总共有四种类型</p>\n<ol>\n<li><p>asset/resource </p>\n<p> 用于文件的处理，替换了<code>file-loader</code></p>\n<pre><code class=\"language-jsx\">{\n    test: /\\.(mp4|mp3|wav)$/,\n    type: &#39;asset/resource&#39;,\n    generator: {\n        filename: &#39;res/video/[name][ext]&#39;,\n    }\n},\n</code></pre>\n</li>\n<li><p>asset/inline </p>\n<p>   替换了 <code>url-loader</code>, 会将文件转化为data URL</p>\n</li>\n<li><p>asset/source </p>\n<p> 替换了 <code>raw-loader</code> ,会直接导入文件的内容</p>\n</li>\n<li><p>asset (默认)</p>\n<p> 会自动选择生产文件还是生成data URL, 可以进行设置maxSize来进行判断处理</p>\n</li>\n</ol>\n<pre><code class=\"language-jsx\">{\n    test: /\\.(woff2|ttf|woff|png|svg|eot|jpg)$/,\n    type: &#39;asset&#39;,\n    parser: {\n        dataUrlCondition: {\n            maxSize: 100000\n        }\n    },\n    generator: {\n        filename: &#39;res/[hash][ext]&#39;,\n    }\n}\n</code></pre>\n<p>因为Webpack 内置了这个所以之前的<code>url-loader</code>  等依赖也无法在Webpack 5下生效</p>\n<h2 id=\"13-module-federation\">1.3 Module Federation</h2>\n<p>Webpack 5的更新中，这个功能最有用（我说的）。Module Federation 即模块联邦，在配置文件中配置后可以让当前项目共享其他项目的代码，也可以共享本身的代码给其他服务。 </p>\n<p>在实际使用中就可以用来做组件库，然后共享给所有项目。完美解决了以往通用组件库存在的痛点，即每次更新后，所有使用到组件库的服务都需要重新进行依赖下载和构建。 而Module Federation只用构建组件库即可，依赖组件库的服务可以直接使用到最新的组件。</p>\n<p>Module Federation 的配置如下</p>\n<pre><code class=\"language-jsx\">// 服务\nnew ModuleFederationPlugin({\n    name: &#39;service-name&#39;,\n    remotes: {\n        microFE: `microFE@http://localhost:7777/remoteEntry.js`\n    },\n    shared: {\n        ...deps\n    }\n})\n// 组件库\nnew ModuleFederation({\n    name: &quot;microFE&quot;,\n    filename: &#39;remoteEntry.js&#39;,\n    exposes: {\n        &#39;./Button&#39;: &#39;./src/components/Button/index.vue&#39;,\n    },\n        shared: {\n            ...deps, // packjson.dependencies\n            vue: ..., // 有些模块需要声明共享的程度\n        }\n})\n</code></pre>\n<p>服务本身要切换成动态导入的模式</p>\n<pre><code class=\"language-jsx\">// main.js 入口文件\nimport(&#39;bootloader.js&#39;)\n</code></pre>\n<pre><code class=\"language-jsx\">// main.js 入口文件\nimport(&#39;bootloader.js&#39;)\n\n// bootloader.js\nimport Vue from &#39;vue\nimport App from &#39;App.vue&#39;\n\nnew Vue({\n    render: h =&gt; h(App)\n}).$mount(&quot;#app&quot;)\n\n// 页面中使用\nimport Button from &#39;microFE/Button&#39;\n</code></pre>\n<p>Module Federation 本身的原理还是很简单的，就是利用动态导入打包成单独的包，然后其他服务使用时通过url加载对应的bundle即可。有了这个特性无论前端框架是什么，都可以做到组件共享。</p>\n<p>然后讲一下配置项</p>\n<ul>\n<li>name: &#39;service-name&#39;  定义服务的名称</li>\n<li>remotes  共享的服务的地址</li>\n<li>shared 声明公用的依赖</li>\n<li>exposed 声明暴露给其他服务使用的模块</li>\n<li>filename 服务构建后生产的单独文件，用于其他服务remotes使用</li>\n</ul>\n<h1 id=\"14-其他修改\">1.4 其他修改</h1>\n<p>Webpack 5还有很多其他的修改，例如一些配置项的更改, 内置了Terser进行代码压缩等。</p>\n<h1 id=\"2-存在的问题\">2. 存在的问题</h1>\n<p>新的版本，新的功能。总的来说对于开发者的使用体验有了很大的提升。</p>\n<p>在升级的过程中，我发现了一些问题：</p>\n<ol>\n<li>plugin 的写法还是过于复杂，用户自定义插件开发体验还是很糟糕</li>\n<li>首次构建速度变慢了，因为内置了Terser</li>\n<li>引入的缓存系统导致构建时的报错</li>\n</ol>\n",
        "title": "Webpack 5 的变化",
        "created": "2022-05-10 15:31:41  ",
        "updated": "2022-10-20 13:50:21 ",
        "excerpt": "现代前端开发都讲究模块化开发，作为打包界的扛把子，Webpack对与整个前端生态有着巨大的影响。但是随着Vite,ESBuild等后起之秀的崛起，webpack本身存在的问题就愈发明显。无论是繁琐的配置文件，还是奇慢无比的构建速度都令人望而...",
        "avatar": "https://avatars.githubusercontent.com/u/26271337?v=4",
        "id": "2"
    },
    "3": {
        "content": "<h1 id=\"1-写在前面\">1. 写在前面</h1>\n<p>Webpack 作为构建工具，前端在使用过程中可以根据自身项目的实际情况进行相关配置。合理的配置对于开发和构建速度有着十分显著的提升。因此本文我们来了解下webpack优化相关的知识点</p>\n<h1 id=\"2-具体方法\">2. 具体方法</h1>\n<ol>\n<li><p>cache  💯</p>\n<pre><code class=\"language-jsx\">cache: {\n    type: &#39;filesystem&#39;\n}\n</code></pre>\n<p>  Webpack 5新增了基于文件系统的缓存，首次构建后的重新构建速度十分快速</p>\n</li>\n<li><p>symlinks(一般，有少量提升)</p>\n<p> 项目未使用npm link时可以将symlinks设置为false, 也会减少构建时间</p>\n<pre><code class=\"language-jsx\">resolve: {\n    symlinks: false,\n}\n</code></pre>\n</li>\n<li><p>文件压缩和代码抽离（ 👍）</p>\n<p> Webpack 5内置了Terser, 可以在 <code>optimization/minimizer</code> 中对TerserPlugin进行详细配置</p>\n<p> <code>css-minimizer-webpack-plugin</code> 用来压缩css</p>\n<p> 通过 <code>splitChunks</code>中进行配置，可以将常用的公共模块提取到入口chunk中</p>\n<p> 通过<code>mini-css-extract-plugin</code> 将所有的css提取到单独文件中</p>\n<p> <code>purgecss-webpack-plugin</code>  可以分离出未使用的css</p>\n</li>\n<li><p>tree-shaking( 👍)</p>\n<p> 可以通过package.json 中的sideEffect来标记有副作用的文件（非ESM模块），tree-shaking通过ESM进行代码优化，将未使用的代码剔除出去。</p>\n<p> 对于第三方的包，如果有提供ES包的话，可以使用引用三方包的ES包来使用</p>\n</li>\n<li><p>静态文件处理( 👍)</p>\n<p>  对于项目中存在的静态文件，例如图片等，可以上传到cdn,提高访问速度的</p>\n<pre><code class=\"language-jsx\">output: {\n    publicPath: isProd?&#39;${cdnPath}&#39;:&#39;&#39;\n}\n</code></pre>\n</li>\n<li><p>第三方库处理(一般)</p>\n<p> 通过 <code>webpack-bundle-analyzer</code>  插件显示打包后每个模块所占用的大小，可以对打包体积分析</p>\n<p> 对于占用体积较大的第三方依赖，可以考虑cdn引入，减少打包体积</p>\n</li>\n<li><p>JS处理( 💯)</p>\n<p>  可以使用 <code>esbuild-loader</code> 替换<code>babel-loader</code>  来处理JS文件，对于构建速度有很大的提升</p>\n<p> 同时<code>ESBuildMinifyPlugin</code> 插件可以代替<code>TerserPlugin</code>插件进行要锁代码</p>\n</li>\n</ol>\n",
        "title": "Webpack 优化",
        "created": "2022-05-11 14:21:16  ",
        "updated": "2022-06-27 15:27:40 ",
        "excerpt": "1. 写在前面 Webpack 作为构建工具，前端在使用过程中可以根据自身项目的实际情况进行相关配置。合理的配置对于开发和构建速度有着十分显著的提升。因此本文我们来了解下webpack优化相关的知识点 2. 具体方法 cache 💯 `j...",
        "avatar": "https://avatars.githubusercontent.com/u/26271337?v=4",
        "id": "3"
    },
    "4": {
        "content": "<h1 id=\"tldr\">TL.DR</h1>\n<p>前端开发已经几年了，对于业务场景中的组件开发也有自己的一些心得。平时开发中遇到的痛点和疑惑之处也常常令我烦躁。因此下文将谈谈我对组件开发和设计的理解。</p>\n<h1 id=\"1-what-why\">1. What? Why?</h1>\n<p>组件化就是将业务逻辑进行抽离，将不同的业务逻辑抽离成不同的文件，避免代码的耦合，方便复用和维护。</p>\n<h2 id=\"11-抽离，降低耦合\">1.1 抽离，降低耦合</h2>\n<p>平时开发中接手和维护旧代码，遇到上千行的组件，整个人都快要昏厥了。</p>\n<p>举个例子，常见的表格数据展示页面会伴随着相关的数据操作。不同的操作往往会有不同的数据和接口处理，这个时候将对应操作的弹窗抽离为单个组件，将相关的数据隔离在组件中，对主组件的影响尽量降低是比较好的做法。 </p>\n<p>反例则是将数据的新增，编辑等弹窗操作，状态都维护在主页面中。后期的需求变更和数据更迭会让当前页面的逻辑越来越混乱。</p>\n<h2 id=\"12-复用，dry\">1.2 复用，DRY</h2>\n<p>复用其实大家都很能理解，平时使用的UI库都是复用的组件。对于平时开发的组件，我习惯分为业务组件和通用组件。</p>\n<p><strong>通用组件</strong>就是基本的组成元素，例如表单，按钮等。对于我们的业务系统，沉淀出自己的通用组件库，对于业务设计系统的一致性有很大的用处。如果一个app的各种按钮和输入都不一致的话，可能没什么用户想去使用。 </p>\n<p><strong>业务组件</strong>就是针对当前业务的组件，例如开发时需要付款码弹窗，好的方法是抽离为一个独立的组件，在不同需要调用支付的地方进行使用，而不是在每个支付的地方都重写相关的逻辑。这样后续更改付款码的逻辑，例如接口调用或者校验之类的都十分方便。</p>\n<p>整个世界都是熵增的，再基础的业务随着不断的的迭代，都会变得越来越复杂。作为开发人员，应该严格要求自己。对于新开发的功能，要想如果移除这个功能所需的时间和代码改动是否合理，当前的结构是否满足新的需求，这些都是需要去好好思考的。开发时间和开发质量很多时候并不是取舍的问题，在屎山上拉屎是避免不了的，但是在前期可以避免但是为了省事而挖更多的坑简直就是 👎</p>\n<h1 id=\"2-how\">2. How?</h1>\n<p>开发人员如何去拆分组件呢？我的方法是找<code>关系</code></p>\n<ol>\n<li>以页面作为基本单位，如果几个页面都有相同的部分，那么可以考虑抽离公用；</li>\n<li>如果某个部分的业务逻辑相对独立，只需要当前页面提供很少的信息，那么请抽离。</li>\n<li>细化组件的功能，不要负责太多的逻辑。不同场景对应不同的组件，比拥有不同场景的组件要好的多，UI要公用，逻辑要少混用。</li>\n</ol>\n<p>其实组件拆分并不麻烦，不同的开发人员有不同的理解。最好的准则就是 <code>好读，好改</code>。</p>\n<h1 id=\"3-在框架上的体现\">3. 在框架上的体现</h1>\n<p>前端的框架有很多，都支持组件化的开发。由于框架本身的实现原理和设计风格不一样，我们在用不同的框架进行开发时也会有对应的开发心得。</p>\n<p>每个框架都有自己的特点，组件中的通信，数据传递都有差异。后面我会有对应框架的文章来介绍它们各自的优缺点。</p>\n",
        "title": "组件开发和设计",
        "created": "2022-06-05 14:13:43  ",
        "updated": "2022-06-05 16:12:20 ",
        "excerpt": "TL.DR 前端开发已经几年了，对于业务场景中的组件开发也有自己的一些心得。平时开发中遇到的痛点和疑惑之处也常常令我烦躁。因此下文将谈谈我对组件开发和设计的理解。 1. What? Why? 组件化就是将业务逻辑进行抽离，将不同的业务逻辑抽...",
        "avatar": "https://avatars.githubusercontent.com/u/26271337?v=4",
        "id": "4"
    },
    "5": {
        "content": "<h1 id=\"tldr\">TL,DR</h1>\n<p>Vue2 作为平时开发中最常用的框架，我在进行业务开发时对于组件拆分和设计还是比较有心得的。开发体验也还算友好，但是还是存在很多问题。本文会介绍一些常用的技巧和框架本身存在的一些问题。</p>\n<h1 id=\"一-基本知识\">一. 基本知识</h1>\n<h2 id=\"11-组件使用\">1.1 组件使用</h2>\n<p>Vue中组件使用十分的简单，<code>import</code>+<code>components中声明</code>+<code>template中使用</code>，当然也可以在全局中进行注册。</p>\n<h2 id=\"12-组件开发\">1.2 组件开发</h2>\n<p>在开发中，Vue的每个<code>SFC</code> 都是一个组件。Vue2 通过声明Options来定义组件。</p>\n<h2 id=\"13-状态管理\">1.3 状态管理</h2>\n<p>在组件中，我们在数据变化后更新 View , View 控制数据的变化, <code>data-view-action</code>  可以简单概述组件中整体变化的一个过程。</p>\n<p>但是在实际的开发场景中，往往是多个组件公用一些状态，可能是兄弟组件，也有可能是层级差别较大的组件。</p>\n<p>如果涉及组件较少，<code>event-bus</code>也能够用。如果需要共享数据的组件较多的话，选择状态管理库会比较合适。</p>\n<h1 id=\"二-高级技巧\">二. 高级技巧</h1>\n<p>没错，稍微讲下基础知识就直接来到高级技巧了。</p>\n<h2 id=\"21-extends\">2.1 extends</h2>\n<blockquote>\n<p>优雅其实很简单</p>\n</blockquote>\n<p>当我们平时使用UI库时会根据业务需求进行改造组件，简单的样式更改通过样式穿透和重置就能处理。对于业务逻辑的修改，很多同学可能会直接复制文件进行更改，这是一个办法。</p>\n<p>之前项目时，我通过手动实现方法继承和覆盖，但还是比较的麻烦</p>\n<pre><code class=\"language-jsx\">export default {\n    componets: {\n        ComponentA,\n    },\n    render(h) {\n        return h(ComponentA,\n            {\n                props: this.$attrs,\n                on: this.listeners,\n                ref: &#39;A&#39;,\n            },...)\n    },\n    mounted() {\n        for (let key in this.$refs.A) {\n        if (!(key in this) &amp;&amp; typeof this.$refs.A[key] === &#39;function&#39;) {\n            this[key] = this.$refs.table[key]\n        }\n    }\n    }\n}\n</code></pre>\n<p>使用<code>extends</code> 就很简单，<a href=\"https://v2.vuejs.org/v2/api/#extends\">extends</a> 的用法就是扩展一个组件</p>\n<pre><code class=\"language-jsx\">// componentB\nexport default {\n    extends: ComponentA,\n    ...\n}\n</code></pre>\n<p>通用extends就是继承一个组件，可以覆盖和扩展一些方法,当然也可以更改视图的一些展示。</p>\n<h2 id=\"22-mixin\">2.2 Mixin</h2>\n<blockquote>\n<p>逻辑隔离还是公用，它都可以</p>\n</blockquote>\n<p><code>mixin</code> 常用来做一些逻辑的抽离。这里我举一个我实际开发中的使用场景。 </p>\n<p>eg: 当前有一个列表展示数据，每个数据都有10几种操作，会调用不同的弹窗，接口，提醒等。与此同时列表还要支持两种展示方式，卡片和Table.</p>\n<p>在这个需求里，我通过minix对每一种操作进行拆分，每一个操作都是单独的mixin。每个minxin里面都包含操作对应的展示校验逻辑和实际的业务逻辑。</p>\n<p>对于每个mixin中的公用的函数和状态，就放在混入的组件中，进行公用即可。</p>\n<p>最后将所有操作形成的数组传入到列表的展示项中，实现了不同的展示形式公用相同的逻辑，避免了代码的重复。</p>\n<p>好处： 不同的业务逻辑进行了隔离，避免了组件的膨胀，很好的支持修改和扩展</p>\n<p>坏处： minix的缺点也比较明显，只能公用逻辑。视图还是需要放到主组件中，这会造成视图和逻辑分离的问题。因此在进行视图操作和公用状态的处理时，需要进行仔细核对。</p>\n<p>实际场景中可以根据需求封装mixin, 可以封装成函数处理不同数据的场景，可以在mixin中开发公用的逻辑，维护公用的状态。</p>\n<h2 id=\"23-vueextend\">2.3 Vue.extend</h2>\n<blockquote>\n<p>说是银弹，未尝不可 </p>\n</blockquote>\n<p>在使用Element-ui时，我们可以通过函数的形式调用组件。在翻看代码后，我知道了Vue.extend这个方法。其实Vue源码中，Vue组件在实际使用时也会通过这个方法进行组件的生产，这里我们就不深入聊下去了。</p>\n<p>介绍下这个方法，Vue.extend可以将组件转化为一个构造函数，通过实例化构造函数，就能生成组件。</p>\n<p>因此我们可以通过Vue.extend将对应的组件转化构造函数，然后封装一个函数进行组件的生成，挂载和更新等操作。常用的一些弹窗组件都可以通过这种形式进行开发</p>\n<pre><code class=\"language-jsx\">import Vue from &#39;vue&#39;\n\nexport const componetToFunction = function (componet) {\n    return function (options = {}) {\n        let parent = document.body\n        const ComponetConstructor = Vue.extend(componet)\n        const dom = document.createElement(&#39;div&#39;)\n        parent.appendChild(dom)\n        const instance = new ComponetConstructor({\n            props: options,\n        })\n\n        for (let prop in options) {\n            if (options.hasOwnProperty(prop)) {\n                instance[prop] = options[prop]\n            }\n        }\n\n        instance.$mount(dom)\n\n        return instance\n    }\n}\n\n// 使用时\nconst renderA = componetToFunction(ComponentA)\nrenderA({a:1,b:2})\n</code></pre>\n<p>当然你也可以通过 闭包实现单例和组件更新等逻辑，根据具体场景进行使用。非常好用</p>\n<p>关于Vue.extend的坑，我也专门有进行总结，<a href=\"https://github.com/vivipure/TIL/issues/8\">链接在这</a></p>\n<h2 id=\"24-slot\">2.4 Slot</h2>\n<blockquote>\n<p>基本知识，你知我知</p>\n</blockquote>\n<p>插槽其实也不用多介绍了，更多的场景还是布局的复用。知道具名插槽，默认插槽和作用域插槽各种使用方法即可</p>\n<h2 id=\"25-v-model\">2.5 v-model</h2>\n<blockquote>\n<p>表单再复杂，有它我不怕</p>\n</blockquote>\n<p>在Vue中我们可以通过v-model指令实现双向绑定。它的原理其实也很简单，其实就是作为语法糖封装了value和updateValue的逻辑。</p>\n<p>在Vue中也允许我们自定义v-model。</p>\n<pre><code class=\"language-jsx\">props:[&#39;value&#39;],\nmodel: {\n    prop: &#39;value&#39;,\n    event: &#39;update:value&#39;\n},\nmethods: {\n    update(value) {\n        this.$emit(&#39;update:value&#39;, value)\n    }\n}\n</code></pre>\n<p>通过model声明组件v-model绑定的值和更新值的事件即可。 因此在做一些富文本输入框，图片上传组件之类输入的组件时，使用v-model会比较合适。</p>\n<p>在我平时的开发中，我会用来做表单的抽离。例如</p>\n<pre><code class=\"language-jsx\">&lt;AreaSelect v-model=&quot;config&quot; /&gt;\n&lt;TimeSelect v-model=&quot;config&quot; /&gt;\n</code></pre>\n<p>当新增的组件需要改好几个值时，也能通过这种方式进行开发，v-model支持更改对象。不过我常常使用data保存对应的引用值直接进行更改，不会进行报错，也比较简单。</p>\n<p>同时注意watch下props传入的值，数据更改后要即使更改data中的值。还有分发事件时，要先触发model的事件，在分发change的事件，不然外部在使用change时拿不到正确的值。</p>\n<p>如果你像我一样在表单中使用的话，记得写验证和清除验证相关的方法供父组件进行使用</p>\n<h2 id=\"26-directives\">2.6 directives</h2>\n<blockquote>\n<p>指令：执行</p>\n</blockquote>\n<p>自定义指令的具体写法我就不写了，也很简单。说一下常用的场景吧，例如对dom的一些操作，输入处理，还有事件绑定都可以通过指令的方式进行处理。</p>\n<p>我的开发中就使用过埋点，拖拽，节流等指令。</p>\n<p>这里需要注意一个点，如果指令需要维持一些数据的话，可以绑定到el上。</p>\n<h2 id=\"27-providereject\">2.7 provide/reject</h2>\n<p>可以通过provide和reject让组件跨级别共享状态，类似React.context. </p>\n<p>如果需要往自组件传递太多的数据，可以考虑用这种方式，而不是用<code>props</code></p>\n<ol>\n<li>需要注意的是如果组件之间存在其他的provide和reject会使reject受到最近的的provide数据。</li>\n<li>共享的数据不是响应式的，可以通过函数的方式进行获取</li>\n</ol>\n<h1 id=\"3-还有点东西\">3. 还有点东西</h1>\n<ol>\n<li>弹窗组件最好放在body下，毕竟fixed会受到css样式的影响，要保证好遮罩层的层级</li>\n<li>弹窗组件如果不是必要，就单独放一个文件吧</li>\n<li>别让组件拥有太多状态，而是不同状态对应不同的组件</li>\n<li>如果一个值传递的层级太深，就把它放到全局状态吧</li>\n</ol>\n<h1 id=\"4-最后再说说\">4. 最后再说说</h1>\n<p>Vue2作为渐进式框架，无论是小应用还是大应用，组件开发是完全能够cover的住的。</p>\n<p>但是Vue Options Api中数据和方法的隔离【物理行数的隔离】导致可读性较差。</p>\n<p>与此同时TS支持较弱，导致开发时组件的传值无法智能提醒。</p>\n<p>mixin不是好的实现方式，视图和数据的分离导致可读性变差。</p>\n<p>好在Vue3来了，TS + Composition Api 让开发体验大大提升，后面将会有文章介绍下Vue3的相关特性。</p>\n",
        "title": "Vue2 组件开发",
        "created": "2022-06-05 15:32:49  ",
        "updated": "2022-06-09 16:04:58 ",
        "excerpt": "TL,DR Vue2 作为平时开发中最常用的框架，我在进行业务开发时对于组件拆分和设计还是比较有心得的。开发体验也还算友好，但是还是存在很多问题。本文会介绍一些常用的技巧和框架本身存在的一些问题。 一. 基本知识 1.1 组件使用 Vue中...",
        "avatar": "https://avatars.githubusercontent.com/u/26271337?v=4",
        "id": "5"
    },
    "6": {
        "content": "<h1 id=\"1-我的疑问\">1. 我的疑问</h1>\n<p> 1.1 $store是怎么保证每个组件都可以进行访问的\n 1.2. 为什么需要Mutation,而不是直接使用Action\n 1.3. mapState等方法是怎么映射到组件的\n 1.4. 怎么和Vue的响应式结合起来的\n 1.5. 插件的实现【兴趣不大】\n 1.6. 模块的实现【兴趣不大】</p>\n<p>带着我的疑问，现在就开搞！</p>\n<h1 id=\"2--基本介绍\">2.  基本介绍</h1>\n<p><img src=\"https://vuex.vuejs.org/vuex.png\" alt=\"流程图\"></p>\n<p><code>Vuex</code> 的核心就是一个 <code>Store</code>, 管理着应用的全局状态。组件从 <code>store</code> 中读取数据，当  <code>store</code> 中数据变化时，组件也会一起更新。\n<code>Vuex</code> 中的数据需要通过 <code>Mutation</code> 进行显示更改，当然根据实际业务直接更改对象类型的 <code>state</code> 其实也可以。显示更改更方便我们定位问题和在 <code>devtools</code> 中进行展示</p>\n<p>项目地址：<a href=\"https://github.com/vuejs/vuex\">https://github.com/vuejs/vuex</a>\n构建工具： Rollup\n入口文件：src/index.js</p>\n<p>由于平时使用的3.x版本的 <code>Vuex</code> ,所以分支为 <strong>v3.6.2</strong></p>\n<h1 id=\"3-初始化\">3. 初始化</h1>\n<p>回想下平时我们是怎么使用Vuex, 我们使用 <code>Vue.use</code> 安装了 <code>Vuex</code> 插件，然后通过\n然后再来看 <code>Vuex</code> 导出的相关包</p>\n<pre><code class=\"language-JS\">Vue.use(Vuex);\nconst store = new Vuex.Store({\n    state,\n    getters,\n    mutations,\n    actions,\n})\n\n  \nexport default store;\n</code></pre>\n<p>首先我们查看入口文件文件</p>\n<pre><code class=\"language-JS\">export default {\n    Store, \n    install,\n    version: &#39;__VERSION__&#39;,\n    mapState,\n    mapMutations,\n    mapGetters,\n    mapActions,\n    createNamespacedHelpers,\n    createLogger\n}\n</code></pre>\n<p><code>Store</code> 就是我们初始化的类，<code>install</code> 就是 <code>Vue.use</code> 安装的逻辑，还有平时使用到的一些辅助函数。</p>\n<h2 id=\"31-vuex初始化\">3.1 Vuex初始化</h2>\n<p>看下 <code>install</code>的逻辑</p>\n<pre><code class=\"language-js\">export function install () {\n    if (Vue &amp;&amp; _Vue === Vue) {\n        if (__DEV__) {\n            console.error(&#39;[vuex] already installed. Vue.use(Vuex) should be called only once.&#39;)\n        }\n        return\n    }\n    Vue = _Vue\n    applyMixin(Vue)\n}Ï\n</code></pre>\n<p>在执行时会往 <code>Vue</code> 中混入一些逻辑，2.0中混入了 <code>beforeCreate</code> 函数的逻辑</p>\n<pre><code class=\"language-js\">Vue.mixin({ beforeCreate: vuexInit })\n</code></pre>\n<p>而 <code>vuexInit</code> 中的逻辑就是混入<code>$store</code>, 保证应用下的组件都可以访问到 <code>$store</code> 。</p>\n<pre><code class=\"language-js\">function vuexInit () {\n    const options = this.$options\n    // store injection\n    if (options.store) {\n        this.$store = typeof options.store === &#39;function&#39;\n        ? options.store()\n        : options.store\n    } else if (options.parent &amp;&amp; options.parent.$store) {\n        this.$store = options.parent.$store\n    }\n}\n</code></pre>\n<p>通过这里的逻辑就能解答我的[第一个疑问]了</p>\n<h2 id=\"32-store初始化\">3.2 Store初始化</h2>\n<p>Store初始化主要分为：</p>\n<ol>\n<li>Module注册，处理嵌套逻辑，形成tree</li>\n<li>Module安装，初始化 state,getters等</li>\n<li>初始化Store.vm</li>\n</ol>\n<h3 id=\"32-1-module注册\">3.2. 1 Module注册</h3>\n<p>初始化<code>Store</code>时我们会传入一个对象，里面包含 <code>state</code>,<code>mutations</code>,<code>getters</code> 等属性。现在我们就来看看 <code>Store</code> 这个类.</p>\n<pre><code class=\"language-js\">this._modules = new ModuleCollection(options)\n</code></pre>\n<p>整个 <code>options</code> 可以视为 Store的 root module, 在ModuleCollection中进行解析，如果有嵌套的 module ,该方法也会进行处理\n看一下模块注册的逻辑</p>\n<pre><code class=\"language-js\">register (path, rawModule, runtime = true) {\n    \n    const newModule = new Module(rawModule, runtime)\n\n    // 构建tree\n    if (path.length === 0) {\n        this.root = newModule\n    } else {\n        // slice(0, -1) 不包括最后一项\n        const parent = this.get(path.slice(0, -1))\n        parent.addChild(path[path.length - 1], newModule)\n    }\n\n    // 处理嵌套的模块\n    if (rawModule.modules) {\n        forEachValue(rawModule.modules, (rawChildModule, key) =&gt; {\n            this.register(path.concat(key), rawChildModule, runtime)\n        })\n    }\n}\n</code></pre>\n<p>其中 <code>path</code> 为 <code>store tree</code> 的路径，<code>rawModule</code> 为配置项， <code>runtime</code> 为是否运行时创建的模块。</p>\n<p>通过 Module 类中对模块进行初始化，判断当前 <code>path</code> 的长度，若为0则称为 <code>root module</code>, 否则就找到 父模块调用 <code>addChild</code> 方法形成父子逻辑。</p>\n<p>这样子模块可以通过路径找到父模块，父模块可以通过 <code>_children</code> <code>key</code> 找到子模块</p>\n<h3 id=\"322-module安装\">3.2.2 Module安装</h3>\n<pre><code class=\"language-js\">installModule(this, state, [], this._modules.root)\n</code></pre>\n<p>这个方法的核心逻辑为</p>\n<pre><code class=\"language-js\">// 获取命名空间，模块标识namespace 为true， 可以嵌套\nconst namespace = store._modules.getNamespace(path)\n\n\nif (!isRoot &amp;&amp; !hot) {\n    const parentState = getNestedState(rootState, path.slice(0, -1))\n    const moduleName = path[path.length - 1]\n    store._withCommit(() =&gt; {\n        Vue.set(parentState, moduleName, module.state)\n    })\n}\n// 挂载state\nconst local = module.context = makeLocalContext(store, namespace, path)\n\n  \n// 处理mutations,action,getter\nmodule.forEachMutation((mutation, key) =&gt; {\n    const namespacedType = namespace + key\n    registerMutation(store, namespacedType, mutation, local)\n})\nmodule.forEachAction((action, key) =&gt; {\n    const type = action.root ? key : namespace + key\n    const handler = action.handler || action\n    registerAction(store, type, handler, local)\n})\nmodule.forEachGetter((getter, key) =&gt; {\n    const namespacedType = namespace + key\n    registerGetter(store, namespacedType, getter, local)\n})\n// 嵌套安装\nmodule.forEachChild((child, key) =&gt; {\n    installModule(store, rootState, path.concat(key), child, hot)\n})\n</code></pre>\n<p>在 <code>makeLocalContext</code> 方法中实现上下文的注册，上下文包括了 <code>state</code>, <code>getters</code> , <code>dispatch</code>, <code>commit</code> 等。这几个属性除了 <code>state</code> 都处理了 <code>namespace</code> 的情况。这里讲一下 <code>state</code> 的获取逻辑就好了</p>\n<pre><code class=\"language-js\">Object.defineProperties(local, {\n    getters: {\n        get: noNamespace\n        ? () =&gt; store.getters\n        : () =&gt; makeLocalGetters(store, namespace)\n    },\n    state: {\n        get: () =&gt; getNestedState(store.state, path)\n    }\n\n})\n\nfunction getNestedState (state, path) {\n    return path.reduce((state, key) =&gt; state[key], state)\n}\n</code></pre>\n<p> 从<code>state</code> 开始，层层查找子模块 <code>state</code>，最终找到目标模块的 <code>state</code>.</p>\n<p> <code>registerMutation</code>, <code>registerAction</code> 等方法完成对 <code>mutation</code>, <code>action</code> 的注册</p>\n<h3 id=\"323-初始化storevm\">3.2.3 初始化Store.vm</h3>\n<pre><code class=\"language-js\">resetStoreVM(this, state)\n</code></pre>\n<p>resetStoreVM的具体逻辑是这样的</p>\n<pre><code class=\"language-js\">  \n\nfunction resetStoreVM (store, state, hot) {\n\n   const oldVm = store._vm\n   // bind store public getters\n   store.getters = {}\n\n   // reset local getters cache\n\n   store._makeLocalGettersCache = Object.create(null)\n\n   const wrappedGetters = store._wrappedGetters\n\n   const computed = {}\n\n   forEachValue(wrappedGetters, (fn, key) =&gt; {\n       computed[key] = partial(fn, store)\n       Object.defineProperty(store.getters, key, {\n           get: () =&gt; store._vm[key],\n           enumerable: true // for local getters\n       })\n   })\n\n   const silent = Vue.config.silent\n   Vue.config.silent = true\n   store._vm = new Vue({\n       data: {\n           $$state: state\n       },\n       computed\n   })\n   Vue.config.silent = silent\n\n\n   if (oldVm) {\n       if (hot) {\n           store._withCommit(() =&gt; {\n\n               oldVm._data.$$state = null\n\n           })\n   \n       }\n       Vue.nextTick(() =&gt; oldVm.$destroy())\n   }\n}\n</code></pre>\n<p>这里的流程就是从 <code>_wrappedGetters</code> 中取出对应 <code>gettter</code> 函数，挂在到 <code>store._vm </code>中，同时存入 <code>computed</code> 中，通过 <code>Vue</code> 的 <code>compute</code> ,和 <code>state</code> 产生依赖关系</p>\n<pre><code>store._vm = new Vue({\n       data: {\n           $$state: state\n       },\n       computed\n})\n</code></pre>\n<p> 然后 <code>store</code> 的 <code>state</code> 的 <code>getter</code> 是这么设置的</p>\n<pre><code class=\"language-js\">get state () {\n return this._vm._data.$$state\n}\n</code></pre>\n<p>因此获取 <code>state</code> 时，实际上访问的是vm的<code>$$state</code></p>\n<p>总体的逻辑来说就是这样的</p>\n<pre><code>根据 `key` 访问 `store.getters` 的某一个 `getter` 的时候，实际上就是访问了 `store._vm[key]`，也就是 `computed[key]`，在执行 `computed[key]` 对应的函数的时候，会执行 `rawGetter(local.state,...)` 方法，那么就会访问到 `store.state`，进而访问到 `store._vm._data.$$state`，这样就建立了一个依赖关系。当 `store.state` 发生变化的时候，下一次再访问 `store.getters` 的时候会重新计算\n</code></pre>\n<p>在上面的代码中还有 严格模式的校验</p>\n<pre><code class=\"language-js\">function enableStrictMode (store) {\n\n    store._vm.$watch(function () { return this._data.$$state }, () =&gt; {\n\n    if (__DEV__) {\n\n    assert(store._committing, `do not mutate vuex store state outside mutation handlers.`)\n\n    }\n\n    }, { deep: true, sync: true })\n}\n</code></pre>\n<p>如果处于严格模式,就会手动添加一个 同步的<code>watch</code>, 监听<code>$$state</code>的变化是否是 <code>mutation</code> 改变的，</p>\n<pre><code class=\"language-js\">_withCommit (fn) {\n  const committing = this._committing\n  this._committing = true\n  fn()\n  this._committing = committing\n}\n</code></pre>\n<p>_withCommit方法保证了通过Vuex自身提供的方法改变数据才能使 <code>_committing</code> 为 <code>true</code></p>\n<p>读到这里，关于 [1.4]和[1.6]的问题，已经有了答案，响应式是通过 <code>Vue</code> 实现的，模块是 <code>Store</code> 的基本单位，兼容层级的嵌套和命名空间。</p>\n<h1 id=\"4-api\">4. API</h1>\n<p>在 store 的初始化过程中完成了数据的存储，接下来就是通过 API来进行使用了。</p>\n<h2 id=\"41-mutation--commit\">4.1 Mutation &amp; commit</h2>\n<p>在初始化时，我们进行了 mutation 方法的初始化，可以通过 mutation 进行 state 的更改。</p>\n<pre><code class=\"language-js\">function registerMutation (store, type, handler, local) {\n  const entry = store._mutations[type] || (store._mutations[type] = [])\n  entry.push(function wrappedMutationHandler (payload) {\n    handler.call(store, local.state, payload)\n  })\n}\n</code></pre>\n<p>这里我们也能明白在 <code>mutation</code> 中改变的数据是当前模块的数据，访问的 <code>this</code> 是 <code>store</code> . 然后将每个 <code>mutation</code> 存入到<code> store._mutations[type]</code> 中</p>\n<p>然后我们再看看 commit, store 提供 commit 来提交 commit</p>\n<pre><code class=\"language-js\">commit (_type, _payload, _options) {\n\n    // 规范传入的参数\n    const {\n        type,\n        payload,\n        options\n    } = unifyObjectStyle(_type, _payload, _options)\n\n  \n\n    const mutation = { type, payload }\n    // 获取存放的方法\n    const entry = this._mutations[type]\n    // 执行mutation改变state\n    this._withCommit(() =&gt; {\n        entry.forEach(function commitIterator (handler) {\n            handler(payload)\n        })\n    })\n    // 提供给订阅者使用，一般是插件\n    this._subscribers\n    .slice() \n    .forEach(sub =&gt; sub(mutation, this.state))\n}\n</code></pre>\n<p>从这里可以看出，mutation必须是同步的，不然下面通知 订阅者 的逻辑会出错</p>\n<h2 id=\"42-action--dispatch\">4.2 Action &amp; dispatch</h2>\n<p>Action 和 Mutation的区别就是 Action是异步的，所以它们大部分逻辑还是差不多的，只是在异步处理和通知上有区别</p>\n<pre><code class=\"language-js\">...\n// 执行前hook\ntry {\n    this._actionSubscribers\n    .slice()\n    .filter(sub =&gt; sub.before)\n    .forEach(sub =&gt; sub.before(action, this.state))\n} catch (e) {\n}\n\n  \nconst result = entry.length &gt; 1\n? Promise.all(entry.map(handler =&gt; handler(payload)))\n: entry[0](payload)\n\n\nreturn new Promise((resolve, reject) =&gt; {\n    // 完成hook 和 error hook\n    result.then(res =&gt; {\n        this._actionSubscribers\n        .filter(sub =&gt; sub.after)\n        .forEach(sub =&gt; sub.after(action, this.state))\n        \n        resolve(res)\n    }, error =&gt; {\n        this._actionSubscribers\n        .filter(sub =&gt; sub.error)\n        .forEach(sub =&gt; sub.error(action, this.state, error))\n        \n        reject(error)\n    })\n})\n</code></pre>\n<h2 id=\"42-mapstate\">4.2 mapState</h2>\n<p>在 <code>src/helper.js</code>中</p>\n<pre><code class=\"language-js\">export const mapState = normalizeNamespace((namespace, states) =&gt; {\n\n    const res = {}\n\n    normalizeMap(states).forEach(({ key, val }) =&gt; {\n        // 组成getter函数\n        res[key] = function mappedState () {\n            let state = this.$store.state\n            let getters = this.$store.getters\n            // 有命名空间就使用模块的数据，不然就使用根的\n            // 这里的this 是指向组件的\n            if (namespace) {\n                const module = getModuleByNamespace(this.$store, \t\t&#39;mapState&#39;,namespace)\n                if (!module) {\n                    return\n                }\n                state = module.context.state\n                getters = module.context.getters\n            }\n\n        return typeof val === &#39;function&#39; ? val.call(this, state, getters): state[val]\n    }\n\n    // mark vuex getter for devtools\n        res[key].vuex = true\n\n    })\n    return res\n})\n</code></pre>\n<p>这里的主要逻辑是 得到一些getter函数，其中也包括对一些命名空间的处理。这里兼容了val是函数还是字符串的情况。</p>\n<p>接下来我们看看 <code>normalizeNamesapce</code> 函数干了啥，</p>\n<pre><code class=\"language-js\">function normalizeNamespace (fn) {\n    return (namespace, map) =&gt; {\n        if (typeof namespace !== &#39;string&#39;) {\n            map = namespace\n            namespace = &#39;&#39;\n        } else if (namespace.charAt(namespace.length - 1) !== &#39;/&#39;) {\n            namespace += &#39;/&#39;\n        }\n        return fn(namespace, map)\n    }\n}\n</code></pre>\n<p>其实对于 <code>namespace/state</code>做处理，拿到斜杠前的命名空间 然后对函数进行包裹，兼容传命名空间和不穿命名空间的两种情况。</p>\n<h2 id=\"43-mapmutations\">4.3 mapMutations</h2>\n<p>其实 <code>mapMutations</code> 的逻辑和 <code>mapState</code> 差不多，这里讲一下核心的逻辑就好了</p>\n<pre><code class=\"language-js\">\nres[key] = function mappedMutation (...args) {\n    let commit = this.$store.commit\n    // 没namespace就用store的顶级commit,不然就使用模块上下文自己的commit\n    if (namespace) {\n        const module = getModuleByNamespace(this.$store, &#39;mapMutations&#39;, namespace)\n        if (!module) return\n        commit = module.context.commit\n    }\n    // 然后执行commit函数，也支持val是函数的情况，将commit进行传入\n    return typeof val === &#39;function&#39;\n    ? val.apply(this, [commit].concat(args))\n\n    : commit.apply(this.$store, [val].concat(args))\n\n}\n</code></pre>\n<p>其他的 <code>mapGetters</code>, <code>mapActions</code> 的逻辑都与其类似。 </p>\n<h1 id=\"5-插件\">5. 插件</h1>\n<p>插件平时用的还是很少的，也就学习教程时知道一个 <code>logger</code> 插件，还有 <code>Vuex 持久化</code>的插件。\n现在就顺便研究下插件机制, 显示插件激活</p>\n<pre><code class=\"language-js\">plugins.forEach(plugin =&gt; plugin(this))\n</code></pre>\n<p>代码其实就是将 <code>store</code> 传递给插件，然后插件调用 <code>store.subscribe</code> 订阅 <code>mutation</code> 事件，或者订阅 <code>action</code> 事件。</p>\n<p>看了这么多源码，想一下 持久化插件会怎么做呢？ </p>\n<p>我觉得可以在每次数据改变后 将当前 <code>state</code> 存到 <code>localStorage</code> 中，当 <code>store</code> 在激活插件时，从 <code>localStorage</code> 中拿到旧的数据，然后改变 <code>$$state</code></p>\n<p>看了下源码果然逻辑差不多 <a href=\"https://github.com/robinvdvleuten/vuex-persistedstate/blob/master/src/index.ts\">Vuex-persistedstate</a></p>\n<h1 id=\"6-总结\">6. 总结</h1>\n<p>看完源码后我的6个疑问解决了5个，收获还是很大的。对于自己平时的开发，如果状态比较多的话，子模块和命名空间的确很好用。毕竟 Vuex 花了很大精力去处理这块逻辑。</p>\n<p>还有插件的设计，也让我学会了如何去制作 Vuex 插件和 设计插件系统</p>\n<p>当然还有最后的疑问，为啥需要Mutation，而不是直接使用Action呢？像 <a href=\"https://pinia.vuejs.org/\">pinia</a> 中就放弃了Mutation.</p>\n<p>我其实也有了答案，正如作者说的，Mutation其实是为了更好的追踪状态的改变，方便devtools去捕捉，同时数据更改后能够及时同步插件，保证插件获取的数据是正确的。</p>\n<p>当然直接使用Action也是可以，因为Action也能够通知订阅者。且用户直接更改数据也不会影响响应式的功能。所以这也是为什么 Mutation 被放弃的原因。</p>\n",
        "title": "Vuex 源码学习",
        "created": "2022-06-11 10:08:27  ",
        "updated": "2022-06-11 12:38:18 ",
        "excerpt": "1. 我的疑问 1.1 $store是怎么保证每个组件都可以进行访问的 1.2. 为什么需要Mutation,而不是直接使用Action 1.3. mapState等方法是怎么映射到组件的 1.4. 怎么和Vue的响应式结合起来的 1.5....",
        "avatar": "https://avatars.githubusercontent.com/u/26271337?v=4",
        "id": "6"
    },
    "7": {
        "content": "<h2 id=\"1-为什么要学习源码\">1. 为什么要学习源码</h2>\n<p>就现有的前端框架来说，阅读源码其实是困难的。例如Vue,React, 这些工业框架为了处理各种边界情况，会让代码变得不那么清晰。而我们在进行学习时就需要从繁到简，理清核心逻辑，学习核心原理。</p>\n<p>至于学习框架的原因，也很简单。我自己有三大理由</p>\n<ol>\n<li>面试，开卷就是了</li>\n<li>学习优秀的代码结构和逻辑</li>\n<li>增加开发能力，了解原理后能够更好的进行开发和优化</li>\n</ol>\n<h2 id=\"2--如何去学习源码\">2.  如何去学习源码</h2>\n<p>如何去学习源码途径有很多，图省事和囫囵吞枣就可以直接看其他人的文章或者视频。这种效率最高，以面试作为需求的完全可以通过这种方式进行学习。</p>\n<p>我个人比较习惯带着问题去看源码，以<strong>什么是怎么实现的</strong>的疑问去阅读源码其实效率还是很高的。无论是阅读范围还是阅读收获都有一个可以量化的区间，不会陷入到无处下手的地步。</p>\n<p>我后面的相关文章也会带着疑问去进行学习。与此同时，我也会对源码中引用的一些第三方库和插件进行总结，方便后续自己使用</p>\n<h2 id=\"3-系列\">3. 系列</h2>\n<ol>\n<li><a href=\"https://github.com/vivipure/blog/issues/6\">Vuex源码学习</a></li>\n</ol>\n",
        "title": "源码学习系列",
        "created": "2022-06-11 10:10:08  ",
        "updated": "2022-06-11 10:10:08 ",
        "excerpt": "1. 为什么要学习源码 就现有的前端框架来说，阅读源码其实是困难的。例如Vue,React, 这些工业框架为了处理各种边界情况，会让代码变得不那么清晰。而我们在进行学习时就需要从繁到简，理清核心逻辑，学习核心原理。 至于学习框架的原因，也很...",
        "avatar": "https://avatars.githubusercontent.com/u/26271337?v=4",
        "id": "7"
    },
    "8": {
        "content": "<h1 id=\"1-我的疑问\">1. 我的疑问</h1>\n<p>Vue Router 的使用频率还是很高的，作为开发者，我们可能知道 hash路由和 history路由 的区别和实现原理。但是一些还是东西是值得理解的。</p>\n<ol>\n<li>内置组件 router-view 是怎么实现的</li>\n<li>路由守卫是怎么实现的</li>\n<li>和Transition是怎么搭配合作的</li>\n<li>routes 数据是怎么解析的</li>\n<li>和keep-alive 是怎么配合</li>\n</ol>\n<h1 id=\"2-基本介绍\">2. 基本介绍</h1>\n<p>这里就不介绍基本的使用</p>\n<p>项目地址：<a href=\"https://github.com/vuejs/vue-router\">https://github.com/vuejs/vue-router</a>\n构建工具： Rollup\n入口文件：src/index.js</p>\n<h1 id=\"3--入口文件分析\">3.  入口文件分析</h1>\n<h2 id=\"31-install\">3.1 install</h2>\n<p>看下 install 函数执行的逻辑</p>\n<pre><code class=\"language-js\">export function install (Vue) {\n    // 避免重复注册\n    if (install.installed &amp;&amp; _Vue === Vue) return\n    install.installed = true\n    _Vue = Vue\n    const isDef = v =&gt; v !== undefined\n    // 暂时不知道少用\n    const registerInstance = (vm, callVal) =&gt; {\n        let i = vm.$options._parentVnode\n        if (\n            isDef(i) &amp;&amp; isDef(i = i.data) &amp;&amp; isDef(i = i.registerRouteInstance)\n        ){\n            i(vm, callVal)\n        }\n    }\n    // 混入逻辑，\n    Vue.mixin({\n        beforeCreate () {\n            if (isDef(this.$options.router)) {\n                // 自身\n                this._routerRoot = this\n                // 路由实例\n                this._router = this.$options.router\n                this._router.init(this)\n                // 定义route,指向当前激活路由\n                Vue.util.defineReactive(\n                    this, &#39;_route&#39;,\n                    this._router.history.current)\n            } else {\n                // 由于是树形结构，因此子组件会找到离自己最近的 带有router的组件\n                this._routerRoot = \n                    (this.$parent &amp;&amp; this.$parent._routerRoot) || this\n            }\n            registerInstance(this, this)\n        },\n        destroyed () {\n            registerInstance(this)\n        }\n    })\n\n \n    // 定义全局属性\n    Object.defineProperty(Vue.prototype, &#39;$router&#39;, {\n        get () { return this._routerRoot._router }\n    })\n    Object.defineProperty(Vue.prototype, &#39;$route&#39;, {\n        get () { return this._routerRoot._route }\n    })\n    // 组件注册\n    Vue.component(&#39;RouterView&#39;, View)\n    Vue.component(&#39;RouterLink&#39;, Link)\n}\n</code></pre>\n<p>相关注释我都写在代码中了，主要逻辑就是在组件中混入了路由的属性，定义全局的属性，注册了两个内置组件。</p>\n<p>这里比较巧妙的是通过树形结构的特性，保证了拥有 <code>options.router</code> 的组件进行了路由初始化，子组件根据父组件层层查找，找到离自己最近的带有 <code>router</code> 的组件。</p>\n<p>然后 <code>registerInstance</code> 方法暂时不知道用法，</p>\n<h2 id=\"32-vuerouter\">3.2 VueRouter</h2>\n<p><code>VueRouter</code> 类在 <code>src/index.js</code> 中，默认导出的就是 <code>VueRouter</code>, 我们在业务开发时也通过实例化 <code>VueRouter</code> 来生成 <code>router</code> 给应用使用。</p>\n<h3 id=\"321-构造函数\">3.2.1 构造函数</h3>\n<pre><code class=\"language-js\">constructor (options: RouterOptions = {}) {\n  this.app = null\n  this.apps = []\n  this.options = options\n  this.beforeHooks = []\n  this.resolveHooks = []\n  this.afterHooks = []\n    \n  this.matcher = createMatcher(options.routes || [], this)\n    \n  // 根据options结合实际浏览器确定 路由模式\n  let mode = options.mode || &#39;hash&#39;\n  this.fallback = mode === &#39;history&#39; &amp;&amp; !supportsPushState &amp;&amp; options.fallback !== false\n  if (this.fallback) {\n    mode = &#39;hash&#39;\n  }\n    // 如果不在浏览器则为 abstract模式\n  if (!inBrowser) {\n    mode = &#39;abstract&#39;\n  }\n  this.mode = mode\n  // 根据路由模式生成 history 对象\n  switch (mode) {\n    case &#39;history&#39;:\n      this.history = new HTML5History(this, options.base)\n      break\n    case &#39;hash&#39;:\n      this.history = new HashHistory(this, options.base, this.fallback)\n      break\n    case &#39;abstract&#39;:\n      this.history = new AbstractHistory(this, options.base)\n      break\n    default:\n      if (process.env.NODE_ENV !== &#39;production&#39;) {\n        assert(false, `invalid mode: ${mode}`)\n      }\n  }\n}\n</code></pre>\n<p>这里主要的逻辑就是通过<code> options.router</code> 生成 <code>matcher</code>, 和通过路由模式生成对应的 <code>history</code>对象. \n通过这里我才知道原来 路由还有 <code>abstract</code> 模式, 提供给服务端或者ssr模式使用，应该和V4版本的 <code>Memory mode</code>是一样的。</p>\n<h3 id=\"322-init\">3.2.2 init</h3>\n<p>在 <code>install</code>的过程中，<code>VueRouter</code> 往 <code>Vue</code> 中 <code>beforeCreated</code> 逻辑, 对有 <code>router</code> 的 <code>options</code> 进行了路由初始化</p>\n<pre><code>this._router.init(this)\n</code></pre>\n<p>因此我们再看看 <code>router</code> 的 <code>init</code> 方法</p>\n<pre><code class=\"language-js\">init (app: any) {\n  // 将当前组件推入 app 中\n  this.apps.push(app)\n  if (this.app) {\n    return\n  }\n  this.app = app\n        \n\n  const history = this.history\n  // 属于hash 和 history 模式\n  if (history instanceof HTML5History || history instanceof HashHistory) {\n     // scrollBehavior支持\n       const handleInitialScroll = routeOrError =&gt; {\n        const from = history.current\n        const expectScroll = this.options.scrollBehavior\n        const supportsScroll = supportsPushState &amp;&amp; expectScroll\n        if (supportsScroll &amp;&amp; &#39;fullPath&#39; in routeOrError) {\n            handleScroll(this, routeOrError, from, false)\n        }\n    }\n    const setupListeners = routeOrError =&gt; {\n        history.setupListeners()\n        handleInitialScroll(routeOrError)\n    }\n    // 切换到当前链接对应的路由\n    history.transitionTo(\n        history.getCurrentLocation(),\n        setupListeners,\n        setupListeners\n    )\n  }\n  // 路由更新后，更新组件的_route\n  history.listen(route =&gt; {\n    this.apps.forEach((app) =&gt; {\n      app._route = route\n    })\n  })\n}\n</code></pre>\n<p>初始化时将当前组件进行保存，将<strong>当前路由</strong>切换到<strong>当前链接</strong>对应路由，也设置了订阅，当 <code>history</code> 改变时，会更新组件的 <code>route</code>。</p>\n<h3 id=\"323-transitionto\">3.2.3 transitionTo</h3>\n<p>看下 <code>tansitionTo</code> 的实际逻辑</p>\n<pre><code class=\"language-js\">// 匹配到路由\nroute = this.router.match(location, this.current)\nconst prev = this.current\n\n// 进行切换动画\nthis.confirmTransition(\n    route,\n    () =&gt; {\n        // 更新当前路由\n        this.updateRoute(route)\n        onComplete &amp;&amp; onComplete(route)\n        // 更改url\n        this.ensureURL()\n        // hook\n        this.router.afterHooks.forEach(hook =&gt; {\n            hook &amp;&amp; hook(route, prev)\n        })\n        // 初始化回调\n        if (!this.ready) {\n            ...\n        }\n    },\n    err =&gt; {\n    // 错误处理\n})\n\n\nconfirmTransition (route: Route, onComplete: Function, onAbort?: Function) {\n    const current = this.current\n    this.pending = route\n    // 错误处理\n    const abort = err =&gt; {}\n    // 当前路由重复导航处理\n    if (isDuplicatedRoute) {\n        this.ensureURL()\n        if (route.hash) {\n            handleScroll(this.router, current, route, false)\n        }\n        return abort(createNavigationDuplicatedError(current, route))\n    }\n    \n    const { updated, deactivated, activated } = resolveQueue(\n        this.current.matched,\n        route.matched\n    )\n    const queue: Array&lt;?NavigationGuard&gt; = [].concat(\n        // in-component leave guards\n        extractLeaveGuards(deactivated),\n        // global before hooks\n        this.router.beforeHooks,\n        // in-component update hooks\n        extractUpdateHooks(updated),\n        // in-config enter guards\n        activated.map(m =&gt; m.beforeEnter),\n        // async components\n        resolveAsyncComponents(activated)\n    )\n    const iterator = (hook: NavigationGuard, next) =&gt; {\n        if (this.pending !== route) {\n            return abort(createNavigationCancelledError(current, route))\n        }\n        try {\n            hook(route, current, (to: any) =&gt; {\n                if (to === false) {\n                    // next(false) -&gt; abort navigation, ensure current URL\n                    this.ensureURL(true)\n                    abort(createNavigationAbortedError(current, route))\n                } else if (isError(to)) {\n                    this.ensureURL(true)\n                    abort(to)\n                } else if (\n                    typeof to === &#39;string&#39; ||\n                    (typeof to === &#39;object&#39; &amp;&amp;\n                    (typeof to.path === &#39;string&#39; || typeof to.name === &#39;string&#39;))\n                ) {\n                    // next(&#39;/&#39;) or next({ path: &#39;/&#39; }) -&gt; redirect\n                    abort(createNavigationRedirectedError(current, route))\n                    if (typeof to === &#39;object&#39; &amp;&amp; to.replace) {\n                        this.replace(to)\n                    } else {\n                        this.push(to)\n                    }\n                } else {\n                    // confirm transition and pass on the value\n                    next(to)\n                }\n            })\n        } catch (e) {\n            abort(e)\n        }\n    }\n\n    runQueue(queue, iterator, () =&gt; {\n        // wait until async components are resolved before\n        // extracting in-component enter guards\n        const enterGuards = extractEnterGuards(activated)\n        const queue = enterGuards.concat(this.router.resolveHooks)\n        runQueue(queue, iterator, () =&gt; {\n            if (this.pending !== route) {\n                return abort(createNavigationCancelledError(current, route))\n            }\n            this.pending = null\n            onComplete(route)\n            if (this.router.app) {\n                this.router.app.$nextTick(() =&gt; {\n                    handleRouteEntered(route)\n                })\n            }\n        })\n    })\n}\n</code></pre>\n<p>这里主要执行 <code>confirmTransition</code> 方法，主要逻辑分为几步：</p>\n<ol>\n<li>检查是否重复路由，进行处理</li>\n<li>用 <code>reolveQuene</code> 筛选出当前路由和跳转路由的差异</li>\n<li>然后对迭代一个队列，队列包含<ol>\n<li>激活失效组件 <code>beforeLeave</code> 路由守卫</li>\n<li>全局路由 <code>beforHooks</code></li>\n<li>重用组件 <code>update</code> 路由守卫</li>\n<li>激活路由 配置的<code>beforeEnter hook</code></li>\n<li>处理异步组件加载逻辑\n如果顺序执行中有一个任务失败，则不会继续下面的任务</li>\n</ol>\n</li>\n<li>队列跑完之后，执行新的队列任务。队列包括<ol>\n<li>激活组件的  <code>beforeEnter hook</code></li>\n<li>全局路由的  <code>resolveHooks</code>\n 执行完成后，在 <code>nextTick</code> 后执行路由完成后的回调操作，调用全局的 <code>afterEach</code> 钩子。</li>\n</ol>\n</li>\n</ol>\n<h3 id=\"324-matcher\">3.2.4 matcher</h3>\n<p>上面的路由切换方法中，进场会比较 <code>route</code> 的 <code>matched</code> 属性，而在构造函数中也有</p>\n<pre><code class=\"language-js\">this.matcher = createMatcher(options.routes || [], this)\n</code></pre>\n<p>因此我们来研究下 <code>matcher</code></p>\n<pre><code class=\"language-js\">function createMatcher (\nroutes: Array&lt;RouteConfig&gt;,\nrouter: VueRouter\n): Matcher {\n\nconst { pathList, pathMap, nameMap } = createRouteMap(routes)\n...\nreturn {\n    match,\n    addRoute,\n    getRoutes,\n    addRoutes\n}\n</code></pre>\n<p>首先是根据传入的 <code>routes</code> 通过 <code>createRouteMap</code> 解析为 <code>list</code> 和 <code>map</code> .</p>\n<ul>\n<li>将用户传入的配置进行遍历，对每个路由生成 RouteRecord 存放到 pathList</li>\n<li>pathMap, nameMap 是存放了 path 和 name 对 RouteRecord 的映射</li>\n</ul>\n<pre><code class=\"language-js\">const record: RouteRecord = {\n   path: normalizedPath, // 规范后的路径\n   regex: compileRouteRegex(normalizedPath, pathToRegexpOptions), // 路径对应正则\n   components: route.components || { default: route.component }, // 组件\n   instances: {},\n   name,\n   parent,\n   matchAs,\n   redirect: route.redirect,\n   beforeEnter: route.beforeEnter,\n   meta: route.meta || {},\n   props: route.props == null\n     ? {}\n     : route.components\n       ? route.props\n       : { default: route.props }\n }\n</code></pre>\n<p>在平时的业务开发中，路由的配置不是固定的，根据用户的权限生产对应的路由才是合理的。因此会使用两个方法：</p>\n<ol>\n<li><p>addRoutes</p>\n<pre><code>function addRoutes (routes) {\n  createRouteMap(routes, pathList, pathMap, nameMap)\n}\n</code></pre>\n</li>\n<li><p>addRoute\n```js\nfunction addRoute (parentOrRoute, route) {\n const parent = (typeof parentOrRoute !== &#39;object&#39;) ? nameMap[parentOrRoute] : undefined</p>\n<p> createRouteMap([route || parentOrRoute], pathList, pathMap, nameMap, parent)\n if (parent &amp;&amp; parent.alias.length) {\n createRouteMap(\n     parent.alias.map(alias =&gt; ({ path: alias, children: [route] })),\n     pathList,\n     pathMap,\n     nameMap,\n     parent\n )\n }</p>\n</li>\n</ol>\n<p>}</p>\n<pre><code>逻辑都很简单，直接调用 `createRouteMap` 的方法即可。在添加单个 `route` 时则会处理父级路由和别名的相关逻辑。\n\n`createMatcher` 的返回值中还包括 `match` 方法, 通过这个方法将 `Location` 转化为 `Route`. 这里的 `Location` 就是我们平时使用 push 等方法传入的参数。\n```ts\n type Location = {\n    _normalized?: boolean;\n    name?: string;\n    path?: string;\n    hash?: string;\n    query?: Dictionary&lt;string&gt;;\n    params?: Dictionary&lt;string&gt;;\n    append?: boolean;\n    replace?: boolean;\n}\n\n type RawLocation = string | Location\n</code></pre>\n<p>现在看看 match 方法的执行逻辑</p>\n<pre><code class=\"language-js\">function match (\n    raw: RawLocation,\n    currentRoute?: Route,\n    redirectedFrom?: Location\n): Route {\n    const location = normalizeLocation(raw, currentRoute, false, router)\n    const { name } = location\n    if (name) {\n        const record = nameMap[name]\n\n        if (process.env.NODE_ENV !== &#39;production&#39;) {\n            warn(record, `Route with name &#39;${name}&#39; does not exist`)\n        }\n\n        if (!record) return _createRoute(null, location)\n\n        const paramNames = record.regex.keys\n        .filter(key =&gt; !key.optional)\n        .map(key =&gt; key.name)\n\n        if (typeof location.params !== &#39;object&#39;) {\n        location.params = {}\n        }\n\n        if (currentRoute &amp;&amp; typeof currentRoute.params === &#39;object&#39;) {\n            for (const key in currentRoute.params) {\n                if (!(key in location.params) &amp;&amp; paramNames.indexOf(key) &gt; -1) {\n                    location.params[key] = currentRoute.params[key]\n                }\n            }\n        }\n\n        location.path = fillParams(record.path, location.params, `named route &quot;${name}&quot;`)\n\n        return _createRoute(record, location, redirectedFrom)\n\n    } else if (location.path) {\n        location.params = {}\n        for (let i = 0; i &lt; pathList.length; i++) {\n            const path = pathList[i]\n            const record = pathMap[path]\n            if (matchRoute(record.regex, location.path, location.params)) {\n                return _createRoute(record, location, redirectedFrom)\n            }\n        }\n    }\n    // no match\n    return _createRoute(null, location)\n}\n</code></pre>\n<ul>\n<li>如果 <code>location</code> 包含 <code>name</code> 那么在 <code>nameMap</code> 中通过 <code>name</code> 取到路由</li>\n<li>如果包含 <code>path</code> 则通过遍历 <code>pathList</code> ， 正则匹配到对应的路由\n从这里我们可以知道，如果传递 <code>name</code> 来获取路由是比较方便的，<code>path</code> 的话会进行比较匹配，写在前面会被优先匹配到的</li>\n</ul>\n<p>最终的到的东西就是一个 Route对象</p>\n<pre><code class=\"language-js\">const route: Route = {\n    name: location.name || (record &amp;&amp; record.name),\n    meta: (record &amp;&amp; record.meta) || {},\n    path: location.path || &#39;/&#39;,\n    hash: location.hash || &#39;&#39;,\n    query,\n    params: location.params || {},\n    fullPath: getFullPath(location, stringifyQuery),\n    matched: record ? formatMatch(record) : [] // 这里通过遍历父级，得到完整的路径数组\n  }\n</code></pre>\n<p>由于 这个对象最终被 Object.freeze() ,因此实际使用时，我们无法更改上面的属性</p>\n<h1 id=\"4-内置组件\">4 内置组件</h1>\n<h2 id=\"4-1-router-link\">4. 1 router-link</h2>\n<p>router-link 自动处理了 a 标签 点击跳转的情况，在点击时会触发路由跳转的事件</p>\n<pre><code class=\"language-js\">const handler = e =&gt; {\n    // 默认事件\n    if (guardEvent(e)) {\n        if (this.replace) {\n        router.replace(location, noop)\n\n        } else {\n\n        router.push(location, noop)\n\n        }\n    }\n}\n</code></pre>\n<h2 id=\"42-router-view\">4.2 router-view</h2>\n<pre><code class=\"language-js\">render (_, { props, children, parent, data }) {\n    // routerView标识\n    data.routerView = true\n    const h = parent.$createElement\n    const name = props.name\n    const route = parent.$route\n\n\n  \n    let depth = 0\n    let inactive = false\n    while (parent &amp;&amp; parent._routerRoot !== parent) {\n        const vnodeData = parent.$vnode ? parent.$vnode.data : {}\n        if (vnodeData.routerView) {\n            depth++\n        }\n        // keep-alive 逻辑\n        if (vnodeData.keepAlive &amp;&amp; parent._directInactive &amp;&amp; parent._inactive) {\n            inactive = true\n        }\n        parent = parent.$parent\n\n    }\n    // 得到routerview的深度，确定当前的路由\n    data.routerViewDepth = depth\n\n    // render previous view if the tree is inactive and kept-alive\n    if (inactive) {\n        const cachedData = cache[name]\n        const cachedComponent = cachedData &amp;&amp; cachedData.component\n\n        if (cachedComponent) {\n            if (cachedData.configProps) {\n                fillPropsinData(cachedComponent, data, cachedData.route, cachedData.configProps)\n            }\n            return h(cachedComponent, data, children)\n        } else {\n            return h()\n        }\n    }\n\n    const matched = route.matched[depth]\n    const component = matched &amp;&amp; matched.components[name]\n    // cache component\n    cache[name] = { component }\n\n  \n    // 这个方法也是在初始化的时候进行的调用\n    // 用来设置当前路由匹配的组件实例\n    data.registerRouteInstance = (vm, val) =&gt; {\n        const current = matched.instances[name]\n        if (\n        (val &amp;&amp; current !== vm) ||\n        (!val &amp;&amp; current === vm)\n        ) {\n            matched.instances[name] = val\n        }\n    }\n    // hook注入\n    data.hook.prepatch = (_, vnode) =&gt; {\n        matched.instances[name] = vnode.componentInstance\n    }\n    data.hook.init = (vnode) =&gt; {\n        if (vnode.data.keepAlive &amp;&amp;\n        vnode.componentInstance &amp;&amp;\n        vnode.componentInstance !== matched.instances[name]\n        ) {\n        matched.instances[name] = vnode.componentInstance\n        }\n        handleRouteEntered(route)\n    }\n\n    const configProps = matched.props &amp;&amp; matched.props[name]\n    return h(component, data, children)\n\n}\n</code></pre>\n<p>主要逻辑就是：</p>\n<ol>\n<li>标识当前路由为 routerview</li>\n<li>往父级遍历，得到当前的 routerview 深度，确定 route</li>\n<li>兼容 keep-alive 的逻辑，处理缓存逻辑</li>\n<li>渲染组件</li>\n</ol>\n<h1 id=\"5-最后总结\">5. 最后总结</h1>\n<p>看完核心逻辑后，我最初的疑问基本得到了解答。感觉还是挺有收获的。知道了路由的第三种模式，路由切换的整体过程，路由的匹配逻辑。也了解了 router-view 这种函数式组件的实现。\n我还有一个问题未得到答案</p>\n<pre><code>3. 和Transition是怎么搭配合作的\n</code></pre>\n<p>看来只有到时候看 Vue 源码时才能有收获了.</p>\n",
        "title": "Vue Router 源码学习",
        "created": "2022-06-13 16:35:26  ",
        "updated": "2022-06-13 16:35:26 ",
        "excerpt": "1. 我的疑问 Vue Router 的使用频率还是很高的，作为开发者，我们可能知道 hash路由和 history路由 的区别和实现原理。但是一些还是东西是值得理解的。 内置组件 router-view 是怎么实现的 路由守卫是怎么实现的...",
        "avatar": "https://avatars.githubusercontent.com/u/26271337?v=4",
        "id": "8"
    },
    "9": {
        "content": "<h1 id=\"tldr\">TL,DR</h1>\n<p>最近半年对两个业务系统进行了重构升级，重构前的代码都是几千行的业务逻辑。在做业务迭代的过程中考虑到开发的难度和后续的维护，于是对就有组件进行了重构。经过重构将大文件组件进行拆分，方便了后续的扩展和维护。</p>\n<h1 id=\"业务背景\">业务背景</h1>\n<p>部门负责的业务中包含一个订单系统，该系统内部包含多种角色，10 余种订单状态，约30种订单操作。业务的前端页面由订单列表和订单详情两个主要组件构成，且订单详情页面展示时覆盖在订单列表上，并未使用独立页面。</p>\n<p>由于历史原因和不断的迭代，造成页面组件的代码行数几千行，且订单详情组件拥有多种自定义状态。</p>\n<p>由于版本迭代，页面UI需要进行调整，订单流程需要精简。结合当前的代码状况，于是决定进行重构。</p>\n<h1 id=\"重构过程\">重构过程</h1>\n<h2 id=\"1-针对订单操作进行拆分\">1. 针对订单操作进行拆分</h2>\n<p>将每个操作抽离成单独的就是</p>\n<pre><code class=\"language-js\">function checkValid(){}\nfunction actionHandle(){}\n\nexport default {\n    label: &#39;订单操作&#39;， \n    style: &#39;&#39;，\n    valid: checkValid,\n    handle: actionHandle,\n}\n</code></pre>\n<p>将每个操作定义成如上数据结构，存入操作的数组中。然后在列表中直接传入 当前行的数据，执行每个操作的valid的方法，过滤出适合当前行数据的操作。\n定义好相关的订单操作后，在列表组件中 ,</p>\n<pre><code class=\"language-js\">\nconst actionList = [...]\n\nexport default {\n    created() {\n        actionList.map(action =&gt; {\n            action.valid = action.valid.bind(this)\n            action.handle = action.handle.bind(this)\n        })\n        this.actionList \n    },\n    methods: {\n        getValidActionList(order) {\n            return this.actionList.filter(action =&gt; action.valid(order))\n        }\n    }\n    \n}\n</code></pre>\n<p>这一块的逻辑也可以单独放在 <code>mixin</code> 里面，之前有一个业务 列表有两种展示方式，卡片和普通列表。像这种情况我们把操作抽离出来，最后混入到对应的列表和卡片组件中即可。</p>\n<p>上述的操作还存在一个问题，就是操作的实际点击事件，很多都会包含视图的变化，弹一些弹窗之类的。 </p>\n<p>如果按照普通的逻辑，将弹窗定义在 列表组件中，然后再维护弹窗显示的状态，整个列表组件还是臃肿，而且视图和逻辑分离，不利于代码的阅读。</p>\n<p>这里我使用了 <code>Vue.extend</code>, 将所有的弹窗组件都封装成函数，将props时通过函数参数进行传入，将弹窗完成的操作通过props定义的回调函数进行传出。</p>\n<p>通过这种代码结构，我们把操作完全抽离，实现了十分合理的解耦</p>\n<h1 id=\"订单详情改造\">订单详情改造</h1>\n<p>之前版本的订单详情展示时是覆盖在订单列表上面的，这导致在详情时刷新页面时会展示为订单列表页面，这种实现和业务交互是不太合适的。</p>\n<p>订单详情页面之前包含 订单发单， 订单审核，订单详情 逻辑。组件的自定义状态过多，视图展示在不同状态的也有差异。因此整体详情的逻辑还是比较混乱的。</p>\n<p>因此在重构时，我将发单，详情，审核的逻辑抽离为单独的组件，通过不同的路由进行分发。对于试图相同的部分抽离为组件。</p>\n<p>将这个大组件拆分成各种逻辑的独立组件后，代码可读性高了很多。在平时的业务开发中，我们也应该注意业务组件公用。在视图的重合比例较高且业务逻辑较为简单时，将组件进行公用是OK的，更多的时候拆分为独立组件对于后续的维护和迭代好处更大</p>\n<h1 id=\"写在最后\">写在最后</h1>\n<p>最后终结下大组件的拆分吧。</p>\n<ol>\n<li>可以通过 mixin 和 Vue.extend 对业务逻辑进行抽离</li>\n<li>将多状态组件抽离为多个单状态组件</li>\n</ol>\n<p>重构的还是有一定风险的，重构过程中不能一蹴而就。一部分一部分的进行重构，写完之后及时测试，保证业务逻辑的正确。全部开发完成后也需要进行回归测试。</p>\n<p>业务开发时，<code>屎山上拉屎</code> 是一种妥协。如果时间允许且对于业务和自己有益处的话，还是推荐重构的。</p>\n",
        "title": "订单业务重构，谈谈大组件的拆分",
        "created": "2022-06-14 12:46:40  ",
        "updated": "2022-06-14 12:46:40 ",
        "excerpt": "TL,DR 最近半年对两个业务系统进行了重构升级，重构前的代码都是几千行的业务逻辑。在做业务迭代的过程中考虑到开发的难度和后续的维护，于是对就有组件进行了重构。经过重构将大文件组件进行拆分，方便了后续的扩展和维护。 业务背景 部门负责的业务...",
        "avatar": "https://avatars.githubusercontent.com/u/26271337?v=4",
        "id": "9"
    },
    "10": {
        "content": "<h1 id=\"一业务背景\">一.业务背景</h1>\n<p>部门负责的业务主要是 H5 营销物料的制作，会有第三方使用我们的服务制作营销物料。作为营销产品，第三方往往需要私有化部署，自己保存相关的数据。当第三方需要进行数据采集或者在我们现有的框架上进行第二次开发时，就需要我们提供相应的SDK能力给对方。</p>\n<p>旧代码中暴露的方式是通过全局的回调函数，但是随着业务的复杂度提升，所需要的回调函数也会越来越多。而且客户有进行二次开发的需求，简单的回调函数不能满足该需求。</p>\n<p>因此决定根据在现有的框架的基础上开发一套SDK，暴露自身的业务能力和数据给第三方。</p>\n<h1 id=\"二-设计原则\">二. 设计原则</h1>\n<p>在进行SDK设计时，我的设计原则是：</p>\n<ol>\n<li>对现有业务代码侵蚀小，不污染业务逻辑</li>\n<li>接口易懂，方便调用</li>\n<li>不影响当前业务</li>\n<li>扩展性强</li>\n</ol>\n<h1 id=\"三实操过程\">三.实操过程</h1>\n<h2 id=\"31-发布订阅\">3.1 发布订阅</h2>\n<p>首先是事件分发，这里我采用了 <code>发布订阅</code> 的设计模式。当业务逻辑执行时，主动分发相关事件，提供给订阅者使用。</p>\n<pre><code class=\"language-js\">class EventEmitter {\n    listener= {}\n    $on(eventName, handler) {\n        !this.listener[eventName] &amp;&amp; (this.listener[eventName] = [])\n        this.listener[eventName].push(handler)\n    }\n    $emit(eventName, data) {\n        if (listener[eventName]) {\n            this.listener[eventName].forEach(handler =&gt; {\n                handler(data)\n            })\n        }\n    }\n}\n</code></pre>\n<p>上面就是一个简单的 发布订阅 设计模式，在此基础可以进行功能的丰富。例如直接进行全部事件的的订阅，取消订阅等逻辑。</p>\n<h2 id=\"32-阻止默认事件\">3.2 阻止默认事件</h2>\n<p>对于业务系统的事件，在事件发生时，可以提供给用户阻止默认事件发生的能力，方便用户进行自定义操作。于是我模仿了 <code>DOM</code> 的 <code>EventListener</code> 的模式，在执行一些事件前提供阻止事件的能力。</p>\n<p>用户在使用时，可以这么进行调用</p>\n<pre><code class=\"language-js\">sdk.$on(&#39;before:&lt;EventName&gt;&#39;, (e) =&gt; {\n    e.preventDefault()\n})\n</code></pre>\n<p>在进行事件设计时，一般的业务都会分发两个事件 <code>before:&lt;EventName&gt;</code> 和 <code>after:&lt;EventName&gt;</code>.</p>\n<p>那在具体代码中是怎么实现这个逻辑的呢？</p>\n<p>我是这么实现的, 先定义事件响应结果的类</p>\n<pre><code class=\"language-js\">\nclass EventResponse {\n    data = {}\n    constructor(data, eventName, eventHandler) {\n        this.data = data\n        this.type = eventName\n        this.preventDefault = () =&gt; eventHandler.isPrevent = true\n    }\n}\n</code></pre>\n<p>然后在 <code>EventEmitter</code> 中，将 响应的实例传递给每个订阅者</p>\n<pre><code class=\"language-js\">...\n$emit(eventName, data) {\n    let eventHandler = {\n        isPrevent: false,\n    }\n    const eventResponse = new EventResponse(data, eventName, eventHandler)\n    \n    if (listener[eventName]) {\n            this.listener[eventName].forEach(handler =&gt; {\n                handler(eventResponse)\n            })\n    }\n    return eventHandler.isPrevent\n}\n...\n</code></pre>\n<p>如果有订阅者调用 <code>preventDefault</code> 方法，则会让 <code>isPevent</code> 为 <code>false</code>。然后业务代码根据返回的值决定是否继续业务逻辑，当然此处只支持同步的阻止，异步阻止并无实际的业务意义。</p>\n<p>接下来，我们看看业务代码如何进行事件分发</p>\n<h2 id=\"33-事件代理\">3.3 事件代理</h2>\n<p>查看了旧的业务代码，业务相关的功能函数中充斥着各种回调，埋点的逻辑，实际的功能逻辑被大幅度污染。</p>\n<p>因此我决定不在现有函数中进行事件的分发，而是利用 函数代理，实现事件的分发。</p>\n<p>函数代理很简单，就是将原函数进行包裹，混入一些其他逻辑。</p>\n<pre><code class=\"language-js\">function registProxy(orgin, methodName) {\n    const originMethod = origin[methodName]\n    origin[methodName] = function () {\n        // 其他混入逻辑\n        originMethod.apply(this, arguments)\n    }\n}\n</code></pre>\n<p>这里我主要是混入一些 hook, 然后和之前的事件分发结合起来 ,于是我的代码是这样的</p>\n<pre><code class=\"language-js\">function registProxy({\n    origin,\n    methodName,\n    beforeHook,\n    afterHook,\n\n}) {\n    const originMethod = origin[methodName]\n    orgin[methodName] = function (...args) {\n        const isPrevent = beforeHook(...args)\n        if (isPrevent) return\n        originMethod(...args)\n        afterHook &amp;&amp; afterHook(...args)\n    }\n}\n\nfunction registSyncHook(origin, methodName, eventCode) {\n    registProxy({\n        origin,\n        methodName,\n        beforeHook(...args) {\n            return sdk.$emit(&#39;before:&#39; + eventCode, args)\n        },\n        afterHook: (...args) =&gt; {\n        return iw_emitter.$emit(&#39;after:&#39; + eventCode, args)\n\n        },\n    })\n}\n</code></pre>\n<p>这里通过注入前后 <code>hook</code> 实现了原有函数的代理, 使用 <code>eventCode</code> 和 被代理的函数， 实现了 事件的分发和默认事件的阻止。</p>\n<p>到了目前这一步，其实已经能够满足基本的需求了，但是实际业务中包含很多异步的逻辑，通过回调函数实现函数的结束，这种情况 <code>afterHook</code> 就无法正常起作用了。</p>\n<p>其实对异步的处理也很简单，对于拥有回调函数的的函数我们可以这么进行处理</p>\n<pre><code class=\"language-diff\"> function registProxy({\n     orgin,\n    methodName,\n    beforeHook,\n    afterHook,\n+      isAsync\n }) {\n     ...\n    // 在beforeHook改变参数中的回调函数，\n+\tlet curArgs = args\n+\tconst emitResponse = beforeHook(...args)\n+\tif (emitResponse.isPrevent) return\n-      const isPrevent = beforeHook(...args)\n-      if (isPrevent) return \n+\tif (emitResponse.args) {\n+\t\tcurArgs = emitResponse.args\n+\t}\n+\torginMethod(...curArgs)\n+   if (isAsync) return\n    ...\n}\n\nfunction registAsyncHook(origin, method, eventCode, injectArgsFunc) {\n    registProxy({\n        ...\n        beforeHook: (...args) =&gt; {\n            // injectArgsFunc 函数更改被代理函数的 回调函数\n            // 在回调函数中放入 afterhook 的逻辑\n            const newArgs = injectArgsFunc(args)\n            const isPrevent = iw_emitter.$emit(&#39;before:&#39; + eventCode, args)\n            // 返回新的参数和是否阻止的字段\n            return {\n                isPrevent,\n                args: newArgs,\n            }\n        },\n        isAsync: true\n    })\n\n}\n</code></pre>\n<p>通过对被代理函数 回调函数参数的处理，我们实现了 <code>afterHook</code> 对异步函数的兼容。</p>\n<p>这是实际使用的例子</p>\n<pre><code class=\"language-js\">const injectTestArgsFunc = eventCode =&gt; (args) =&gt; {\n    const {\n        2: callback\n        } = args\n    const newCallback = () =&gt; {\n        sdk.$emit(`after:${eventCode}`, args)\n        callback &amp;&amp; callback()\n    }\n    const newArgs = [...args]\n    newArgs.splice(2, 1, newCallback)\n    return newArgs\n}\n\n\nregistAsyncHook(window, &#39;test&#39;, &#39;test:new&#39;, injectTestArgsFunc(&#39;test:new&#39;))\n</code></pre>\n<p>对于支持 <code>promise</code> 的处理就相对简单了，这里就不进行讨论了。</p>\n<h2 id=\"34-总体处理\">3.4 总体处理</h2>\n<p>当我们将上面的工具函数写好之后，就可以对框架中需要进行暴露的业务函数进行代理，注入相关 <code>hook</code>,\n并将相关的 <code>eventCode</code> 整理成文档，提供给第三方进行使用。对于函数的代理，我们可以写一个函数进行处理，在 <code>SDK</code> 初始化时才进行代理。这样处理的好处在于如果不使用 <code>SDK</code>，对现有的业务逻辑没有一点影响，而且也不影响在线的 <code>debug</code>。</p>\n<pre><code class=\"language-js\">function initRegistProxy() {\n    registAsyncHook(...)\n    registSyncHook(...)\n    ...\n}\n    \nclass EventEmitter {\n    ...\n    \n    init() {\n        initRegistProxy()\n    }\n    ...\n}\n    \nconst sdk = new EventEmitter()\n\n// 用户使用时\nsdk.init()\nsdk.$on(&#39;before:&lt;EventCode&gt;&#39;,()=&gt;{})\n</code></pre>\n<h2 id=\"35-用户主动触发事件\">3.5 用户主动触发事件</h2>\n<p>这个逻辑也好处理，就是 发布者 和 订阅者 的身份对换即可。 业务事件函数订阅相关的 <code>event</code>, 用户可以使用 <code>SDK</code> 进行<code>sdk.$emit(&#39;&lt;eventCode&gt;&#39;)</code>发布事件即可。</p>\n<h1 id=\"四-写在最后\">四. 写在最后</h1>\n<p>经过这次 <code>SDK</code> 开发，加深了我对设计模式的理解，好的设计模式对于代码的解耦非常有帮助。</p>\n<p>同时我也学会了通过 函数代理 来对函数进行扩展，避免对函数内部的业务逻辑产生影响。</p>\n<p>当然 <code>SDK</code> 的开发最重要的还是文档，好的文档描述可以让开发者快速接入 <code>SDK</code>. 对于双方的对接效率有很大的提升。</p>\n",
        "title": "提供业务能力，SDK的开发",
        "created": "2022-06-15 16:08:51  ",
        "updated": "2022-06-15 16:08:51 ",
        "excerpt": "一.业务背景 部门负责的业务主要是 H5 营销物料的制作，会有第三方使用我们的服务制作营销物料。作为营销产品，第三方往往需要私有化部署，自己保存相关的数据。当第三方需要进行数据采集或者在我们现有的框架上进行第二次开发时，就需要我们提供相应的...",
        "avatar": "https://avatars.githubusercontent.com/u/26271337?v=4",
        "id": "10"
    },
    "11": {
        "content": "<h1 id=\"一-业务背景\">一. 业务背景</h1>\n<p>日常的工作有很大一部分都是编辑器的开发。由于业务需求，今年推动了全景编辑器2.0的重构。本文会主要讲述此次重构的全部细节。</p>\n<p>作为一款编辑器，老版全景编辑器的功能存在很多问题。</p>\n<ol>\n<li>数据实时变化，用户操作后立即保存。不能进行撤销，也无历史记录功能</li>\n<li>前后端耦合严重，新功能开发需要依赖前后端共同协作</li>\n<li>用户使用体验不好，操作后数据流转和接口请求逻辑混乱，有明显的卡顿</li>\n<li>业务打包历史包袱重，各种大组件和事件传递，维护成本高</li>\n</ol>\n<p>当前的业务架构不在满足后续业务的开发，于是我决定重构。</p>\n<h1 id=\"二-重构目标\">二. 重构目标</h1>\n<p>作为编辑器的主程，产品在规划2.0版的新功能时，我基于当前业务现状和主管提出了重构的想法。通过重构后，主要能够实现的目标有：</p>\n<ol>\n<li>满足2.0的产品需求，不进行实时保存，在前端存储数据，由用户决定数据的保存</li>\n<li>减少前后端耦合，减少接口请求。后续新功能可以完全有前端进行开发。</li>\n<li>性能优化，提高用户的使用体验</li>\n<li>全景逻辑和UI框架逻辑抽离，让全景编辑的逻辑完全独立，即时使用其他UI框架也能快速实现编辑器</li>\n</ol>\n<h1 id=\"三-具体实操\">三. 具体实操</h1>\n<h2 id=\"31-数据建模\">3.1 数据建模</h2>\n<p>首先是数据，和H5编辑器不同，老版本的全景编辑器在前端存储的数据是很零散的。完全通过 <code>krapno</code> 读取全景的数据。在数据更改时直接提交后端，更改配置 <code>XML</code> 文件，前后端耦合非常严重。</p>\n<p>因此数据方面我完全放弃从 <code>krpano</code> 实例中读取数据，而是在进入编辑器时获取该物料的 XML配置文件，然后将 <code>XML</code> 转化为 <code>DOM</code>，从 <code>DOM</code> 中获取数据构建整个全景的 <code>JSON</code> 树，后续的编辑器操作都基于 <code>JSON</code> 操作。</p>\n<p>从 <code>XML</code> 到 <code>JSON</code> 的转化过程中，我对全景中所有的组件都进行数据建模。包括 热点，图层，标尺等，声明的类大约 20余种。每个类都提供解析 <code>XML</code> 获取 <code>JSON</code> 的方法，最终对整个 <code>XML</code> 进行操作，就获取到所有的组件数据了。</p>\n<pre><code class=\"language-js\">class Hotspot {\n    static parseDOM(DOM) {\n        ...\n        return {...}\n    }\n}\n</code></pre>\n<p>对数据建模的好处,  不止在于解析数据。上面我也提到，我希望将全景编辑的逻辑和UI逻辑抽离，而通过类来对相关的组件进行数据和逻辑的封装就非常好用。我将 <code>krpano</code> 相关的操作全部封装到对应的类中，操作数据时，直接调用相关的类和实例的方法即可</p>\n<pre><code class=\"language-js\">class Hotspot {\n    add() {}\n    remvoe() {}\n    update(...) {}\n}\n</code></pre>\n<p>这样就不用在 <code>Vue</code> 代码中写 <code>krpano</code> 的相关逻辑了，界面表单在更新 <code>JSON</code> 数据时，使用封装好的类同步预览的视图即可。</p>\n<h2 id=\"32-组件拆分\">3.2 组件拆分</h2>\n<p>旧代码中包含很多的大组件，例如热点组件，热点的类型有7种，每种热点的属性各有异同。老组件中直接包含所有热点的配置，各种状态判断，十分混乱。</p>\n<p>这里的重构逻辑很简单，拆分组件，每种类型热点对应相关的属性组件，编辑时通过数据类型标识识别对应组件然后用动态组件进行展示。</p>\n<p>对于其他的大组件，我们也采用一样的方法进行抽离，保证组件的颗粒度，保证组件的业务复杂度不能过高。</p>\n<h2 id=\"33-切图处理\">3.3 切图处理</h2>\n<p>用户上传的全景图是一张2：1的图片，无法直接被全景使用。我们使用 <code>krpano</code> 官方提供的切图工具在服务器进行切图，然后放到对应的物料文件夹中。</p>\n<p>重构时有考虑前端切图，普通切图将全景图分割为6张图片是可以实现的，但是业务场景更多的需要的是高清切图，由于算法问题，最终还是放弃了这个小优化。</p>\n<p>老版本切图存在一个问题，就是用户在进行切图时，对服务器的压力特别大，后端在队列管理上也处理的不好，没有进行异步处理。这就导致多用户多图上传时，等待的时间可能会特别久，如果接口超时失败，前端也未进行相关处理。10张切图，有一张失败了都会造成整体操作失败，用户体验十分糟糕。</p>\n<p>我这边的处理也很简单，切图时不使用遮罩阻止用户操作。将每个切图都变成任务，每个任务有各自的进度条，任务之间互不影响。这样用户在编辑物料时也能进行上传的操作，用户使用体验大幅提高。</p>\n<p>同时为了缓解服务器压力，前端封装了一个 任务调度器 <code>scheduler</code>, 用户任务最多并行两个。 当然这个处理的收益还是比较小的，也不能真正解决问题，还是需要后端进行优化。</p>\n<h2 id=\"34-最终保存\">3.4 最终保存</h2>\n<p>重构一开始的目的就是为了最终保存，用户拥有数据保存的决定权。在编辑器对 <code>JSON</code>进行编辑后，我们需要进行转换。将 <code>JSON</code> 重新转化为 <code>XML</code>，这里同样使用类的序列化方法</p>\n<pre><code class=\"language-js\">class Hotspot {\n    serialize(data) {\n        ...\n        return `&lt;hotspot ... /&gt;`\n    }\n}\n</code></pre>\n<p>这里在进行开发时还是遇到了坑， 一开始我们使用的是对属性进行遍历，然后通过字符串组装成 <code>XML</code>，由于业务场景不需要关心 <code>XSS</code> 的问题。但是在代码提测之后，问题接踵而来。当输入特殊字符或者引号之类的特殊符号时，由于 <code>XML</code> 的格式要求，<code>XML</code> 就变成了非法的 <code>XML</code> 文档了，这也造成了全景保存失败。</p>\n<p>因此我们选择通过将 <code>JSON</code> 转化成通过 <code>DOM</code> 提供的能力来进行序列化</p>\n<pre><code class=\"language-js\">const hotspot = document.createElement(&#39;hotspot&#39;) \n...\n    hotspot.setAttribute(key, value)\n...\nreturn hotspot.outerHTML\n</code></pre>\n<p>这种方法解决了大部分的问题，但是还是会有不少的坑，例如 <code>word</code> 中的特殊空格，就是无法进行保存。定位到问题后，只能根据 <code>unicode</code> 进行匹配替换。</p>\n<p>还有富文本的情况，富文本通过属性进行保存时也会存在问题，要么是预览异常，要么是回显到富文本编辑器异常。最终还是决定针对富文本进行字符串拼接，然后将<code>&amp;</code>,<code>&lt;</code>,<code>&gt;</code>,<code>&quot;</code>符号进行实体化处理，上线后到目前为止暂时无任何异常。</p>\n<h1 id=\"四最后结果\">四.最后结果</h1>\n<p>经过2.0 的重构，在业务架构上减少了后端的依赖，大幅提高了用户的使用体验。 让用户可以通过全景编辑器快速制作出全景漫游物料，添加丰富的交互效果。</p>\n<p>在前端代码设计上，让全景编辑的逻辑完全独立，针对全景模块进行数据建模，对后续维护和新增功能十分的友好。</p>\n<p>当然通过这次大的重构，无论是业务架构设计还是组件拆分，我都有了巨大的收获。</p>\n<p>当然重构到目前为止，编辑器已经重构的十分强大了。但是还是缺少一个最重要的功能： 历史记录。后面我会有专文介绍历史记录功能的实现，和具体业务难点。</p>\n",
        "title": "编辑器重构，数据建模实践",
        "created": "2022-06-16 14:33:48  ",
        "updated": "2022-06-16 14:33:48 ",
        "excerpt": "一. 业务背景 日常的工作有很大一部分都是编辑器的开发。由于业务需求，今年推动了全景编辑器2.0的重构。本文会主要讲述此次重构的全部细节。 作为一款编辑器，老版全景编辑器的功能存在很多问题。 数据实时变化，用户操作后立即保存。不能进行撤销，...",
        "avatar": "https://avatars.githubusercontent.com/u/26271337?v=4",
        "id": "11"
    },
    "12": {
        "content": "<h1 id=\"一-业务背景\">一. 业务背景</h1>\n<p><a href=\"https://github.com/vivipure/blog/issues/11\">上文</a>我讲了编辑器的整体重构，也留下了一个关于 <strong>历史记录</strong> 的坑。在我们的业务中，无论老版本还是新版，都缺少历史记录的功能。 </p>\n<p>作为一款编辑器，不能进行历史记录的展示，不能进行操作的回退和重做是不完整的。因此开发历史记录功能刻不容缓。</p>\n<h1 id=\"二-方案选型\">二. 方案选型</h1>\n<p>和H5编辑器不一样，在H5编辑器中，我们可以通过JSON直接控制相关元素的展示。历史记录功能可以将JSON在操作后进行备份，回撤时直接使用备份的JSON即可。</p>\n<p>这也是通过 <code>快照方式</code> 实现历史记录功能的基本逻辑，但是全景编辑器却无法使用这个功能，全景编辑器的预览并不是由JSON直接控制，每次JSON更新都需要手动更新预览。如果通过 <code>快照方式</code>实现该需求，那么在进行回撤时，全景预览就会重载，用户使用体验十分不好。我们更需要的是十分精细的更新。</p>\n<p>于是我选择了 <code>命令模式</code> ，我在全局建立一个历史记录的一个管理类，用户的每一次操作都会触发一个命令，然后 <code>push</code> 到历史记录中。在历史记录中可以看到每个命令的细节，点击对应命令时，根据状态执行当前命令和点击命令之间的所有命令的动作，执行就是重做，撤销就是回撤。这样就实现了历史记录功能和重做撤销。</p>\n<h1 id=\"三-实操\">三. 实操</h1>\n<h2 id=\"31-定义命令类和控制类\">3.1 定义命令类和控制类</h2>\n<p>首先是定义命令基类</p>\n<pre><code class=\"language-js\">class Command {\n    name\n    excute() {}\n    undo() {}\n}\n</code></pre>\n<p>每个命令包含 name 和 执行重做两个方法。接下来就是管理器</p>\n<pre><code class=\"language-js\">class Controller {\n    commandStack = []\n    curIdx = 0\n    maxLength = 30\n    \n    execute(command){}\n    undo(idx){...}\n    redo(idx){...}\n    \n    deal(command) {\n        const idx = this.commandStack.findIndex(c =&gt; c=== command)\n        if(idx &lt; this.curIdx) {\n            this.undo(idx)\n        } else {\n            this.redo(idx)\n        }\n    }\n\n}\n</code></pre>\n<p>管理器中维护了一个命令的数组和当前的索引，这种实现比使用 重做和撤销两个数组 要简单和清晰。同时也定义了历史记录的最大数。 每个命令都需要管理器进行执行， 然后管理器也提供重做和撤销功能.</p>\n<p>具体的重做和撤销代码我这里就展开了，实际逻辑很简单，就是从数组中取出对应的命令执行相关的操作，然后更新索引即可。</p>\n<h2 id=\"32-和框架结合\">3.2 和框架结合</h2>\n<p>我引入命令模式，其实是希望通过命令来进行数据的更新和视图的更新，但是 <code>Vue</code> 作为数据绑定的框架，当视图改变后，数据自动更新了，并没有在命令类中进行操作。这其实不符合我的预期。这样对后面的重做和撤销操作也会有影响，会造成无法对比更改的问题。</p>\n<p>我的解决方法也很简单，就是当编辑器选中编辑数据时，特定的数据，使用特定的更新命令类记录当前的数据。</p>\n<pre><code class=\"language-js\">watch: {\n    editData  {\n        handler(cur, last) {\n            // 不同数据，设置备份\n            if(cur !== last) {\n                if(this.editType === editTypeConst.hotspot) {\n                    UpdateHotspotCommand.setTarget(cur)\n                }\n            }else {\n                // 相同数据，意味着数据变动\n                const command = new UpdateHotspotCommand(cur)\n                // 管理器实触发罚命令\n                controller.execute(command)\n            }\n        },\n        deep: true\n    }\n}\n\nclass UpdateHotspotCommand extends Command {\n    static target = null\n    \n    static setTarget(data) {\n        this.target = JSON.parse(JSON.stringify(data))\n    }\n    execute() {}\n    undo() {}\n    // 数据变化后，比较数据之间不同的字段\n    getDiffKeys() {}\n\n}\n</code></pre>\n<p>每次选中数据时，就将当前数据备份，当数据更改后就触发对应命令。在命令类中进行数据比较，然后在 \n<code>execute</code>, <code>undo</code> 更改数据和引用对应的类更新视图。 之前重构时还是的必须将类在Vue文件中使用，通过这种方式，完全进行了隔离，每个组件只关心 <code>JSON</code> 数据的改变，视图的更新通过 <code>watch</code> ,生成命令进行控制。</p>\n<p>上面主要讲的是更新命令和 <code>Vue</code> 框架的兼容，其他的删除，添加命令就要简单的多了。</p>\n<h2 id=\"32-命令合并的实现\">3.2 命令合并的实现</h2>\n<p>在进行开发时，有参考 <code>photoshop</code> 历史记录的实现，对于同一个对象同一种操作，历史记录会进行合并，只会出现一条记录。在全景编辑器中也会出现热点移动等多次触发的操作，因此也需要实现命令合并的功能，优化历史记录的展示。</p>\n<p>具体的实现也很简单，在 <code>controller</code> 执行命令时，判断当前命令是否有实现合并的方法，如果有且上一条命令和当前命令是同一命令的实例，就进行比较。</p>\n<p>主要比较数据改变的字段是否一致，如果字段一致，那么就将当前命令更新的部分合并到上一条命令中即可，这样就实现了命令的合并功能。</p>\n<h1 id=\"四-命令模式存在的问题\">四. 命令模式存在的问题</h1>\n<p><code>命令模式</code> 对我们管理应用的数据操作有着很大的好处，但是它也存在一个很明显的问题。就是随着操作的变多，相关的命令文件也会随之膨胀，编辑器几十上百种操作都需要进行定义相关命令类，工作量和代码体积膨胀都是问题。</p>\n<p>但是 <code>命令模式</code> 对于全景编辑器的业务场景十分适合，用户体验也十分友好，毕竟也不想用户每次回撤都黑屏一下。因此基于业务场景，最终还是使用了这套方案</p>\n<h1 id=\"五-最后总结\">五. 最后总结</h1>\n<p>通过对编辑器的历史记录功能开发，我学会了 <code>命令模式</code> 和 <code>快照方式</code> 两种方案。我们在实际业务开发中可以根据业务场景进行技术选型。 如果是简单的H5编辑器，那么 <code>快照方式</code> 就足够了。但如果你的业务场景也和我们的场景类似，数据和预览视图是完全独立的场景，那么 <code>命令模式</code> 是比较合适的。</p>\n<p>没有完美的技术方案， 我们只能选择做相对正确的事而不是做简单的事！</p>\n",
        "title": "编辑器历史记录功能，命令模式实操",
        "created": "2022-06-16 15:18:46  ",
        "updated": "2022-06-18 10:04:15 ",
        "excerpt": "一. 业务背景 上文我讲了编辑器的整体重构，也留下了一个关于 历史记录 的坑。在我们的业务中，无论老版本还是新版，都缺少历史记录的功能。 作为一款编辑器，不能进行历史记录的展示，不能进行操作的回退和重做是不完整的。因此开发历史记录功能刻不容...",
        "avatar": "https://avatars.githubusercontent.com/u/26271337?v=4",
        "id": "12"
    },
    "13": {
        "content": "<h1 id=\"一-业务背景\">一. 业务背景</h1>\n<p>部门的业务主要是营销物料的生产，可以分发到不同终端。手机可以在H5，小程序展示，PC可以打包成 electron应用，但是目前在安卓应用上是空缺的。因此需要提供用户可以将制作的物料直接打包成安卓应用的能力。</p>\n<h1 id=\"二技术选型\">二.技术选型</h1>\n<p>在前端相关框架中，提供将H5打包成安卓应用的框架很多。我们主要需要的是能够进行二次开发，且能够快速进行接入。</p>\n<p>其实一开始有想过自己封装 webview ，然后实现混合应用框架的方案的。但是部门内部都没有安卓开发的经验，且需求时间较紧，选择现有的混合框架符合我们的当前的业务场景。</p>\n<p>最终选择了 <a href=\"https://capacitorjs.com/\">capacitor</a> 这个框架，这个框架可以看作在 cordova 的进阶版。功能比较齐全，且提供了很多插件。</p>\n<h1 id=\"三-自动化实现\">三. 自动化实现</h1>\n<p>打包成安卓应用很简单，capacitor 新建一个项目，然后将h5放到指定目录中，然后执行相关命令即可。</p>\n<p>需求的主要难点在于如何实现自动化，后端可以通过 java 直接调用服务器打包应用，然后提供接口给前端。最终展示给用户的就是一个按钮，打包成功后自动通知用户，用户下载应用即可。</p>\n<p>查看了相关文档之后，其实也很简单，主要就是在服务器安装安卓环境，然后执行capacitor的打包即可。</p>\n<h2 id=\"31-安卓环境配置\">3.1 安卓环境配置</h2>\n<p><code>SDKManger</code> 是 <code>Androdi SDK</code> 管理工具，可以通过 <code>SDKManager</code> 下载  <code>Androdi SDK</code></p>\n<pre><code class=\"language-shell\"># 下载\n\ncurl -O https://dl.google.com/android/repository/commandlinetools-linux-7583922_latest.zip\n\n# 解压到目录 得到文件夹 cmdline-tools\n\nunzip commandlinetools-linux-7583922_latest.zip\n\n# 打开到 cmdlin-tools/bin 下载SDK 31（若需要其他版本sdk， 可更换版本号）\n\n./sdkmanager --sdk_root=../ --install &quot;build-tools;31.0.0&quot; &quot;platforms;android-31&quot;\n</code></pre>\n<p>设置环境变量 ， 指定android_home 的路径为cmdline-tools的绝对路径</p>\n<pre><code class=\"language-shell\">sudo vim /etc/profile\n\n...\n\n# Android\n\nexport ANDROID_HOME=...\n\nexport PATH=$ANDROID_HOME/tools:$ANDROID_HOME/platform-tools:$PATH\n\n...\n\n# 应用\n\nsource /etc/profile\n</code></pre>\n<h2 id=\"32-capacitor-安装\">3.2 capacitor 安装</h2>\n<pre><code class=\"language-shell\">npm init -y\n\n# 下载capacitor依赖 \n\nyarn add @capacitor/core @capacitor/cli @capacitor/android -D\n\n# capacitor初始化\n\nnpx cap init\nnpx cap add android\n# 新建www目录存放网页\nmkdir www\n# 复制网页文件到安卓 一般用下面同步命令就可以了\nnpx cap copy android\n# 同步配置\nnpx cap sync\n</code></pre>\n<h2 id=\"33-签名配置\">3.3 签名配置</h2>\n<p>安卓正式打包需要进行签名，因此需要先生成签名文件, 在 <code>capacitor</code> 生成好的目录中，进入安卓目录</p>\n<pre><code class=\"language-shell\"># 在android目录下 执行该命令\nkeytool -genkey -v -keystore my-release-key.jks -keyalg RSA -keysize 2048 -validity 10000 -alias my-alias\n</code></pre>\n<p>生成好签名后会生成一个 <code>my-release-key.jks</code> 的文件</p>\n<p>打开 <code>app</code> 目录，编辑 <code>build.gradle</code> 文件</p>\n<pre><code class=\"language-groovy\">android {\n\n...\n\n    // 取消格式检查，避免打包错误\n    lintOptions {\n        checkReleaseBuilds false\n    }\n    // 签名配置\n    signingConfigs {\n        release {\n            storeFile file(&quot;../my-release-key.jks&quot;)\n            storePassword &quot;password&quot; # 这个密码需要填生成签名时的密码\n            keyAlias &quot;my-alias&quot;\n            keyPassword &quot;password&quot; # 这个密码需要填生成签名时的密码\n        }\n    }\n\n    buildTypes {\n        release {\n            signingConfig signingConfigs.release\n            ...\n        }\n    }\n\n...\n\n}\n</code></pre>\n<p>完成上述配置后，在 <code>android</code> 目录就可以执行打包了</p>\n<pre><code class=\"language-shell\">./gradlew assembleRelease\n</code></pre>\n<p>打包完成后会在./app/build/outputs/apk/release 文件夹下生成app-release.apk 文件</p>\n<h1 id=\"四-capacitor配置\">四. capacitor配置</h1>\n<h2 id=\"41-自定义启动图和logo\">4.1 自定义启动图和logo</h2>\n<p> 下载依赖包</p>\n<pre><code>yarn add cordova-res -D\n</code></pre>\n<p>打包目录下新建文件夹<code> resource/android</code></p>\n<p>配置四个文件, 普通使用时可以将<code>icon</code>,<code>icon-backgournd</code>,<code>icon-foreground</code>设置为一致即可</p>\n<pre><code>- icon.png // 图标 1024 * 1024\n- splash.png // 启动图 最小2732*2732\n- icon-background.png // 自适应图标 最小432*432\n- icon-foreground.png // 自适应图标 最小432*432\n</code></pre>\n<p>在 <code>package.json</code> 新增命令</p>\n<pre><code>&quot;icon&quot;: &quot;cordova-res android --skip-config --copy&quot;\n</code></pre>\n<p>执行命令即可生成和替换源码的图标</p>\n<pre><code>npm run icon\n</code></pre>\n<p>这里踩了很多坑，利用 <code>cordova-res</code> 工具可以将 图片裁成响应式的图片，适合不同的屏幕。但是我们的业务需求就决定了，最终产物是固定分辨率的安卓设备，因此这里可以不使用上面的插件，直接将文件复制到安卓的 res 中存放图标和启动图的目录即可，删除掉那些针对不同分辨率的目录，只保留一个即可.</p>\n<h2 id=\"42-app强制横屏\">4.2 APP强制横屏</h2>\n<p>配置<code>AndroidManifest.xml</code></p>\n<pre><code class=\"language-xml\">&lt;activity\n    android:screenOrientation=&quot;landscape&quot;\n</code></pre>\n<h2 id=\"43-修改包名\">4.3 修改包名</h2>\n<p>包名决定了手机安装应用的目录。如果手机安装了一个应用，再安装一个与它包名一致的应用时，会导致覆盖应用。</p>\n<p>如果报名一致，签名证书不一致，则安装失败。</p>\n<p>在<code>./android/app/build.gradle</code> 文件进行修改即可</p>\n<pre><code class=\"language-gradle\">android {\n    ...\n    defaultConfig {\n        applicationId &quot;com.test.app&quot;\n        ...\n    }\n    ...\n}\n</code></pre>\n<h2 id=\"44-强制全屏\">4.4 强制全屏</h2>\n<p>配置 <code>android/app/src/res/value/styles.xml</code></p>\n<pre><code class=\"language-xml\">&lt;style name=&quot;AppTheme.NoActionBar&quot; parent=&quot;Theme.AppCompat.NoActionBar&quot;&gt;\n    ...\n    &lt;item name=&quot;android:windowFullscreen&quot;&gt;true&lt;/item&gt;\n    ...\n&lt;/style&gt;\n</code></pre>\n<h2 id=\"45-修改应用名称\">4.5 修改应用名称</h2>\n<p>在<code>android/app/src/main/res/values/strings.xml</code>修改文件</p>\n<pre><code class=\"language-xml\">&lt;?xml version=&#39;1.0&#39; encoding=&#39;utf-8&#39;?&gt;\n&lt;resources&gt;\n     &lt;!-- 应用名称 --&gt;\n    &lt;string name=&quot;app_name&quot;&gt;xx&lt;/string&gt; \n    &lt;string name=&quot;title_activity_main&quot;&gt;xx&lt;/string&gt;\n    &lt;!-- 包名 --&gt;\n    &lt;string name=&quot;package_name&quot;&gt;cn.xx.xx&lt;/string&gt;\n     &lt;!-- 自定义协议 --&gt;\n    &lt;string name=&quot;custom_url_scheme&quot;&gt;cn.xx.xx&lt;/string&gt;\n&lt;/resources&gt;\n</code></pre>\n<h1 id=\"五-参考资料\">五. 参考资料</h1>\n<ol>\n<li><a href=\"https://developer.android.com/docs?hl=zh-cn\">https://developer.android.com/docs?hl=zh-cn</a></li>\n<li><a href=\"https://weread.qq.com/web/reader/73532150723f022f73516a6kc81322c012c81e728d9d180\">《第一行代码：Android》(第三版)</a></li>\n<li><a href=\"https://capacitorjs.com/\">https://capacitorjs.com/</a></li>\n</ol>\n",
        "title": "网页打包安卓应用，实现流程自动化",
        "created": "2022-06-18 13:04:22  ",
        "updated": "2022-06-18 13:04:22 ",
        "excerpt": "一. 业务背景 部门的业务主要是营销物料的生产，可以分发到不同终端。手机可以在H5，小程序展示，PC可以打包成 electron应用，但是目前在安卓应用上是空缺的。因此需要提供用户可以将制作的物料直接打包成安卓应用的能力。 二.技术选型 在...",
        "avatar": "https://avatars.githubusercontent.com/u/26271337?v=4",
        "id": "13"
    },
    "14": {
        "content": "<h1 id=\"一-写在前面\">一. 写在前面</h1>\n<p>作为前端开发，<code>Vue</code> 是我日常工作中使用最多的框架，各种特性我都有进行了解。但是对于框架底层的原理却知之甚少，知道数据劫持，但是不知道依赖收集的具体过程。知道 <code>diff</code> 算法，但对 <code>Vue</code> 所做的算法优化不了解。一入门就学习了 <code>Vue</code> 的生命周期，却不了解组件实例化的整个过程。</p>\n<p>总的来说就是似懂非懂，都知道一些，都不深入。因此学习源码，了解 <code>Vue</code> 的整体设计是我的主要目标。也希望通过 <code>Vue</code> 源码的学习能让我在工作中使用 <code>Vue</code> 更加的得心应手。</p>\n<h1 id=\"二-基本介绍\">二. 基本介绍</h1>\n<p><code>Vue</code> 的源码设计的东西太多了，我决定拆分成不同部分去阅读，带有目的去了解。</p>\n<ul>\n<li>源码地址： <a href=\"https://github.com/vuejs/vue\">https://github.com/vuejs/vue</a></li>\n<li>分支： main</li>\n<li>版本： v2.7.0</li>\n</ul>\n<p>这里选择了当前(2022-06)最新版本的代码，当前版本的代码已经全部使用 <code>TypeScript</code> 进行重写，舍弃了之前的 <code>flow</code> 标注，阅读体验还是比较好的。</p>\n<p><code>Vue</code> 的代码在 <code>src</code> 目录下，目录结构为</p>\n<pre><code>src\n├── compiler        # 编译相关 \n├── core            # 核心代码 \n├── platforms       # 多平台支持\n├── server          # 服务端\n├── types           # 类型声明\n├── shared          # 共享工具方法\n├── v3              # v3的特性\n</code></pre>\n<p>看源码的顺序一般从入口文件开始，<code>Vue</code> 作为库，入口文件是它的构建产物，因此我们从打包命令中入手。</p>\n<pre><code class=\"language-shell\">&quot;build&quot;: &quot;node scripts/build.js&quot;,\n</code></pre>\n<p>于是找到 <code>scripts/build.js</code> 文件，然后找到配置文件 <code>scripts/config.js</code></p>\n<pre><code class=\"language-js\">const builds = {\n    // Runtime only (CommonJS). Used by bundlers e.g. Webpack &amp; Browserify\n    &#39;runtime-cjs-dev&#39;: {\n        entry: resolve(&#39;web/entry-runtime.ts&#39;),\n        dest: resolve(&#39;dist/vue.runtime.common.dev.js&#39;),\n        format: &#39;cjs&#39;,\n        env: &#39;development&#39;,\n        banner\n    },\n    &#39;runtime-cjs-prod&#39;: {\n        entry: resolve(&#39;web/entry-runtime.ts&#39;),\n        dest: resolve(&#39;dist/vue.runtime.common.prod.js&#39;),\n        format: &#39;cjs&#39;,\n        env: &#39;production&#39;,\n        ...\n</code></pre>\n<p>从上面的配置中，我们可以看到 <code>Vue</code> 在打包是构建成不同的版本，有支持 <code>CommonJS</code> 规范 <code>cjs</code>,\n也有支持 <code>ESM</code> 的 <code>esm</code>, 也有兼容多格式的 <code>UMD</code>。其中有带 <code>complier</code> 的版本，也有 <code>runtime-only</code> 的版本。</p>\n<h1 id=\"三-入口文件\">三. 入口文件</h1>\n<p>从配置文件中有找到 别名的声明文件 <code>scripts/alias </code></p>\n<pre><code class=\"language-js\">{\n    vue: resolve(&#39;src/platforms/web/entry-runtime-with-compiler&#39;),\n}\n</code></pre>\n<p>也有很多的构建版本以该文件作为入口文件，因此从 <code>src/platforms/web/entry-runtime-with-compiler.ts</code>开始入手。</p>\n<pre><code class=\"language-ts\">import Vue from &#39;./runtime-with-compiler&#39;\nimport * as vca from &#39;v3&#39;\nimport { extend } from &#39;shared/util&#39;\nextend(Vue, vca)\nimport { effect } from &#39;v3/reactivity/effect&#39;\nVue.effect = effect\n\nexport default Vue\n</code></pre>\n<p>忽略新增的 <code>v3</code> 的功能代码，进入 <code>./runtime-with-compiler</code>文件</p>\n<pre><code class=\"language-ts\">const mount = Vue.prototype.$mount\nVue.prototype.$mount = function () {\n    const { render, staticRenderFns } = compileToFunctions(...)\n    options.render = render\n    options.staticRenderFns = staticRenderFns\n}\n</code></pre>\n<p>这个文件的代码很多，但是核心逻辑就是引入了 <code>compileToFunctions</code> 方法, 扩展了 <code>$mount</code> 方法，支持将 <code>options</code> 的 <code>template</code> 转化为 <code>render</code> 函数。根据导入一直寻找，我们最终来到了<code>src/core/index.ts</code></p>\n<pre><code class=\"language-ts\">import Vue from &#39;./instance/index&#39;\ninitGlobalAPI(Vue) // 初始化全局Api\n</code></pre>\n<p>然后在 <code>instance/index</code>文件</p>\n<pre><code class=\"language-ts\">function Vue(options) {\n    if (__DEV__ &amp;&amp; !(this instanceof Vue)) {\n        warn(&#39;Vue is a constructor and should be called with the `new` keyword&#39;)\n    }\n    this._init(options)\n}\ninitMixin(Vue)\nstateMixin(Vue)\neventsMixin(Vue)\nlifecycleMixin(Vue)\nrenderMixin(Vue)\n</code></pre>\n<p>在这里我们知道，<code>Vue</code> 就是一个构造函数，只能通过 <code>new Vue</code> 进行实例化，然后通过不同函数对 <code>prototype</code> 进行扩展实现功能模块化，</p>\n<h1 id=\"四-总结\">四. 总结</h1>\n<p>Vue 的整体逻辑过于庞大，涉及到组件化, 响应式原理，编译等诸多逻辑。因此我会从不同的部分去阅读和解析源码。</p>\n<p>文章链接：TODO</p>\n",
        "title": "Vue 源码学习 (1) - 起始篇",
        "created": "2022-06-26 11:28:17  ",
        "updated": "2022-06-26 11:28:17 ",
        "excerpt": "一. 写在前面 作为前端开发，Vue 是我日常工作中使用最多的框架，各种特性我都有进行了解。但是对于框架底层的原理却知之甚少，知道数据劫持，但是不知道依赖收集的具体过程。知道 diff 算法，但对 Vue 所做的算法优化不了解。一入门就学习...",
        "avatar": "https://avatars.githubusercontent.com/u/26271337?v=4",
        "id": "14"
    },
    "15": {
        "content": "<h1 id=\"_init\">_init</h1>\n<p>当我们使用 <code>Vue 2</code> 时，我们会用 <code>Vue</code> 实例化一个应用</p>\n<pre><code class=\"language-ts\">const app = new Vue({\n    render: h =&gt; h(App)\n}).$mount(&#39;#app&#39;)\n</code></pre>\n<p> <code>Vue</code>  是一个构造函数，实例化时会调用 <code>this._init(options)</code> 方法.</p>\n<pre><code class=\"language-ts\">function Vue(options) {\n    this._init(options)\n}\n</code></pre>\n<p>找到 <code>core/instance/init.ts</code>文件中，<code>initMixin</code>函数执行时挂载了 <code>_init</code>方法</p>\n<pre><code class=\"language-ts\">Vue.prototype._init = function (options?: Record&lt;string, any&gt;) {\nconst vm: Component = this\n    // a uid\n    vm._uid = uid++\n    if (options &amp;&amp; options._isComponent) {\n        initInternalComponent(vm, options as any)\n    } else {\n        vm.$options = mergeOptions(\n        resolveConstructorOptions(vm.constructor as any),\n        options || {},\n        vm\n        )\n    }\n    initLifecycle(vm)\n    initEvents(vm)\n    initRender(vm)\n    callHook(vm, &#39;beforeCreate&#39;)\n    initInjections(vm) \n    initState(vm)\n    initProvide(vm) \n    callHook(vm, &#39;created&#39;)\n\n    if (vm.$options.el) {\n        vm.$mount(vm.$options.el)\n    }\n}\n</code></pre>\n<p>这里的逻辑我大致讲一下，</p>\n<ol>\n<li><code>uid</code> 递增</li>\n<li>往实例上加一些属性标识</li>\n<li><code>$options</code> 初始化，合并 <code>extend</code>, <code>mixin</code> 等</li>\n<li>初始化声明周期，初始化 <code>render</code></li>\n<li><code>beforeCreate</code></li>\n<li>初始化 <code>inject</code></li>\n<li>初始化 <code>props</code> -&gt; <code>methods</code> -&gt; <code>data</code> -&gt; <code>computed</code> -&gt; <code>watch</code></li>\n<li>初始化 <code>provide</code></li>\n<li><code>created</code></li>\n<li>开始 <code>$mount</code></li>\n</ol>\n<h1 id=\"mount\">$mount</h1>\n<p>上面的流程大致过下，接下来我们看看 <code>$mount</code> 执行的过程。</p>\n<p>在 <code>web/runtime-with-compiler.ts</code>中我们讲过，这里将 <code>compileToFunctions</code> 函数引入进来，用于讲 <code>template</code> 转化成 <code>render</code> 函数，这里我们也讲一下详细的逻辑</p>\n<pre><code class=\"language-ts\">// 不能挂在到 html 或者 body 下\nif (el === document.body || el === document.documentElement)\n    return \nif (!options.render) {\n    // 如果template存在\n        // 字符串 \n            // 直接解析\n            // 通过id 获取元素，然后获取innerHTML\n        // 元素 获取 innerHTML\n    // 如果templet 不存在 ，el 存在 获取 outerHTML\n    \n    // 执行compileToFunctions 得到render\n    \n    // 执行缓存的原方法\n    return mount.call(this, el, hydrating)\n}\n</code></pre>\n<p>来到 <code>web/runtime/index.ts</code>， 这里就是 <code>runtime</code> 时<code> $mount</code> 方法</p>\n<pre><code class=\"language-ts\">Vue.prototype.$mount = function (\n    el?: string | Element,\n    hydrating?: boolean\n\n    ): Component {\n    el = el &amp;&amp; inBrowser ? query(el) : undefined\n    return mountComponent(this, el, hydrating)\n}\n</code></pre>\n<p>这里调用了 <code>core/instance/lifecycle</code>的 <code>mountComponent</code> 方法</p>\n<pre><code class=\"language-ts\">export function mountComponent(\nvm: Component,\nel: Element | null | undefined,\nhydrating?: boolean\n): Component {\n    // 声明 $el，检查render\n    vm.$el = el\n    if (!vm.$options.render) {\n        vm.$options.render = createEmptyVNode\n    }\n    \n    callHook(vm, &#39;beforeMount&#39;)\n    \n    let updateComponent = () =&gt; {\n        vm._update(vm._render(), hydrating)\n    }\n    const watcherOptions: WatcherOptions = {\n        before() {\n            if (vm._isMounted &amp;&amp; !vm._isDestroyed) {\n                callHook(vm, &#39;beforeUpdate&#39;)\n            }\n        }\n    }\n\n    new Watcher(\n        vm,\n        updateComponent,\n        noop,\n        watcherOptions,\n        true /* isRenderWatcher */\n    )\n    if (vm.$vnode == null) {\n        const preWatchers = vm._preWatchers\n        if (preWatchers) {\n            for (let i = 0; i &lt; preWatchers.length; i++) {\n                preWatchers[i].run()\n            }\n        }\n        vm._isMounted = true\n        callHook(vm, &#39;mounted&#39;)\n    }\n\n    return vm\n\n}\n</code></pre>\n<p>这里实例化了一个 渲染的 <code>Watcher</code>, 在它的回调中会调用 <code>updateComponent</code> 方法，执行 <code>_render</code>，<code>_update</code> 更新 <code>DOM</code></p>\n<p>这里还有一个判断 <code>vm.$node === null</code>, 这里 <code>$node</code> 表示父 <code>vnode</code>，为 <code>null</code> 则表示为根结点的实例.</p>\n<p>Watcher 我们先不看，这主要是响应式原理和依赖收集相关的部分，我们继续看 <code>_render</code> , <code>_update</code> 方法的逻辑.</p>\n<h1 id=\"_render\">_render</h1>\n<p>在 <code>instance/render.ts</code>中，<code>renderMixin</code> 函数注册了 <code>_render</code> 方法.</p>\n<pre><code class=\"language-ts\">Vue.prototype._render = function (): VNode {\n    const vm: Component = this\n    const { render, _parentVnode } = vm.$options\n\n    vm.$vnode = _parentVnode!\n    let vnode = render.call(vm._renderProxy, vm.$createElement)\n    \n    // set parent\n    vnode.parent = _parentVnode\n    return vnode\n}\n</code></pre>\n<p><code>_render</code> 函数调用 <code>render</code> 生成 <code>vnode</code> 进行返回</p>\n<p>平时我们使用 <code>render</code> 函数时是这么写的：</p>\n<pre><code class=\"language-js\">render: h =&gt; h(&#39;div&#39;, {}, &#39;&#39;)\n</code></pre>\n<p>这里的 <code>h</code> 就对应了 <code>vm.$reateElement</code>, 而 <code>renderProxy</code> 就是响应式的数据</p>\n<p>其中 <code>vm.$createElement</code> 在 <code>initRender</code> 时进行了注册，实际上也是对 <code>createElement</code> 方法进行了封装。</p>\n<h1 id=\"createelement\">createElement</h1>\n<p>在 <code>core/vdom/create-element.ts</code>中定义了 <code>createElement</code> 函数，该函数是对 <code>_createElement</code> 的封装，让参数更加灵活</p>\n<pre><code class=\"language-ts\">export function _createElement(\n    context: Component,\n    tag?: string | Component | Function | Object,\n    data?: VNodeData,\n    children?: any,\n    normalizationType?: number\n): VNode | Array&lt;VNode&gt; {\n\n    // 处理 :is\n    if (isDef(data) &amp;&amp; isDef(data.is)) {\n        tag = data.is\n    }\n\n    if (normalizationType === ALWAYS_NORMALIZE) {\n        children = normalizeChildren(children)\n    } else if (normalizationType === SIMPLE_NORMALIZE) {\n        children = simpleNormalizeChildren(children)\n    }\n\n    let vnode, ns\n    if (typeof tag === &#39;string&#39;) {\n        let Ctor\n        if (config.isReservedTag(tag)) {\n            vnode = new VNode(\n                config.parsePlatformTagName(tag),\n                data,\n                children,\n                undefined,\n                undefined,\n                context\n            )\n\n        } else if (...) {\n            vnode = createComponent(Ctor, data, context, children, tag)\n        } else {\n            vnode = new VNode(tag, data, children, undefined, undefined, context)\n\n        }\n    } else {\n        // direct component options / constructor\n        vnode = createComponent(tag as any, data, context, children)\n    }\n\n    return vnode\n}\n</code></pre>\n<p>这里主要执行的逻辑是，先将 <code>children</code> 规范为 <code>VNode</code> 数组，<code>normalizationType</code> 标识规范类型。</p>\n<p>然后创建 <code>VNode</code>, 对 <code>tag</code> 进行判断,</p>\n<ul>\n<li>. 如果是 <code>tag</code> 是 <code>string</code> 类型<ul>\n<li>. 内置 <code>HTML</code> 元素的话，直接创建普通 <code>node</code></li>\n<li>. 已经注册过的组件名，则使用 <code>createComponent</code> 创建组件 <code>VNode</code></li>\n<li>. 创建未知标签的 <code>vnode</code></li>\n</ul>\n</li>\n<li>. 如果是 <code>component</code> 类型，直接创建 <code>component</code> 组件 <code>VNode</code></li>\n</ul>\n<p>到这里我们大致讲完了 <code>createElement</code> 的逻辑了。</p>\n<h1 id=\"update\">update</h1>\n<p>在 <code>mountComponent</code>方法中，<code>_render</code>执行完成后，会执行<code>_update</code> 方法</p>\n<pre><code class=\"language-ts\">vm._update(vm._render(), hydrating)\n</code></pre>\n<p>查看 <code>_update</code> 方法</p>\n<pre><code class=\"language-ts\">Vue.prototype._update = function (vnode: VNode, hydrating?: boolean) {\n    const vm: Component = this\n    const prevEl = vm.$el\n    const prevVnode = vm._vnode\n    const restoreActiveInstance = setActiveInstance(vm)\n    vm._vnode = vnode\n\n\n    if (!prevVnode) {\n        // initial render\n        vm.$el = vm.__patch__(vm.$el, vnode, hydrating, false)\n    } else {\n        vm.$el = vm.__patch__(prevVnode, vnode)\n    }\n\n    restoreActiveInstance()\n\n    // update __vue__ reference\n    if (prevEl) {\n    prevEl.__vue__ = null\n    }\n    if (vm.$el) {\n    vm.$el.__vue__ = vm\n    }\n\n    // if parent is an HOC, update its $el as well\n    if (vm.$vnode &amp;&amp; vm.$parent &amp;&amp; vm.$vnode === vm.$parent._vnode) {\n        vm.$parent.$el = vm.$el\n    }\n\n}\n</code></pre>\n<p>这里的核心逻辑是 <code>__patch__</code> 方法. 由于 <code>Vue</code> 不只面向 <code>web</code> 平台， 也会处理其他平台的逻辑，例如<strong>死去的</strong> <code>Weex</code>. 而且在 <code>Vue SSR</code> 时，也是不需要 <code>patch的</code>。这里我们看 <code>web</code> <code>端的patch</code> 方法。</p>\n<pre><code class=\"language-ts\">\nfunction createPatchFunction({ nodeOps, modules }) {\n    return function patch(oldVnode, vnode, hydrating, removeOnly) {\n\n    let isInitialPatch = false\n    const insertedVnodeQueue: any[] = []\n\n    if (isUndef(oldVnode)) {\n        isInitialPatch = true\n        createElm(vnode, insertedVnodeQueue)\n    } else {\n        const isRealElement = isDef(oldVnode.nodeType)\n        oldVnode = emptyNodeAt(oldVnode)\n        // replacing existing element\n        const oldElm = oldVnode.elm\n        const parentElm = nodeOps.parentNode(oldElm)\n        // create new node\n        createElm(\n            vnode,\n            insertedVnodeQueue,\n            oldElm._leaveCb ? null : parentElm,\n            nodeOps.nextSibling(oldElm)\n        )\n\n        // update parent placeholder node element, recursively\n        if (isDef(vnode.parent)) {\n            let ancestor = vnode.parent\n            const patchable = isPatchable(vnode)\n            while (ancestor) {\n                for (let i = 0; i &lt; cbs.destroy.length; ++i) {\n                    cbs.destroy[i](ancestor)\n                }\n                ancestor.elm = vnode.elm\n\n                if (patchable) {\n                    for (let i = 0; i &lt; cbs.create.length; ++i) {\n                        cbs.create[i](emptyNode, ancestor)\n                    }\n\n                    const insert = ancestor.data.hook.insert\n                    if (insert.merged) {\n                        for (let i = 1; i &lt; insert.fns.length; i++) {\n                            insert.fns[i]()\n                        }\n                    }\n                } else {\n                    registerRef(ancestor)\n                }\n            ancestor = ancestor.parent\n            }\n        }\n\n        if (isDef(parentElm)) {\n            removeVnodes([oldVnode], 0, 0)\n        } else if (isDef(oldVnode.tag)) {\n            invokeDestroyHook(oldVnode)\n        }\n\n        invokeInsertHook(vnode, insertedVnodeQueue, isInitialPatch)\n        return vnode.elm\n    }\n}\n</code></pre>\n<p>这里主要通过 <code>cretateElem</code> 创建元素</p>\n<pre><code class=\"language-ts\">if (isDef(vnode.elm) &amp;&amp; isDef(ownerArray)) {\n    vnode = ownerArray[index] = cloneVNode(vnode)\n}\n\nconst data = vnode.data\nconst children = vnode.children\nconst tag = vnode.tag\nif (isDef(tag)) {\n    vnode.elm = vnode.ns\n    ? nodeOps.createElementNS(vnode.ns, tag)\n    : nodeOps.createElement(tag, vnode)\n    \n    setScope(vnode)\n    createChildren(vnode, children, insertedVnodeQueue)\n    if (isDef(data)) {\n        invokeCreateHooks(vnode, insertedVnodeQueue)\n    }\n    insert(parentElm, vnode.elm, refElm)\n\n} else if (isTrue(vnode.isComment)) {\n    vnode.elm = nodeOps.createComment(vnode.text)\n    insert(parentElm, vnode.elm, refElm)\n} else {\n    vnode.elm = nodeOps.createTextNode(vnode.text)\n    insert(parentElm, vnode.elm, refElm)\n\n}\n</code></pre>\n<p>这里的逻辑就是通过 <code>VNode</code> 创建正式的 <code>DOM</code> 然后插入到它的父节点中。</p>\n<p>这里先创建 <code>elm</code> 元素，然后创建 <code>children</code>，遍历子节点，递归调用 <code>createElm</code>, 然后调用 <code>invokeCreateHook</code>。</p>\n<p>最后调用 <code>insert</code> 方法插入到 父节点，所以插入节点的顺序是 子&gt;父 的。</p>\n<h1 id=\"总结\">总结</h1>\n<p>最后回顾下整个 Vue 初始化的流程：</p>\n<ol>\n<li><code>init</code> 初始化声明周期，数据</li>\n<li><code>$mount</code> 开始挂载</li>\n<li><code>compile  template to render fn</code></li>\n<li><code>render</code> 生成 <code>VNode</code></li>\n<li><code>patch VNode</code>  到 <code>DOM</code> 上</li>\n</ol>\n<p>从 <code>patch</code> 的过程我们也知道了从 虚拟节点 到 DOM 的一个生成逻辑，所以有一个常见的面试题，就是父子组件的生命周期问题，这个问题的答案现在就很简单了</p>\n<pre><code>父亲：F  子组件： C\n\nF beforeCreate -&gt; created -&gt; beforeMount -&gt; C beforeCreate -&gt; created -&gt; beforeMount -&gt; Mounted -&gt; F Mounted\n</code></pre>\n<p>上面我们大致讲了下 <code>patch</code> 的过程，很多关于 新旧节点的比较逻辑，diff 算法优化并没有细聊。后续会有文章, 我们接着聊。</p>\n",
        "title": "Vue 源码学习 (2) - Vue 初始化",
        "created": "2022-06-26 11:36:24  ",
        "updated": "2022-07-03 16:39:06 ",
        "excerpt": "_init 当我们使用 Vue 2 时，我们会用 Vue 实例化一个应用 `ts const app = new Vue({ render: h => h(App) }).$mount('#app') ` Vue 是一个构造函数，实例化时会...",
        "avatar": "https://avatars.githubusercontent.com/u/26271337?v=4",
        "id": "15"
    },
    "16": {
        "content": "<h1 id=\"一-业务背景\">一. 业务背景</h1>\n<p>部门官网和主应用是一个 <code>SPA</code> 的服务。由于业务扩展，希望能够被搜索引擎收录到，所以官网需要做 <code>SEO</code>。</p>\n<h1 id=\"二-技术选型\">二. 技术选型</h1>\n<p>由于直接在原主应用上做 <code>SSR</code>，改动成本太大，决定直接使用现成的 <code>SSR</code> 框架。</p>\n<p><code>Next.js</code> 与 <code>Nuxt</code> 都是前端比较流行的 <code>SSR</code> 框架，且都支持 <code>SSG</code>.。加上旧代码是 <code>Vue</code> 写的，直接迁移到 <code>Nuxt</code> 是比较方便的，因此最终选择了 <code>Nuxt</code>.</p>\n<p><code>SSR</code> 和 <code>SSG</code> 都能够起到 <code>SEO</code>  的作用，但是 <code>SSR</code> 需要在服务器特意启动 <code>node</code> 服务，而 <code>SSG</code> 只需要部署在 nginx 代理的目录下即可。</p>\n<p>因此最终选型： <code>Nuxt</code> + <code>SSG</code></p>\n<h1 id=\"三-开发过程\">三. 开发过程</h1>\n<h2 id=\"31-路由和布局\">3.1 路由和布局</h2>\n<p><code>Nuxt</code> 框架使用约定式路由，即 <code>pages</code> 文件夹下的 <code>Vue</code> 组件直接成为路由。</p>\n<pre><code class=\"language-shell\">- pages\n    # /\n    - index.vue \n    - foo\n        # /foo/bar\n        - bar.vue \n</code></pre>\n<p>以下划线开头的文件，成为<strong>动态路由</strong></p>\n<pre><code class=\"language-shell\"># news/:post\n- news\n    - _post.vue\n</code></pre>\n<p>布局文件在 <code>layouts</code> 文件下, 包裹 <code>Nuxt</code> 组件即可</p>\n<pre><code class=\"language-tsx\">// default.vue\n&lt;div&gt;\n    ...\n        &lt;Nuxt&gt;\n    ...\n&lt;/div&gt;\n</code></pre>\n<p>知道这些基本的配置，将旧代码迁移过来，一般就能直接用了</p>\n<h2 id=\"32-插件\">3.2 插件</h2>\n<p>当我们需要引入第三方库时，并没有向 <code>Vue</code> 中那样有个入口文件可以使用。我们需要在 <code>plugins</code> 文件夹下写插件。例如部分引入 <code>element-ui</code></p>\n<pre><code class=\"language-ts\">// plugins/element.js\nimport Vue from &#39;vue&#39;\n\nconst components = [...]\n                    \nconst Element = {\n    install(Vue) {\n        components.forEach(c =&gt; Vue.component(c.name, c))\n    }\n}\nVue.use(Element)\n</code></pre>\n<p>然后在 <code>nuxt.config.js</code> 进行引入</p>\n<pre><code>plugins: [\n    &#39;./plugins/element.js&#39;\n]\n</code></pre>\n<p>如果我们要对 <code>axios</code> 做扩展，也可以写一个插件 </p>\n<pre><code class=\"language-ts\">import host from &#39;../env&#39;\nexport default function({$axios,},) {\n    $axios.setBaseURL(`${host}/...`)\n    $axios.onResponse(res =&gt; {\n        ...\n    })\n}\n</code></pre>\n<p>当然 <code>Nuxt</code> 提供的插件能力强大， 我们可以通过插件往实例中添加属性</p>\n<pre><code class=\"language-ts\">export default function({}, inject) {\n    inject(...)\n}\n</code></pre>\n<h2 id=\"33-页面文件\">3.3 页面文件</h2>\n<h3 id=\"331-asyncdata\">3.3.1 asyncData</h3>\n<p>和普通的 <code>Vue</code> 开发不同，<code>Nuxt</code> 中 <code>Vue</code> 组件获取数据需要用特定的方法 <code>asyncData</code>, 方便客户端和服务端都能使用</p>\n<pre><code class=\"language-ts\">async asyncData({params , $axios}) {\n    const { id } = params\n    const data = await $axios.get(`...`)\n    return {\n        data\n    }\n}\n</code></pre>\n<p><code>asyncData</code> 返回的数据，可以通过实例获取，例如 <code>this.data</code>。</p>\n<p><code>Nuxt</code> 同时也提供 <code>fetch</code> 函数用来获取数据。</p>\n<h3 id=\"332-processbrowser\">3.3.2 process.browser</h3>\n<p>在组件中，如果有些方法需要放到 <code>created</code> 周期去做的，需要注意判断下环境，支持目标环境支持的操作</p>\n<pre><code class=\"language-ts\">if(process.browser) {\n    ...\n}\n</code></pre>\n<h3 id=\"333-head\">3.3.3 head</h3>\n<p>如果当前页面需要额外的 <code>meta</code> 信息，可以通过 <code>head</code> 函数进行定义</p>\n<pre><code class=\"language-ts\">head() {\n    return {\n        meta: [\n            {\n                hid: &#39;keywords&#39;,\n                name: &#39;keywords&#39;,\n                content: &#39;...&#39;\n            }\n        ]\n    }\n\n}\n</code></pre>\n<h1 id=\"四-nuxtconfigjs\">四. nuxt.config.js</h1>\n<p><code>nuxt.config.js</code> 是 <code>Nuxt</code> 应用的配置文件,现在初略讲一下重要的字段。</p>\n<ol>\n<li><strong>target</strong><br>构建的目标 <code>server</code> / <code>static</code> </li>\n<li><strong>head</strong>\n定义 <code>head</code> 标签中信息,支持定义 <code>meta</code>, <code>link</code>, <code>script</code> 等</li>\n<li><strong>css</strong>\n全局 CSS 定义</li>\n<li><strong>components</strong>\n组件自动导入功能开启，不需要写引入语句</li>\n<li><strong>env</strong>\n环境变量</li>\n<li>** router **\n路由配置<pre><code class=\"language-ts\">router: {\n base: &#39;&#39;,\n extendRoutes() {}// 扩展路由\n}\n</code></pre>\n这里需要注意下，<code>SSG</code> 的页面存在路由问题。如果某个路由页面刷新，会找不到地址，这里需要对路由处理下。\n```ts\nrouter: {\n extendRoutes(routes,) {\n routes.forEach(route =&gt; {\n     const alias  = route.path.length &gt; 1 <code>${route.path}/index.html</code>: &#39;/index.html&#39;\n     route.alias = alias\n \n })\n }</li>\n</ol>\n<p>}</p>\n<pre><code>\n\n7. **build**\n`webpack` 的处理, 增加规则，引入插件等\n```js\nbuild: {\n    extend(config) {\n        config.module.rules...\n        return config\n    },\n    babel: {\n        plugins: [...]\n    }\n\n}\n</code></pre>\n<ol start=\"8\">\n<li><strong>generate</strong>\n配置 <code>SSG</code> 的逻辑,例如我这里请求接口生成路由\n```js\ngenerate: {\n routes() {\n axios.get(&#39;...&#39;).then(res =&gt; {\n     return res.data.map(r =&gt; ({\n         route: <code>/news/${r.id}</code>\n     }))\n \n })\n }</li>\n</ol>\n<p>}</p>\n<p>```\n这里声明了路由文件的数量，构建时会调用对应组件的 <code>asyncData</code> 方法传入参数，然后生成静态文件</p>\n<h1 id=\"五-总结\">五. 总结</h1>\n<p>总的来说 <code>Nuxt</code> 的开发体验还是比较好的，毕竟是框架上面的框架，各种插件和模块都比较齐全。能够快速实现 <code>SSR</code> 和 <code>SSG</code>, 就算普通开发 <code>SPA</code> 的体验也是比较好的。</p>\n",
        "title": "SEO需求，Nuxt SSG练手",
        "created": "2022-06-27 16:33:15  ",
        "updated": "2022-06-27 16:33:15 ",
        "excerpt": "一. 业务背景 部门官网和主应用是一个 SPA 的服务。由于业务扩展，希望能够被搜索引擎收录到，所以官网需要做 SEO。 二. 技术选型 由于直接在原主应用上做 SSR，改动成本太大，决定直接使用现成的 SSR 框架。 Next.js 与 ...",
        "avatar": "https://avatars.githubusercontent.com/u/26271337?v=4",
        "id": "16"
    },
    "17": {
        "content": "<h1 id=\"一-createcomponent\">一. createComponent</h1>\n<p>Vue 开发就是开发组件，现在我们来看看组件形成 VNode 的逻辑。</p>\n<p>在 <code>_createElement</code> 方法中, 在两种场景会调用 createComponent 方法</p>\n<pre><code class=\"language-ts\">// tag 是已经声明过的 components 时\nvnode = createComponent(Ctor, data, context, children, tag)\n// tag 不为字符串时\nvnode = createComponent(tag as any, data, context, children)\n</code></pre>\n<p>初始化时我们传入的值都为 options 对象，对应的实现为</p>\n<pre><code class=\"language-ts\">export function createComponent(\nCtor: typeof Component | Function | ComponentOptions | void,\ndata: VNodeData | undefined,\ncontext: Component,\nchildren?: Array&lt;VNode&gt;,\ntag?: string\n): VNode | Array&lt;VNode&gt; | void {\n    // baseCtor 就是 Vue\n    const baseCtor = context.$options._base\n    // 将当前的 Ctor 传入 Vue.extend 得到新的 Ctor\n    if (isObject(Ctor)) {\n        Ctor = baseCtor.extend(Ctor as typeof Component)\n    }\n\n    data = data || {}\n    resolveConstructorOptions(Ctor as typeof Component)\n    \n    const propsData = extractPropsFromVNodeData(data, Ctor, tag)\n    const listeners = data.on\n    data.on = data.nativeOn\n\n    installComponentHooks(data)\n\n    const name = Ctor.options.name || tag\n    const vnode = new VNode(\n        `vue-component-${Ctor.cid}${name ? `-${name}` : &#39;&#39;}`,\n        data,\n        undefined,\n        undefined,\n        undefined,\n        context,\n        { Ctor, propsData, listeners, tag, children },\n        asyncFactory\n    )\n    return vnode\n}\n</code></pre>\n<p>这里先将传入的 Ctor 通过 Vue.extend 进行扩展</p>\n<pre><code class=\"language-ts\">Vue.extend = function (extendOptions: any): typeof Component {\n    extendOptions = extendOptions || {}\n    const Super = this\n    const SuperId = Super.cid\n    const cachedCtors = extendOptions._Ctor || (extendOptions._Ctor = {})\n\n    if (cachedCtors[SuperId]) {\n        return cachedCtors[SuperId]\n    }\n\n    const name = extendOptions.name || Super.options.name\n    const Sub = function VueComponent(this: any, options: any) {\n\n        this._init(options)\n\n    } as unknown as typeof Component\n    \n    // 通过原型进行继承\n    // Sub.prototype.__proto__ = Suer.prototype\n    Sub.prototype = Object.create(Super.prototype)\n    Sub.prototype.constructor = Sub\n    \n    Sub.cid = cid++\n    Sub.options = mergeOptions(Super.options, extendOptions)\n    Sub[&#39;super&#39;] = Super\n\n    if (Sub.options.props) {\n        initProps(Sub)\n    }\n\n    if (Sub.options.computed) {\n        initComputed(Sub)\n    }\n\n    Sub.extend = Super.extend\n    Sub.mixin = Super.mixin\n    Sub.use = Super.use\n\n\n    ASSET_TYPES.forEach(function (type) {\n        Sub[type] = Super[type]\n    })\n\n    // enable recursive self-lookup\n    if (name) {\n        Sub.options.components[name] = Sub\n    }\n  \n    Sub.superOptions = Super.options\n    Sub.extendOptions = extendOptions\n    Sub.sealedOptions = extend({}, Sub.options)\n    // cache constructor\n    cachedCtors[SuperId] = Sub\n    return Sub\n}\n</code></pre>\n<p>Vue.extend 函数允许我们讲 options 转化为构造函数，平时开发时也会进行使用。</p>\n<p>这里 Vue.extend 创建了 Vue 的子类，并对子类进行缓存。</p>\n<p>在 create-component 方法中 还有个 <code>installComponentHooks</code> 方法，我们看看它的逻辑</p>\n<pre><code class=\"language-ts\">const hooksToMerge = Object.keys(componentVNodeHooks)\n\nfunction installComponentHooks(data: VNodeData) {\n    const hooks = data.hook || (data.hook = {})\n    for (let i = 0; i &lt; hooksToMerge.length; i++) {\n        const key = hooksToMerge[i]\n        const existing = hooks[key]\n        const toMerge = componentVNodeHooks[key]\n        if (existing !== toMerge &amp;&amp; !(existing &amp;&amp; existing._merged)) {\n            hooks[key] = existing ? mergeHook(toMerge, existing) : toMerge\n\n        }\n    }\n}\n</code></pre>\n<p>这里主要是合并自身的 hook 和组件自带的 hook ,组件自带的hook有这些</p>\n<pre><code class=\"language-ts\">const componentVNodeHooks = {\n    init(){}, // 处理keep-alive逻辑 和 挂载子组件\n    prepatch(){}, // 更新子组件\n    insert(){}, // mounted事件， 处理keep-alive activate相关\n    destroy(){}, // 组件销毁\n}\n</code></pre>\n<p>在 patch 方法中会先对 vnode 进行一个判断，如果返回为 true 就不执行下方的插入逻辑了</p>\n<pre><code class=\"language-ts\">if (createComponent(vnode, insertedVnodeQueue, parentElm, refElm)) {\nreturn\n}\n</code></pre>\n<p>所以来看看这个 patch 内部定义的 createComponent 方法</p>\n<pre><code class=\"language-ts\">function createComponent(vnode, insertedVnodeQueue, parentElm, refElm) {\n    let i = vnode.data\n    if (isDef(i)) {\n        if (isDef((i = i.hook)) &amp;&amp; isDef((i = i.init))) {\n            i(vnode, false /* hydrating */)\n        }\n        if (isDef(vnode.componentInstance)) {\n            initComponent(vnode, insertedVnodeQueue)\n            insert(parentElm, vnode.elm, refElm)\n            return true\n        }\n    }\n}\n</code></pre>\n<p>这里判断 如果 vnode 有data的话，代表它是一个组件。然后执行 componentVNodeHooks 中定义的 init 方法</p>\n<pre><code class=\"language-ts\">...\nvnode.componentInstance = createComponentInstanceForVnode(\nvnode,\nactiveInstance\n))\n...\n\n// createComponentInstanceForVnode\nconst options: InternalComponentOptions = {\n_isComponent: true,\n_parentVnode: vnode,\nparent\n}\n\nreturn new vnode.componentOptions.Ctor(options)\n</code></pre>\n<p>这个方法中 执行 createComponent方法， 将 options 的 _isComponent 设为 true。 然后实例化构造函数，执行 _init方法,\n走了  initInternalComponent 函数的逻辑</p>\n<pre><code class=\"language-ts\">if (options &amp;&amp; options._isComponent) {\n    initInternalComponent(vm, options as any)\n}\n</code></pre>\n<p>这个函数就是为了实例内部子组件初始化使用的，优化合并配置的体验</p>\n<pre><code class=\"language-ts\">export function initInternalComponent(\nvm: Component,\noptions: InternalComponentOptions\n) {\n    // 直接获取 构造函数的 options\n    const opts = (vm.$options = Object.create((vm.constructor as any).options))\n    \n    const parentVnode = options._parentVnode\n    opts.parent = options.parent // 父组件实例\n    opts._parentVnode = parentVnode // 父Vnode\n\n\n    const vnodeComponentOptions = parentVnode.componentOptions!\n    opts.propsData = vnodeComponentOptions.propsData\n    opts._parentListeners = vnodeComponentOptions.listeners\n    opts._renderChildren = vnodeComponentOptions.children\n    opts._componentTag = vnodeComponentOptions.tag\n    if (options.render) {\n        opts.render = options.render\n        opts.staticRenderFns = options.staticRenderFns\n    }\n\n}\n</code></pre>\n<p>回到组件 init hook,这里组件会进行手动挂载</p>\n<pre><code class=\"language-ts\">child.$mount(hydrating ? vnode.elm : undefined, hydrating)\n\n// 在客户端\nchild.$mount( undefined, false)\n</code></pre>\n<p>在render 时</p>\n<pre><code class=\"language-ts\">Vue.prototype._render = function (): VNode {\n    const { render, _parentVnode } = vm.$options\n    vm.$vnode = _parentVnode!\n    vnode = render.call(vm._renderProxy, vm.$createElement)\n    ...\n    vnode.$parent = _parentVnode\n}\n</code></pre>\n<p>我看了接下来的流程， 子组件之所以会持有父节点，主要有两个作用</p>\n<ol>\n<li>往父组件的 $children 中push 当前实例<pre><code class=\"language-ts\">parent.$children.push(vm)\nvm.$parent = parent\n</code></pre>\n</li>\n<li>插入dom<pre><code class=\"language-ts\">insert(parentElm, vnode.elm, refElm)\n</code></pre>\n</li>\n</ol>\n<p>最后我们总结 patch 中 createElm方法：</p>\n<blockquote>\n<p>如果传入的<code>vnode</code> 个普通元素， <code>createComponent(vnode, insertedVnodeQueue, parentElm, refElm)</code> 的返回值是 false。接下来的过程就和我们上一章一样了，先创建一个父节点占位符，然后再遍历所有子 VNode 递归调用 <code>createElm</code>，在遍历的过程中，如果遇到子 VNode 是一个组件的 VNode，就走组件初始化和挂载的逻辑，通过一个递归的方式就可以完整地构建了整个组件树。</p>\n</blockquote>\n<h1 id=\"二-配置处理\">二. 配置处理</h1>\n<p>当我们平时开发组件时，会声明很多属性，也会使用 extends, mixin 等服用逻辑。而我们访问属性时直接从 vm 上就能访问的到，那么 Vue 是怎么实现这个配置合并到组件的呢？ 请接着往下看。</p>\n<h2 id=\"2-1实例场景\">2. 1实例场景</h2>\n<p>使用 mergeOptions 将构造器的 options 和 传入的 options 进行合并</p>\n<pre><code class=\"language-ts\">vm.$options = mergeOptions(\n    resolveConstructorOptions(vm.constructor as any),\n    options || {},\n    vm\n)\n</code></pre>\n<p>构造器的 options 包括全局的一些 components, directives, filters等</p>\n<p>接着看看 mergeOptions 的实际逻辑</p>\n<pre><code class=\"language-ts\">export function mergeOptions(\nparent: Record&lt;string, any&gt;,\nchild: Record&lt;string, any&gt;,\nvm?: Component | null\n): ComponentOptions {\n\nif (isFunction(child)) {\n    child = child.options\n}\n\n  \nnormalizeProps(child, vm)\nnormalizeInject(child, vm)\nnormalizeDirectives(child)\n  \nif (!child._base) {\n    if (child.extends) {\n        parent = mergeOptions(parent, child.extends, vm)\n    }\n    if (child.mixins) {\n        for (let i = 0, l = child.mixins.length; i &lt; l; i++) {\n            parent = mergeOptions(parent, child.mixins[i], vm)\n        }\n    }\n}\n\nconst options: ComponentOptions = {} as any\n\nlet key\n\nfor (key in parent) {\n    mergeField(key)\n}\n\nfor (key in child) {\n    if (!hasOwn(parent, key)) {\n        mergeField(key)\n    }\n\n}\n\nfunction mergeField(key: any) {\n    const strat = strats[key] || defaultStrat\n    options[key] = strat(parent[key], child[key], vm, key)\n\n}\n\nreturn options\n\n}\n</code></pre>\n<p>这里的步骤有：</p>\n<ol>\n<li>处理 props, inject, directives, 合并到child.options<ol>\n<li>这里child optinos 最终会由于合并策略 直接合并到options</li>\n</ol>\n</li>\n<li>将 extends 和 mixins 合并到 parent</li>\n<li>然后遍历parent, mergeField 到 options上</li>\n<li>遍历child, 将不在 parent上的属性合并到 options</li>\n<li>最后返回options, 挂载到 vm.options</li>\n</ol>\n<p>mergeField 函数针对不同的 key 值也有不同的合并策略</p>\n<pre><code class=\"language-ts\">const strats = config.optionMergeStrategies\nstrats.props = strats.methods = strats.inject = strats.computed = ...\n\nstrats[hook] = ...\n</code></pre>\n<p>具体每个属性的合并策略，我们后续有兴趣可以仔细看看。</p>\n<h2 id=\"22-组件场景\">2.2 组件场景</h2>\n<p>内部组件都是通过 Vue.extend 扩展为 Vue 的子类, 现在我们再看看 initInternalComponet 的具体逻辑</p>\n<pre><code class=\"language-ts\">export function initInternalComponent(\nvm: Component,\noptions: InternalComponentOptions\n) {\n    const opts = (vm.$options = Object.create((vm.constructor as any).options))\n\n    const parentVnode = options._parentVnode\n    opts.parent = options.parent\n    opts._parentVnode = parentVnode\n    const vnodeComponentOptions = parentVnode.componentOptions!\n    opts.propsData = vnodeComponentOptions.propsData\n    opts._parentListeners = vnodeComponentOptions.listeners\n    opts._renderChildren = vnodeComponentOptions.children\n    opts._componentTag = vnodeComponentOptions.tag\n\n    if (options.render) {\n        opts.render = options.render\n        opts.staticRenderFns = options.staticRenderFns\n\n    }\n\n}\n</code></pre>\n<p>这里的逻辑就是</p>\n<ol>\n<li>将vm.$options 的原型指向 构造器的options</li>\n<li>然后保留 父实例，父 VNode, 还保存propsData等属性</li>\n</ol>\n<p>这里可以看出，组件生成的实例主要还是以原型链为基础，结合简单的对象引用赋值，相比于直接实例化 Vue, 不需要进行那么多 配置的合并，递归和处理。所以官方注释也是这么说的</p>\n<blockquote>\n<p>optimize internal component instantiation\nsince dynamic options merging is pretty slow, and none of the\n internal component options needs special treatment.</p>\n</blockquote>\n<p> 内部组件的配置初始化要比 应用直接初始化要快的多，而且结合缓存，这对性能有极大的帮助</p>\n<h1 id=\"三-组件注册\">三. 组件注册</h1>\n<p>平时注册组件有两种方式，一种是通过 <code>Vue.component</code> 注册全局组件，还有中是在组件内部注册局部组件. 其实原理应该很简单的，全局注册就注册到 <code>Vue.options.components</code>里，局部注册就直接 注册到 <code>vm.$options.components</code>里. 然后组件初始化时混入构造器逻辑，就可以读取到全局组件了。</p>\n<p>接下来我们看看具体逻辑，首先是 全局注册</p>\n<h2 id=\"31-全局注册\">3.1 全局注册</h2>\n<pre><code class=\"language-ts\">// &gt; src/core/global-api/asset.ts\n\nexport function initAssetRegisters(Vue: GlobalAPI) {\n    ASSET_TYPES.forEach(type =&gt; {\n        Vue[type] = function (\n        id: string,\n        definition?: Function | Object\n        ): Function | Object | void {\n            if (type === &#39;component&#39; &amp;&amp; isPlainObject(definition)) {\n                definition.name = definition.name || id\n                definition = this.options._base.extend(definition)\n            }\n            this.options[type + &#39;s&#39;][id] = definition\n            return definition\n        }\n    })\n}\n</code></pre>\n<p>这里注册了 <code>Vue.component</code>,<code>Vue.directive</code>, <code>Vue.filter</code>三个静态方法，我们看下 <code>Vue.component</code>的逻辑。</p>\n<ol>\n<li>通过 <code>Vue.extend</code>将组件扩展为 组件构造器</li>\n<li>存入 <code>Vue.options</code> 中\n这样应用下的每个组件在实例化时，合并配置，都可以使用到这个组件</li>\n</ol>\n<h2 id=\"32-局部注册\">3.2 局部注册</h2>\n<p>局部注册就是实例化合并 <code>option</code> 时， 将 <code>components</code> 合并到 <code>vm.$options.components</code> 上，这样在组件中就可以使用注册的组件了</p>\n<h1 id=\"四-总结\">四. 总结</h1>\n<p>组件这一篇我是看的比较难受的，一开始很难理解内部组件的整体的创建流程。结合网上的文章和源码才断断续续读到差不多。但是对于整个流程还是有点迷糊，后续会绘制完整的流程图，方便理解。</p>\n",
        "title": "Vue 源码学习 (3) - 组件",
        "created": "2022-07-03 16:42:09  ",
        "updated": "2022-07-03 16:42:09 ",
        "excerpt": "一. createComponent Vue 开发就是开发组件，现在我们来看看组件形成 VNode 的逻辑。 在 _createElement 方法中, 在两种场景会调用 createComponent 方法 `ts // tag 是已经声...",
        "avatar": "https://avatars.githubusercontent.com/u/26271337?v=4",
        "id": "17"
    },
    "18": {
        "content": "<h1 id=\"一-数据初始化\">一. 数据初始化</h1>\n<p>如果有人问 Vue 的响应式是怎么实现的，大多数人会回答 通过数据劫持，利用 <code>Object.defineProperty</code> 劫持 getter 和 setter 实现的。数据赋值时，更新视图。然后数组 通过重写数组的 prototype 方法实现劫持。</p>\n<p>上面的说法其实也没多错，但是不够细节。例如依赖时怎么收集的，数据变化时，怎么知道该更新哪些数据？定义在 option 上的数据，为何通过 this 可以直接访问的到？ 带着这些疑问，我们继续源码探索之旅。</p>\n<p>首先来到数据初始化的逻辑</p>\n<pre><code class=\"language-ts\">// &gt; src/core/instance/state.ts\nexport function initState(vm: Component) {\n    const opts = vm.$options\n    if (opts.props) initProps(vm, opts.props)\n        initSetup(vm)\n    if (opts.methods) initMethods(vm, opts.methods)\n    if (opts.data) {\n        initData(vm)\n    } else {\n        const ob = observe((vm._data = {}))\n        ob &amp;&amp; ob.vmCount++\n    }\n    if (opts.computed) initComputed(vm, opts.computed)\n    if (opts.watch &amp;&amp; opts.watch !== nativeWatch) {\n        initWatch(vm, opts.watch)\n    }\n}\n</code></pre>\n<h2 id=\"11-initprops\">1.1 initProps</h2>\n<pre><code class=\"language-ts\">function initProps(vm: Component, propsOptions: Object) {\n    const propsData = vm.$options.propsData || {}\n    const props = (vm._props = shallowReactive({}))\n    const keys: string[] = (vm.$options._propKeys = [])\n    const isRoot = !vm.$parent\n\n    if (!isRoot) {\n        toggleObserving(false)\n    }\n    for (const key in propsOptions) {\n        keys.push(key)\n        const value = validateProp(key, propsOptions, propsData, vm)\n        defineReactive(props, key, value)\n\n        if (!(key in vm)) {\n            proxy(vm, `_props`, key)\n        }\n\n    }\n    toggleObserving(true)\n}\n</code></pre>\n<ol>\n<li>调用 <code>defineReactive</code> 将每个 prop key 变成响应式</li>\n<li>通过 proxy 方法将 vm._props.* 代理到 vm.* 上</li>\n</ol>\n<p>这里有一个 propsData ，这是给组件传入的 props 值</p>\n<h1 id=\"12-initdata\">1.2 initData</h1>\n<pre><code class=\"language-ts\">function initData(vm: Component) {\n    let data: any = vm.$options.data\n    data = vm._data = isFunction(data) ? getData(data, vm) : data || {}\n    // proxy data on instance\n    const keys = Object.keys(data)\n    let i = keys.length\n\n    while (i--) {\n        const key = keys[i]\n         if (!isReserved(key)) {\n            proxy(vm, `_data`, key)\n        }\n    }\n\n    // observe data\n    const ob = observe(data)\n    ob &amp;&amp; ob.vmCount++\n}\n</code></pre>\n<p>这里通过 proxy 方法将 data 中的 key 代理到 vm上，还有通过 observe 方法观测整个 data数据。</p>\n<p>数据初始化就先讲 initProps 和 initState, 通过这两个方法，我们了解到了三个重要函数 ，defineReactive , proxy, oberve 。接下来我们来看下这三个函数的主要逻辑。</p>\n<h1 id=\"13-proxy\">1.3 proxy</h1>\n<p>proxy 代理属性到 vm 上，这也是为什么我们写在 option 中的配置，可以直接通过 this 访问的到原因。</p>\n<pre><code class=\"language-ts\">const sharedPropertyDefinition = {\n    enumerable: true,\n    configurable: true,\n    get: noop,\n    set: noop\n}\n\n\nexport function proxy(target: Object, sourceKey: string, key: string) {\n    sharedPropertyDefinition.get = function proxyGetter() {\n        return this[sourceKey][key]\n    }\n    sharedPropertyDefinition.set = function proxySetter(val) {\n        this[sourceKey][key] = val\n    }\n    Object.defineProperty(target, key, sharedPropertyDefinition)\n}\n</code></pre>\n<p>逻辑很简单，就是通过 Object.defineProperty 劫持属性的访问，将对vm的操作，映射为被代理数据的操作。</p>\n<h1 id=\"14-observe\">1.4 observe</h1>\n<pre><code class=\"language-ts\">export function observe(value: any, shallow?: boolean): Observer | void {\n    let ob: Observer | void\n     if (\n\n        shouldObserve &amp;&amp;\n        !isServerRendering() &amp;&amp;\n        (isArray(value) || isPlainObject(value)) &amp;&amp;\n        Object.isExtensible(value) &amp;&amp;\n        !value.__v_skip\n    ) {\n        ob = new Observer(value, shallow)\n    }\n    return ob\n}\n</code></pre>\n<p>符合条件时，实例化一个 Observer 对象实例</p>\n<pre><code class=\"language-ts\">export class Observer {\n    dep: Dep\n    vmCount: number \n\n    constructor(public value: any, public shallow = false) {\n        this.dep = new Dep()\n        this.vmCount = 0\n        def(value, &#39;__ob__&#39;, this)\n        if (isArray(value)) {\n            protoAugment(value, arrayMethods)\n            if (!shallow) {\n                this.observeArray(value)\n            }\n\n        } else {\n            this.walk(value, shallow)\n        }\n    }\n\n    walk(obj: object, shallow: boolean) {\n        const keys = Object.keys(obj)\n        for (let i = 0; i &lt; keys.length; i++) {\n            const key = keys[i]\n            defineReactive(obj, key, NO_INIITIAL_VALUE, undefined, shallow)\n        }\n\n    }\n  \n    observeArray(items: Array&lt;any&gt;) {\n        for (let i = 0, l = items.length; i &lt; l; i++) {\n            observe(items[i])\n        }\n    }\n\n}\n</code></pre>\n<p>这里的逻辑主要是对 Array 和 Object 进行数据劫持</p>\n<ol>\n<li>如果是数组，就劫持原型方法，然后对每一项进行递归 observe</li>\n<li>如果是对象，就对每一个属性执行 defineReactive</li>\n</ol>\n<h1 id=\"15-definereactive\">1.5 defineReactive</h1>\n<p>initProps 和 initData 实质上都使用到了这个方法，现在看看它的逻辑</p>\n<pre><code class=\"language-ts\">export function defineReactive(\n    obj: object,\n    key: string,\n    val?: any,\n    customSetter?: Function | null,\n    shallow?: boolean\n) {\n\n    const dep = new Dep()\n    const property = Object.getOwnPropertyDescriptor(obj, key)\n\n    const getter = property &amp;&amp; property.get\n    const setter = property &amp;&amp; property.set\n\n\n    let childOb = !shallow &amp;&amp; observe(val)\n    Object.defineProperty(obj, key, {\n        enumerable: true,\n        configurable: true,\n        get: function reactiveGetter() {\n            const value = getter ? getter.call(obj) : val\n            if (Dep.target) {\n                dep.depend()\n                if (childOb) {\n                    childOb.dep.depend()\n                    if (isArray(value)) {\n                    dependArray(value)\n                    }\n                }\n            }\n            return isRef(value) ? value.value : value\n        },\n\n        set: function reactiveSetter(newVal) {\n            const value = getter ? getter.call(obj) : val\n            if (!hasChanged(value, newVal)) {\n                return\n            }\n\n            if (setter) {\n                setter.call(obj, newVal)\n            } else if (getter) {\n                return\n            } else if (isRef(value) &amp;&amp; !isRef(newVal)) {\n                value.value = newVal\n                return\n            } else {\n                val = newVal\n            }\n\n            childOb = !shallow &amp;&amp; observe(newVal)\n            dep.notify()\n        }\n\n    })\n    return dep\n\n}\n</code></pre>\n<p>这里执行的逻辑为：</p>\n<ol>\n<li>拿到原始的 getter和 setter,方便后续劫持时使用</li>\n<li>如果不是 shallow, 就Observe当前数据</li>\n<li>getter函数中，如果Dep.target 存在，就执行depend<ol>\n<li>自身depend</li>\n<li>childOb 的depend</li>\n</ol>\n</li>\n<li>setter函数中<ol>\n<li>利用原始getter得到原始值，和新值比较，如果不变就 return</li>\n<li>执行赋值逻辑，重新对当前属性observe</li>\n<li>执行 notify</li>\n</ol>\n</li>\n</ol>\n<p>这个函数也是通过递归对整个对象进行劫持，这样保证了无论是多深的数据结构，任何值变化都能执行 notify的逻辑</p>\n<p>上面的方法中，我们能看到 Dep 这个类，在执行getter时，会触发 dep.depend 来进行依赖收集 ，setter 时会触发 dep.notify方法进行派发更新。其实这就是 Vue 响应式的基本原理。接下来我们来看下 Dep 这个类</p>\n<h1 id=\"二-dep\">二. Dep</h1>\n<p>Dep 类的定义</p>\n<pre><code class=\"language-ts\">export interface DepTarget extends DebuggerOptions {\n    id: number\n    addDep(dep: Dep): void\n    update(): void\n}\n\nexport default class Dep {\n    static target?: DepTarget | null\n    id: number\n    subs: Array&lt;DepTarget&gt;\n\n    constructor() {\n        this.id = uid++\n        this.subs = []\n    }\n    addSub(sub: DepTarget) {\n        this.subs.push(sub)\n    }\n    removeSub(sub: DepTarget) {\n        remove(this.subs, sub)\n    }\n    depend() {\n        if (Dep.target) {\n            Dep.target.addDep(this)\n        }\n    }\n    notify() {\n        const subs = this.subs.slice()\n        for (let i = 0, l = subs.length; i &lt; l; i++) {\n            subs[i].update()\n        }\n    }\n}\n</code></pre>\n<p>Dep 拥有一个静态属性 target, 全局唯一。在使用 depend方法时 实际上是对当前 target 添加 addDep. 在使用 notify 方法会对当前所有的订阅执行更新方法。</p>\n<p>所以一切的关键都在于 target.addDep 的方法执行的逻辑。</p>\n<p>实际上 Dep 和 Watcher 相辅相成，target 指向的一般是 watcher, subs也是 watcher数组。</p>\n<h1 id=\"三-watcher\">三. Watcher</h1>\n<p>在前面的文章中，我们了解到有渲染 watcher,。</p>\n<p>我们平时在 options 时可以自定义 watcher , 还有我们使用的 computed ，它本质上也是一个 watcher。</p>\n<p>总的来说，Vue 的响应式的实现就是依赖 Watcher 的。现在我们就来看看 Watcher 的逻辑。</p>\n<pre><code class=\"language-ts\">&gt; core/observer/watcher.ts\n\nexport default class Watcher implements DepTarget {\n    vm?: Component | null\n    expression: string\n    cb: Function\n    id: number\n    deep: boolean\n    user: boolean\n    lazy: boolean\n    sync: boolean\n    dirty: boolean\n    active: boolean\n    deps: Array&lt;Dep&gt;\n    newDeps: Array&lt;Dep&gt;\n    depIds: SimpleSet\n    newDepIds: SimpleSet\n    before?: Function\n    onStop?: Function\n    noRecurse?: boolean\n    getter: Function\n    value: any\n\n    constructor(\n    vm: Component | null,\n    expOrFn: string | (() =&gt; any),\n    cb: Function,\n    options?: WatcherOptions | null,\n    isRenderWatcher?: boolean\n    ) {\n        recordEffectScope(this, activeEffectScope || (vm ? vm._scope : undefined))\n        if ((this.vm = vm)) {\n\n            if (isRenderWatcher) {\n\n            vm._watcher = this\n\n            }\n\n        }\n        if (options) {\n            this.deep = !!options.deep\n            this.user = !!options.user\n            this.lazy = !!options.lazy\n            this.sync = !!options.sync\n            this.before = options.before\n        } else {\n            this.deep = this.user = this.lazy = this.sync = false\n        }\n\n        this.cb = cb\n        this.id = ++uid // uid for batching\n        this.active = true\n        this.dirty = this.lazy // for lazy watchers\n        this.deps = []\n        this.newDeps = []\n        this.depIds = new Set()\n        this.newDepIds = new Set()\n        this.expression = &#39;&#39;\n\n        if (isFunction(expOrFn)) {\n            this.getter = expOrFn\n        } else {\n            this.getter = parsePath(expOrFn)\n        }\n        this.value = this.lazy ? undefined : this.get()\n    }\n\n  \n\n    get() {\n        pushTarget(this)\n        let value\n        const vm = this.vm\n        try {\n            value = this.getter.call(vm, vm)\n        } finally {\n            if (this.deep) {\n                traverse(value)\n            }\n            popTarget()\n            this.cleanupDeps()\n        }\n        return value\n    }\n\n    addDep(dep: Dep) {\n        const id = dep.id\n        if (!this.newDepIds.has(id)) {\n            this.newDepIds.add(id)\n            this.newDeps.push(dep)\n            if (!this.depIds.has(id)) {\n                dep.addSub(this)\n            }\n        }\n\n    }\n\n  \n\n    cleanupDeps() {\n        let i = this.deps.length\n\n        while (i--) {\n            const dep = this.deps[i]\n            if (!this.newDepIds.has(dep.id)) {\n                dep.removeSub(this)\n            }\n        }\n\n        let tmp: any = this.depIds\n        this.depIds = this.newDepIds\n        this.newDepIds = tmp\n        this.newDepIds.clear()\n\n        tmp = this.deps\n        this.deps = this.newDeps\n        this.newDeps = tmp\n        this.newDeps.length = 0\n    }\n\n  \n\n    update() {\n        if (this.lazy) {\n            this.dirty = true\n        } else if (this.sync) {\n            this.run()\n        } else {\n            queueWatcher(this)\n\n        }\n\n    }\n\n    run() {\n        if (this.active) {\n            const value = this.get()\n            if (\n                value !== this.value ||\n            isObject(value) ||\n            this.deep\n            ) {\n            const oldValue = this.value\n            this.value = value\n            if (this.user) {\n                const info = `callback for watcher &quot;${this.expression}&quot;`\n                invokeWithErrorHandling(\n                    this.cb,\n                    this.vm,\n                    [value, oldValue],\n                    this.vm,\n                    info\n                )\n\n                } else {\n                    this.cb.call(this.vm, value, oldValue)\n                }\n            }\n        }\n    }\n\n    evaluate() {\n        this.value = this.get()\n        this.dirty = false\n    }\n\n    depend() {\n        let i = this.deps.length\n        while (i--) {\n            this.deps[i].depend()\n        }\n    }\n\n    teardown() {\n        if (this.vm &amp;&amp; !this.vm._isBeingDestroyed) {\n            remove(this.vm._scope.effects, this)\n        }\n        if (this.active) {\n            let i = this.deps.length\n            while (i--) {\n                this.deps[i].removeSub(this)\n            }\n            this.active = false\n            if (this.onStop) {\n                this.onStop()\n            }\n\n        }\n\n    }\n\n}\n</code></pre>\n<p>在 Watcher 类中，有几个属性需要注意</p>\n<pre><code class=\"language-ts\">deps: Array&lt;Dep&gt; // 依赖数组\nnewDeps: Array&lt;Dep&gt; // 依赖数组\ndepIds: SimpleSet // 依赖id set\nnewDepIds: SimpleSet // 依赖id set\n</code></pre>\n<h2 id=\"31-依赖收集和派发更新\">3.1 依赖收集和派发更新</h2>\n<p>在 Watcher 初始化时，会执行自己的 get方法</p>\n<pre><code class=\"language-ts\">\nthis.getter = expOrFn\nthis.value = this.lazy ? undefined : this.get()\n}\n\nget() {\n    pushTarget(this)\n    let value\n    const vm = this.vm\n    ...\n    value = this.getter.call(vm, vm)\n    ...\n    if (this.deep) {\n        traverse(value)\n    }\n    popTarget()\n    this.cleanupDeps()\n    return value\n\n}\n</code></pre>\n<p>get 方法中会执行 pushTarget 和 popTarget 方法</p>\n<pre><code class=\"language-ts\">export function pushTarget(target?: DepTarget | null) {\n    targetStack.push(target)\n    Dep.target = target\n}\nexport function popTarget() {\n    targetStack.pop()\n    Dep.target = targetStack[targetStack.length - 1]\n}\n</code></pre>\n<p>pushTarget 方法就是把当前的 watcher 设为 Dep.target并压栈</p>\n<p>然后执行 this.getter 方法，会想 <code>mountComponent</code> 方法，在实例化 在渲染 <code>watcher</code> 中， <code>getter</code> 方法传入的是 <code>updateCompontent</code></p>\n<pre><code class=\"language-ts\">updateComponent = () =&gt; {\n    vm._update(vm._render(), hydrating)\n}\n</code></pre>\n<p>这里 vm.render() 生成 VNode 时会触发 vm上响应式数据的 getter , 也因此调用 <code>dep.depend()</code> 方法，也就是 <code>Dep.target.addDep(this)</code>，也就是当前 watcher 执行 addDep方法</p>\n<pre><code class=\"language-ts\">addDep(dep: Dep) {\n    const id = dep.id\n    if (!this.newDepIds.has(id)) {\n        this.newDepIds.add(id)\n        this.newDeps.push(dep)\n        if (!this.depIds.has(id)) {\n            dep.addSub(this)\n        }\n    }\n}\n</code></pre>\n<p>这里 watcher 收集了数据的依赖，数据的依赖也收集了 watcher 的依赖。然后执行 popTarget 将当前Dep.tareget 恢复成上一次的状态</p>\n<pre><code class=\"language-ts\">popTarget()\nthis.cleanupDeps()\n</code></pre>\n<p>这里除了 popTarget 之外， 这里还执行了 this.cleanupDesp 方法</p>\n<pre><code class=\"language-ts\">cleanupDeps() {\n    let i = this.deps.length\n    while (i--) {\n        const dep = this.deps[i]\n        if (!this.newDepIds.has(dep.id)) {\n            dep.removeSub(this)\n        }\n    }\n    let tmp: any = this.depIds\n    this.depIds = this.newDepIds\n    this.newDepIds = tmp\n    this.newDepIds.clear()\n    tmp = this.deps\n    this.deps = this.newDeps\n    this.newDeps = tmp\n    this.newDeps.length = 0\n}\n</code></pre>\n<p>这里的逻辑就是将没有依赖进行更新，对没有用到的依赖进行移除。</p>\n<p>所以通过 watcher 和 Dep.depend  在组件进行渲染时，触发数据的getter，进行依赖的收集。这里watcher 也收集了依赖，主要是为了每次更新能够移除不再需要的依赖，使更新更加颗粒度。</p>\n<p>所以当数据更新，触发 setter 时，会触发当前数据的 <code>dep.notify</code>, 然后将 dep 所有的依赖 sub，触发 sub.update. 也就是当前 渲染 watcher 的 update 方法</p>\n<pre><code class=\"language-ts\">update() {\n    if (this.lazy) {\n        this.dirty = true\n    } else if (this.sync) {\n        this.run()\n    } else {\n        queueWatcher(this)\n    }\n\n}\n</code></pre>\n<p>这里 渲染 watcher 会走 queueWatcher 的逻辑，至于 lazy 和 sync 会和其他功能的实现有关系，我们后面再专门去讲。</p>\n<pre><code class=\"language-ts\">export function queueWatcher(watcher: Watcher) {\n    const id = watcher.id\n    if (has[id] != null) {\n        return\n    }\n    if (watcher === Dep.target &amp;&amp; watcher.noRecurse) {\n        return\n    }\n    has[id] = true\n    if (!flushing) {\n        queue.push(watcher)\n    } else {\n        let i = queue.length - 1\n        while (i &gt; index &amp;&amp; queue[i].id &gt; watcher.id) {\n            i--\n        }\n        queue.splice(i + 1, 0, watcher)\n    }\n\n    if (!waiting) {\n        waiting = true\n        nextTick(flushSchedulerQueue)\n    }\n}\n</code></pre>\n<p>我们可以看到这里的逻辑就是讲当前的watcher push 到队列中，然后在 nextTick 的回调中执行 flushSchedulerQueue方法。因此我们可知，并不是每次数据更新，视图都会更新，而是push 到队列中，进行批量更新。</p>\n<pre><code class=\"language-ts\">function flushSchedulerQueue() {\n    currentFlushTimestamp = getNow()\n    flushing = true\n    let watcher, id\n    queue.sort((a, b) =&gt; a.id - b.id)\n    for (index = 0; index &lt; queue.length; index++) {\n        watcher = queue[index]\n        if (watcher.before) {\n            watcher.before()\n        }\n        id = watcher.id\n        has[id] = null\n        watcher.run()\n    }\n\n    const activatedQueue = activatedChildren.slice()\n    const updatedQueue = queue.slice()\n    resetSchedulerState()\n    // 触发hook\n    callActivatedHooks(activatedQueue)\n    callUpdatedHooks(updatedQueue)\n}\n</code></pre>\n<p>flushSchedulerQueue 逻辑为：</p>\n<ol>\n<li>对queue进行排序<ol>\n<li>保证 父组件比子组件先更新</li>\n<li>用户自定义 watcher 比 渲染 watcher 先执行</li>\n<li>如果一个组件被父组件 watcher 执行时销毁，那么该组件的watcher 可以不被执行</li>\n</ol>\n</li>\n<li>在遍历中执行wachter.run 的方法，而且在watcher 执行过程中可能会添加新的watcher到队列，所以这里用了传统的 for 循环，每次都会判断 length<pre><code class=\"language-ts\">let i = queue.length - 1\nwhile (i &gt; index &amp;&amp; queue[i].id &gt; watcher.id) {\n i--\n}\nqueue.splice(i + 1, 0, watcher)\n</code></pre>\n</li>\n<li>执行 resetSchedulerState 函数，重置状态和队列<pre><code class=\"language-ts\">function resetSchedulerState() {\n index = queue.length = activatedChildren.length = 0\n has = {}\n waiting = flushing = false\n}\n</code></pre>\n</li>\n</ol>\n<p>在 watcher.run 函数中</p>\n<pre><code class=\"language-ts\">run() {\n    if (this.active) {\n        const value = this.get()\n        if (\n            value !== this.value ||\n            isObject(value) ||\n            this.deep\n        ) {\n            const oldValue = this.value\n            this.value = value\n            this.cb.call(this.vm, value, oldValue)\n        }\n    }\n}\n</code></pre>\n<p>run 方法，先执行 get 方法，然后执行 回调。 对于渲染 watcher 就是执行 udpateComponent 方法，对于用户自定义的watcher, 也就是执行我们定义执行的回调。</p>\n<h1 id=\"四-响应式存在的问题\">四. 响应式存在的问题</h1>\n<p>在进行业务开发时，我们知道给对象添加新的key值，视图不会更新，这是因为当前的key 值并未被劫持, 不能触发setter.</p>\n<p>而数组改动某一项的值也存在这个问题，而数组是因为劫持的是原型方法，直接根据索引改值也不会触发 dep.notify 的逻辑。</p>\n<p>而我们针对这种情况会使用 $set 函数解决这种情况。</p>\n<pre><code class=\"language-ts\">export function set(\ntarget: any[] | Record&lt;string, any&gt;,\nkey: any,\nval: any\n): any {\n\n\n    if (isArray(target) &amp;&amp; isValidArrayIndex(key)) {\n        target.length = Math.max(target.length, key)\n        target.splice(key, 1, val)\n        return val\n    }\n\n    if (key in target &amp;&amp; !(key in Object.prototype)) {\n        target[key] = val\n        return val\n    }\n\n    const ob = (target as any).__ob__\n\n    if ((target as any)._isVue || (ob &amp;&amp; ob.vmCount)) {\n        return val\n    }\n\n    if (!ob) {\n        target[key] = val\n        return val\n    }\n\n    defineReactive(ob.value, key, val)\n    ob.dep.notify()\n    return val\n}\n</code></pre>\n<ol>\n<li>如果是改变数组的值，就使用 splice 方法，触发更新</li>\n<li>如果本身在target上，直接复制并返回</li>\n<li>如果 target 不是响应式对象，直接赋值</li>\n<li>对当前target 的 key 值进行响应式处理</li>\n<li>通知 dep 更新</li>\n</ol>\n<h1 id=\"五-总结\">五. 总结</h1>\n<p>看到现在，我们知道了 数据初始化时 是如何变成 响应式数据的，然后知道了 依赖如何收集和更新如何派发。 而且 数据触发更新，并不会直接更新，而是进入到队列中，在nextTick的回调中进行更新操作。</p>\n<p>后面文章会讲下 nextTick 的逻辑，还有在 watcher 中我们漏掉的逻辑，这也会涉及到 computed 和 用户自定义 watcher 的实现。</p>\n<p>这里补一张 总体的流程图\n<img src=\"https://ustbhuangyi.github.io/vue-analysis/assets/reactive.png\" alt=\"\"></p>\n",
        "title": "Vue 源码学习 (4) - 响应式篇",
        "created": "2022-07-03 16:42:54  ",
        "updated": "2022-07-03 16:42:54 ",
        "excerpt": "一. 数据初始化 如果有人问 Vue 的响应式是怎么实现的，大多数人会回答 通过数据劫持，利用 Object.defineProperty 劫持 getter 和 setter 实现的。数据赋值时，更新视图。然后数组 通过重写数组的 pro...",
        "avatar": "https://avatars.githubusercontent.com/u/26271337?v=4",
        "id": "18"
    },
    "19": {
        "content": "<h1 id=\"写在前面\">写在前面</h1>\n<p>在平时开发中，我们更新数据后，需要通过 nextTick 的回调中才能获取DOM。</p>\n<pre><code class=\"language-ts\">this.value = 1\nthis.$nextTick(() =&gt; {\n    ...\n})\n</code></pre>\n<p>通过前面的文章我们知道，这是因为 Vue中数据更新后，视图并不是立即更新，而是进入批量更新的队列中，而批量更新的队列也是在 nextTick 的回调，所以当 更新的回调执行完成后，我们操作dom的回调执行时才能正确获取到DOM的状态。</p>\n<p>所以来看看nextTick</p>\n<h1 id=\"nexttick\">nextTick</h1>\n<pre><code class=\"language-ts\">export function nextTick(cb?: (...args: any[]) =&gt; any, ctx?: object) {\n    let _resolve\n    callbacks.push(() =&gt; {\n        if (cb) {\n        cb.call(ctx)\n        } else if (_resolve) {\n        _resolve(ctx)\n        }\n\n    })\n    if (!pending) {\n        pending = true\n        timerFunc()\n    }\n    if (!cb &amp;&amp; typeof Promise !== &#39;undefined&#39;) {\n    return new Promise(resolve =&gt; {\n        _resolve = resolve\n    })\n\n    }\n\n}\n</code></pre>\n<p>nextTick 方法可以将 回调函数推入到 callbacks 数组中，如果未传入 cb， 则会执行 resolve， 保证 nextTick后的 then回调被执行。</p>\n<p>这里会执行 timeFunc 函数</p>\n<pre><code class=\"language-ts\">const p = Promise.resolve()\ntimerFunc = () =&gt; {\n    p.then(flushCallbacks)\n    if (isIOS) setTimeout(noop)\n}\n...\ntimerFunc = () =&gt; {\n    setImmediate(flushCallbacks)\n}\n...\ntimerFunc = () =&gt; {\n    setTimeout(flushCallbacks, 0)\n}\n</code></pre>\n<p>这里做了很多兼容，有使用Promise 的微任务回调版本，也有定时器版本的宏任务版本。</p>\n<p>这里保证nextTick 回调的执行实际在 任务队列中完成，执行 flushCallbacks</p>\n<pre><code class=\"language-ts\">function flushCallbacks() {\n    pending = false\n    const copies = callbacks.slice(0)\n    callbacks.length = 0\n    for (let i = 0; i &lt; copies.length; i++) {\n        copies[i]()\n    }\n}\n</code></pre>\n<p>平时我们使用的 $nextTick 就是 这个逻辑</p>\n<pre><code class=\"language-ts\">Vue.nextTick = nextTick\nVue.prototype.$nextTick = function (fn: (...args: any[]) =&gt; any) {\n    return nextTick(fn, this)\n}\n</code></pre>\n<h1 id=\"总结\">总结</h1>\n<p>通过对 nextTick 的源码学习，我们知道了 Vue 的批量更新是 不是在主线程执行的逻辑里面，而是在任务队列中执行相关的逻辑。</p>\n",
        "title": "Vue 源码学习 (5) - nextTick",
        "created": "2022-07-03 16:43:36  ",
        "updated": "2022-07-03 16:43:36 ",
        "excerpt": "写在前面 在平时开发中，我们更新数据后，需要通过 nextTick 的回调中才能获取DOM。 `ts this.value = 1 this.$nextTick(() => { ... }) ` 通过前面的文章我们知道，这是因为 Vue中数...",
        "avatar": "https://avatars.githubusercontent.com/u/26271337?v=4",
        "id": "19"
    },
    "20": {
        "content": "<h1 id=\"一-写在前面\">一. 写在前面</h1>\n<p>React 生态的状态管理库有很多，比如Redux ，Recoil ，Mobx，自身的 context  也可以用来进行状态管理。</p>\n<p>首先 Redux 实在说不上是一个合格的状态管理库，功能太基础，结合业务必须使用插件。而且需要写的模版代码太多了，开发体验一般般。</p>\n<p>而 Mobx 也不太行，在 class 组件流行时，通过装饰器写 Mobx 还是很爽的。但是 hooks 流行的今天，呃，就这样吧。</p>\n<p><a href=\"https://github.com/pmndrs/zustand\">Zustand</a> 是这么多状态管理库中让我眼前一亮的库。它的代码很少，功能很多。</p>\n<h1 id=\"二-安装\">二. 安装</h1>\n<pre><code class=\"language-shell\">npm install zustand \n</code></pre>\n<h1 id=\"三-快速使用\">三. 快速使用</h1>\n<h2 id=\"31-定义store\">3.1 定义store</h2>\n<pre><code class=\"language-ts\">import create from &#39;zustand&#39;\n\nconst useStore = create((set) =&gt; ({\n  bears: 0,\n  increasePopulation: () =&gt; set((state) =&gt; ({ bears: state.bears + 1 })),\n  removeAllBears: () =&gt; set({ bears: 0 }),\n}))\n</code></pre>\n<p>在 create 时， set 有几种用法</p>\n<ul>\n<li><code>set(obj)</code>  obj 会合并到 state中</li>\n<li><code>set(state =&gt; obj)</code>  函数返回值合并到 state 中</li>\n<li><code>set(obj, true) </code> obj 会取代当前 state</li>\n</ul>\n<p>create 函数中的第二个参数是 <code>get</code>， 我们可以通过 get 获取当前的 state</p>\n<h2 id=\"32-在组件中使用\">3.2 在组件中使用</h2>\n<pre><code class=\"language-ts\">function BearCounter() {\n  const bears = useStore((state) =&gt; state.bears)\n  return &lt;h1&gt;{bears} around here ...&lt;/h1&gt;\n}\n\nfunction Controls() {\n  const increasePopulation = useStore((state) =&gt; state.increasePopulation)\n  return &lt;button onClick={increasePopulation}&gt;one up&lt;/button&gt;\n}\n</code></pre>\n<p>上面都是我从官网中 copy 的代码，实际开发也就是这么写的。可以看出，它的代码真的非常的少，我需要什么，我就定义什么。</p>\n<h1 id=\"四-优势\">四. 优势</h1>\n<p>和 redux 比：</p>\n<ol>\n<li>简单</li>\n<li>hooks 友好</li>\n<li>不需要 context provider</li>\n<li>可以和组件渲染解耦，只更改状态\n```ts\nconst useStore = create(set =&gt; ({ scratches: 0, ... }))</li>\n</ol>\n<p>function Component() {\n  const scratchRef = useRef(useStore.getState().scratches)\n  useEffect(() =&gt; useStore.subscribe(\n    state =&gt; (scratchRef.current = state.scratches)\n  ), [])</p>\n<pre><code>\n和 context 比：\n1. 更少的模版代码\n2. 只在数据变化时更新组件\n3. 集中的、基于操作的状态管理\n\n# 五. 插件\n```ts\nconst log = (config) =&gt; (set, get, api) =&gt;\n  config(\n    (...args) =&gt; {\n      console.log(&#39;  applying&#39;, args)\n      set(...args)\n      console.log(&#39;  new state&#39;, get())\n    },\n    get,\n    api\n  )\n\nconst useStore = create(\n  log((set) =&gt; ({\n    bees: false,\n    setBees: (input) =&gt; set({ bees: input }),\n  }))\n)\n</code></pre>\n<p><code>Zustand</code>的插件也很简单，就是定义一个函数。 上面这个 log 插件也逻辑很清晰，在create 内执行时，对set 方法进行覆写，实现 log 的效果</p>\n<p>我在RN 中开发中需要对数据进行持久化，于是我可以这么写</p>\n<pre><code class=\"language-ts\">TODO\n</code></pre>\n<h1 id=\"六-总结\">六. 总结</h1>\n<p>Zustand 是一个优秀的数据管理库，可以很好的管理应用的状态。逻辑简单，可定制化强。开发 React 应用，Zustand 是不错的选择。</p>\n",
        "title": "简单又强大的状态管理 - Zustand",
        "created": "2022-07-07 16:11:21  ",
        "updated": "2022-07-07 16:11:21 ",
        "excerpt": "一. 写在前面 React 生态的状态管理库有很多，比如Redux ，Recoil ，Mobx，自身的 context 也可以用来进行状态管理。 首先 Redux 实在说不上是一个合格的状态管理库，功能太基础，结合业务必须使用插件。而且需要...",
        "avatar": "https://avatars.githubusercontent.com/u/26271337?v=4",
        "id": "20"
    },
    "21": {
        "content": "<h1 id=\"hooks-出现的原因\">hooks 出现的原因</h1>\n<ol>\n<li><p>class 自身存在的问题</p>\n<ol>\n<li>组件逻辑复用困难，尽管拥有HOC 和render props ，逻辑复用还是比较困难。</li>\n<li>在不同生命周期中执行不同的逻辑，组件会变得越来越复杂。相关的逻辑不好抽离</li>\n<li>使用Class 组件只为了组件定义状态，视图和逻辑，其实没有用到Class 的太多功能。而且还需要处理 this的绑定</li>\n<li>通过this 读取状态，是有副作用的。并不能确保状态的正确性\n```tsx\nclass ProfilePage extends React.Component { \n showMessage = () =&gt; {\n alert(&#39;Followed &#39; + this.props.user); \n };</li>\n</ol>\n<p> handleClick = () =&gt; { \n     setTimeout(this.showMessage, 3000); \n }; \n render() {\n     return &lt;button onClick{this.handleClick}&gt;\n         Follow</button>; \n }</p>\n</li>\n</ol>\n<p>}</p>\n<pre><code>例如这个组件，点击发生后，如果props改变，那么最终的弹出的数据并不符合点击时的预期\n\n2. 增强函数组件\n\n之前版本的函数组件太过鸡肋，只能用于展示，自身不拥有状态。\n\n\n# hooks 存在的问题\n## 使用场景限制\n\nReact hook 不能在判断语句中使用\n```ts\ncosnt [count, setCount] = useState(0)\nif(count == 2) {\n   const [num, setNum] = useState(1)\n}\n...\n</code></pre>\n<p>具体原因是和 hook 的原理有关。 hook 通过闭包维护状态，然后将每个hooks注册到一个链表中进行存储，也就是说 hook 本身取值是有顺序的。 </p>\n<p>当组件更新时，hook重新执行，如果通过条件语句新增或者减少 hook 都会影响到原有链表的顺序，造成取值异常。</p>\n<h2 id=\"闭包陷阱\">闭包陷阱</h2>\n<p>当我们使用 useEffect 时，不同的依赖项会有不同的效果。 当我们传入空数组时， 此时的 useEffect 相当于 componentDidMount. 只会执行一次。结合函数使用时，就有可能产生的问题。</p>\n<pre><code class=\"language-ts\">export default function App() {\n  const [count, setCount] = useState(0);\n  useEffect(() =&gt; {\n    const timer = setInterval(() =&gt; {\n      console.log(count);\n    }, 3000);\n  }, []);\n  return (\n    &lt;div className=&quot;App&quot;&gt;\n      &lt;h1&gt; {count}&lt;/h1&gt;\n      &lt;h2 onClick={() =&gt; setCount(count + 1)}&gt;\n        Start editing to see some magic happen!\n      &lt;/h2&gt;\n    &lt;/div&gt;\n  );\n}\n</code></pre>\n<p>这个例子中， 定时器通过闭包获取的变量永远都是第一次渲染时的 count， 导致打印的都是 0.</p>\n<p>其实不止定时器，还有在 useEffect 外部定义的函数，都有可能产生这个问题。</p>\n<p>解决办法：</p>\n<ol>\n<li>useEffect 添加依赖，内部函数使用到了哪个变量，就加入到依赖项。函数也是如此<pre><code class=\"language-ts\"> const [count, setCount] = useState(0);\n  useEffect(() =&gt; {\n const timer = setInterval(() =&gt; {\n   console.log(count);\n }, 3000);\n return () =&gt; {\n   clearInterval(timer)\n }\n  }, [count]);\n</code></pre>\n</li>\n<li>使用useRef, 由于 ref是一个对象，它的 current 才指向真实的值。所以可以避免这个问题</li>\n</ol>\n",
        "title": "我所理解的 React Hooks ",
        "created": "2022-07-09 09:28:43  ",
        "updated": "2022-07-09 16:05:44 ",
        "excerpt": "hooks 出现的原因 class 自身存在的问题 组件逻辑复用困难，尽管拥有HOC 和render props ，逻辑复用还是比较困难。 在不同生命周期中执行不同的逻辑，组件会变得越来越复杂。相关的逻辑不好抽离 使用Class 组件只为了...",
        "avatar": "https://avatars.githubusercontent.com/u/26271337?v=4",
        "id": "21"
    },
    "22": {
        "content": "<h1 id=\"写在前面\">写在前面</h1>\n<p>今年是毕业的第三年，也是我从事前端开发的第三年。相比于刚毕业时用 Vue 都不太熟练的新手，现在的我可以算的上是一名靠谱的前端开发。对于前端这一领域，我也有了一些自己的思考。</p>\n<h1 id=\"学习\">学习</h1>\n<p>内卷这个词语是近几年的热词。作为程序员，我从技术网站，社交平台经常会接收到各种渲染焦虑信息，这些信息会逼着我们内卷，学习。</p>\n<p>我一直要求自己成为不可替代的那种技术人才，而不是 CRUD boy，为此我也做了很多努力。基本上的时间都是在学习，看技术视频，博客。但是学习真的由减轻自己的心里压力吗，能够保证自己未来不失业，不35岁送外卖吗？ </p>\n<p>其实不能！至少对于我来说是不能的，我依旧感觉到焦虑，依旧对未来没有希望。我会因为技术焦虑买一些课程，或者学习目前根本用不到的东西（3D渲染，C++, Flutter），但是都没有很好的学习下去。</p>\n<p>前端的技术更迭很快，各种包管理，构建工具，语言，框架层出不穷。今天我看了这个源码，明天学会了那个工具。追逐技术的过程是比较累的。</p>\n<p>现在的我理解到，只有真正的业务实践才是最好的学习方法， 而我更应该掌握的是如何快速学习的能力。</p>\n<p>比如我负责的一个移动端APP的开发需求，从技术预研，相关框架和语言学习，到后面同步给同事学习，快速开发业务。整体的时间花费是比较少的，因为我知道了如何快速的去学习。</p>\n<p>关于学习的方向，我现在是比较明确的。JS/TS 编程语言精通，UI框架熟练掌握，扩展自己移动端原生开发的能力，熟悉后端的技术。总的来说就是 前端有深度，技术有广度。</p>\n<h1 id=\"和后端的比较\">和后端的比较</h1>\n<p>很多人说前端是娱乐圈，没有什么技术门槛。刚入门时我听到还是会有点不开心的，觉得自己的工作被人贬低，而且作为非科班出身，不可避免会有不自信的心态。</p>\n<p>而对于现在的我来说，我反而庆幸前端的门槛低。我能通过自学快速的找到一份前端的工作，而且在工作中获得持续的成就感。到现在三年了，我在工作中获得的成就感从未中断。</p>\n<p>后端的确比前端复杂，后端的开发体验和开发流程十分的完整，工业化程度十分的高。前端其实起势也就这十几年，JS变成一门还算可以的语言也就这几年。而且对于多人维护的项目来说，JS算不得上是好语言，灵活的优点带来的缺点更多。还好我们有TS， 我可以自信的说，TS 改变了前端。</p>\n<p>可能对于很多项目来说，复杂的业务逻辑都由后端来处理，前端做的都是一些页面交互，没有<strong>含金量</strong>。对也不完全对，用户交互在我看来和功能来说一样重要。很多时候产品想的和用户实际使用的根本对不上，交互是产品和用户交流的第一线，好的交互有利于成就伟大的产品。前端平时开发时也应该多想想交互，把自己作为第一个测试和用户来体验产品。写出恶心人的交互是对前端工作的侮辱。</p>\n<p>对于现在的前端，其实业务逻辑也不简单。我做过业务包含编辑器，大部分的业务逻辑都在前端。后端的业务只有数据存储和文件写入。而且现在很多在线文档，笔记或者其他工具，它们的前端业务也很复杂。桌面应用网页化是潮流所向，所以前端不仅只有页面，我们的未来是一篇蓝海。</p>\n<h2 id=\"我的困惑\">我的困惑</h2>\n<p>前面讲了很多东西，现在我讲一下我的一些疑惑点吧，希望未来的自己能够解答这些问题</p>\n<ol>\n<li>组件和样式的边界在哪里，如果只是样式一致，有必要抽离成组件吗？</li>\n<li>很多开发都渐渐变成了 chrome 前端工程师，这种趋势好吗？</li>\n<li>CSS的兼容问题，如果一种写法有 90% 的用户显示正常，是否需要对10% 写更多的hack代码？</li>\n<li>utility css 类框架例如 tailwind css 变得流行，但是开发的代码如何去维护？</li>\n</ol>\n",
        "title": "工作三年，我对前端领域的困惑",
        "created": "2022-07-30 15:42:12  ",
        "updated": "2022-10-07 13:01:22 ",
        "excerpt": "写在前面 今年是毕业的第三年，也是我从事前端开发的第三年。相比于刚毕业时用 Vue 都不太熟练的新手，现在的我可以算的上是一名靠谱的前端开发。对于前端这一领域，我也有了一些自己的思考。 学习 内卷这个词语是近几年的热词。作为程序员，我从技术...",
        "avatar": "https://avatars.githubusercontent.com/u/26271337?v=4",
        "id": "22"
    },
    "23": {
        "content": "<h1 id=\"一-写在前面\">一. 写在前面</h1>\n<p>之前文章讲了 SDK开发的背景，和具体封装的逻辑。最近有用户使用我的SDK进行二次开发，对接的过程中我发现SDK存在一些问题，例如 使用方式，对接方式。因此我根据这些问题，将SDK进行了重构。</p>\n<h1 id=\"二-重构\">二. 重构</h1>\n<p>框架通过暴露全局函数的方式来暴露能力，第三方通过覆写对应的函数来实现能力的调用。</p>\n<p>我开发的SDK讲这些全局函数再次进行封装，通过 发布订阅 的设计模式进行通信。但是SDK 的暴露方式还是通过全局对象进行暴露，第三方在进行二次开发时，需要讲他们的JS 放到 我们的JS 逻辑之下才能运行。而且通\n过全局变量这种方式，无法进行友好的类型提示，根据文档进行开发，开发体验不是很友好。</p>\n<p>所以我对SDK进行了抽离，变为一个独立的 NPM 包。第三方开发时可以通过引入NPM包的形式进行开发。</p>\n<h2 id=\"2-1-环境\">2. 1 环境</h2>\n<ul>\n<li>构建工具 ： Vite</li>\n<li>插件： <a href=\"https://www.npmjs.com/package/rollup-plugin-typescript2\">rollup-plugin-typescript2</a></li>\n<li>语言：TypeScript</li>\n</ul>\n<p>使用 <code>rollup-plugin-typescript2</code> 可以在打包时生成 <code>.d.ts</code> 文件，其他人在使用我们的包时，通过JS开发也能获得类型提醒，使用体验十分的友好。</p>\n<h2 id=\"22-类型体操\">2.2 类型体操</h2>\n<p>其实通过 TypeScript 开发和 JavaScript 开发区别并不大，无非就是加一些类型注解。但是我之所以使用 TypeScript ，还是希望通过 TypeScript 强大的类型提示可以让用户减少看文档的时间。</p>\n<p>举个例子，SDK 通过 发布订阅 分发事件，不同的事件的返回值是不同的。 我想实现的效果是用户订阅不同的事件时，类型提醒可以返回对应事件的值。</p>\n<p>灵感来源： <a href=\"https://twitter.com/mattpocockuk/status/1549721729630625799\">https://twitter.com/mattpocockuk/status/1549721729630625799</a></p>\n<p>想法很简单，实现有点难。这里我参考了上面推文的例子：<a href=\"https://www.typescriptlang.org/play?#code/JYWwDg9gTgLgBAbzgMTgXzgMyhEcBEMAzgLQwQQA2ARgKaUz4DcAUCzAJ5i1wBCAhkVoAlCAFcYtKAGEIAO0zAA5nAC8cYbQDG0ACYAeIjCjA5SgDSI4Q-lC0ALAPwAua8dNKA2gF10APlYWHTkjOBB+AGsRcUkoNTh9ABVZBWU4WgAPSTldIj5BaIkpFMUlPwAKFjg4AH1g0tdkADoAOVscAHckkuU-cxYASjU-RCq4KFoYMSg5UerqpQhEiFck0SL0rNocvKiOCEw4ZPlSy0SAZVpbB3jj1K9E9clvT3wbO3t8bwqx+fGY2iuR4A-p-arvBwuI6Xa72TbZXJuExmHy-MGOKyeGEfAAKtn4eFM0KuH08cjEIDoUG83ihRmRKjQaL+rjktAAblJQfMhqoRghmXBKJM4GyOk8eOpzu4zOUcEUBoEwXBgIdyhD7EMBcrqmKJXAANTqMVwACqwgAMtiHHioASiJUdfMNXBBBptHpDDKLEiPH1BdUBk1yNKGeVFYKmcqOqZdBAOk1KBAtPwYMB5E17BNDsbaOKAaw-mhuWhWKW2MFQvLJHl1OEohKoOVtQQAPT4VwIYtjfCt3SCezUCC2XQdubOkkOVyvMD8JS0fCWfDcKB4+eLghEXCTeweL4l-poCMsau0IhNRbLcq9-tEQfDqCjywt2fz1z4ACMi7GW5AO4877fkegSnuel4QNe7YRkAA\">makeRouter</a>，这个例子通过 路由配置 让返回的路由实例能够正确提醒路由所对应的query.</p>\n<p>我最终实现的效果如下：</p>\n<pre><code class=\"language-ts\">import { F } from &quot;ts-toolbelt&quot;;\n\ntype BaseEventConfig = Record&lt;string, string[]&gt;\n\nconst makeEvents= &lt;TConfig extends BaseEventConfig&gt;(_config: F.Narrow&lt;TConfig&gt;) =&gt; ({\n    $on: &lt;EventName extends keyof TConfig, Response = TConfig[EventName]&gt;(eventName: EventName, callback: ResCallback&lt; Response extends string[] ? { [SearchParam in Response[number]]?: string } : never, EventName&gt; ):void =&gt; {\n    \n    }\n\n})\n\ntype ResCallback&lt;T, E&gt; = (e: {\n    data: T\n    preventDefault: () =&gt; void\n    type: E\n}) =&gt; void\n\n// test\n\nlet emitter = makeEvents({\n    &#39;page:change1&#39;: [&quot;pageName&quot;,&quot;pageParams&quot;,&quot;pageTitle&quot;,&quot;rid&quot;],\n    &#39;page:change2&#39;: [&quot;aadfa1&quot;,&quot;bbb1&quot;]\n})\n\nemitter.$on(&#39;page:change1&#39;, e =&gt; {\n    e.data.pageName\n    e.data.pageParams\n    e.data.pageTitle\n    e.data.rid\n})\n\nemitter.$on(&#39;page:change2&#39;, e =&gt; {\n    e.data.aadfa1\n    e.data.bbb1\n})\n</code></pre>\n<p>利用 类型收紧和泛型，我在 TypeScript 传入相关事件的配置，用户在使用时就能从不同的事件得到不通的类型提示，that&#39;s  cool!</p>\n<h2 id=\"23-使用场景\">2.3 使用场景</h2>\n<p>用户在使用SDK时一般有两种场景，一种是在现有HTML里嵌入自身逻辑，还有一种是通过 iframe 嵌入我们的物料，然后在 iframe 外部写自己的逻辑。</p>\n<p>第一种方式SDK是能够正常使用的，但是通过 iframe 方式，SDK并不能生效。因为我们的SDK是通过拦截 window 上的事件进行重写，在进行事件分发。iframe 模式的 window 并不一致，所以SDK无法正常使用。</p>\n<p>兼容也很简单，提供一个方法进行初始化</p>\n<pre><code class=\"language-ts\">SDK.init()\n</code></pre>\n<p>不传值的情况就使用当前 window，拦截相关函数。 传值时就传入对应的iframe DOM即可。</p>\n<pre><code class=\"language-ts\">SDK.init(iframe)\n//\ninit(iframe) {\n    let global = window\n    if(iframe) {\n        global = iframe.contentWindow\n    } \n    registProxy(global)\n}\n</code></pre>\n<p>这样我们的SDK既能支持当前物料的开发，也能支持iframe嵌入</p>\n<h2 id=\"24-发布\">2.4 发布</h2>\n<p>作为SDK,通过全局变量的形式暴露对于开发者是不友好的，更好的方式是发布到 npm 上提供给开发者下载</p>\n<ol>\n<li>注册账号，可以添加组织，让包名拥有scope</li>\n<li>package.json 配置包信息，入口文件</li>\n<li>配置.npmignore, 忽略上传文件</li>\n<li>npm login</li>\n<li>npm publish(组织包，需要执行 npm publish --access public)</li>\n</ol>\n<p>更新版本时，先 npm version patch 再 publish</p>\n<h1 id=\"三-文档\">三. 文档</h1>\n<p>其实有了 TypeScript 和相关注释，用户在进行开发时不借助文档也能够很好的开发。但是文档还是很重要的。</p>\n<p>当用户想接入我们的SDK时，他接触的第一个东西肯定是文档。文档可以告诉他 SDK 能够提供的能力，已经如何进行接入。</p>\n<p>写文档的确很烦，但当我们自己开发时又希望其他人写文档。很矛盾，又很真实。</p>\n<p>文档的结构我借鉴了常用的文档模式。</p>\n<ol>\n<li>功能介绍</li>\n<li>安装</li>\n<li>快速使用</li>\n<li>事件</li>\n<li>模块</li>\n</ol>\n<p>写完这些，快速对接基本上没啥问题了。</p>\n<h1 id=\"四-界限\">四. 界限</h1>\n<p>写 SDK 的主要目的时暴露自身的能力，因此我们需要注意能力的界限。</p>\n<p>例如用户在使用我们的SDK时想要进行数据埋点，获取访问用户的IP. 这个能力就不应该由我们提供，而是用户自己使用第三方库来开发。</p>\n<p>SDK的目的就是降低耦合，即使SDK内部有某些能力，但是我们也要考虑是否需要开放。</p>\n<h1 id=\"五-写在最后\">五. 写在最后</h1>\n<p>SDK 的开发经验还是很宝贵的，我也从中学习到了很多东西。我也通过这个业务将平时所学到的东西进行了实践。</p>\n",
        "title": "提供业务能力，SDK的开发（二）",
        "created": "2022-08-07 03:55:39  ",
        "updated": "2022-08-09 15:15:54 ",
        "excerpt": "一. 写在前面 之前文章讲了 SDK开发的背景，和具体封装的逻辑。最近有用户使用我的SDK进行二次开发，对接的过程中我发现SDK存在一些问题，例如 使用方式，对接方式。因此我根据这些问题，将SDK进行了重构。 二. 重构 框架通过暴露全局函...",
        "avatar": "https://avatars.githubusercontent.com/u/26271337?v=4",
        "id": "23"
    },
    "24": {
        "content": "<h1 id=\"写在前面\">写在前面</h1>\n<p>国庆假期基本没出去玩，学习了下Astro 和 Solid。这篇文章就来具体讲下 Solid  的开发体验，还有和Vue ,React的框架区别</p>\n<h1 id=\"react-like\">React Like</h1>\n<pre><code class=\"language-tsx\">const [count, setCount] = createSignal(0)\n</code></pre>\n<p>看到语法的第一眼，就会感到十分眼熟。这不是 React吗？ </p>\n<p>从语法上来说，Solid 和 React 十分相似，但确有根本上的不同。</p>\n<p>在 Solid 中声明响应式变量需要用到 <code>createSignal</code>.  与 React 的 <code>useState</code> 不同的是，返回的第一个值为函数，而不是一个值。</p>\n<p>React 为了实现组件中数据的更新，利用多次闭包加链表实现了 Hooks ,但是 Hooks 存在的闭包陷阱和必须顶层使用是无法进行避免的。</p>\n<p>Solid 中直接返回一个函数，使用函数获取真实的值，完全没有 React hook 存在的问题。这里有点像 Vue3 ，但是比 Vue3  更简洁。</p>\n<h1 id=\"reactive\">Reactive</h1>\n<p>在组件更新上，Solid的处理方式和 React 有很大的区别</p>\n<p>React 函数组件中， 通过 setState 触发函数再次执行函数，实现组件更新。</p>\n<p>而 Solid 函数组件中的代码只会执行一次，组件的更新依赖于响应式数据。Solid 实现了和Vue 类似的方式，进行了依赖收集。当数据变化时，组件就会进行更新。</p>\n<pre><code class=\"language-tsx\">...\nconst [count, setCount] = createSignal(0)\n\nreturn &lt;div onClick={() =&gt; setCount(prev =&gt; prev+1)}&gt;{count()}&lt;/div&gt;\n...\n</code></pre>\n<p>由于是直接使用函数，<code>useMemo</code> 在Solid 中变得很简单</p>\n<pre><code class=\"language-tsx\">const [count, setCount] = createSignal(0)\nconst doubleCount = () =&gt; count() * 2\n\nreturn &lt;div onClick={() =&gt; setCount(prev =&gt; prev+1)}&gt;{doubleCount()}&lt;/div&gt;\n</code></pre>\n<p>不得不说，这样的实现十分优美</p>\n<h1 id=\"❌-virtual-dom\">❌ Virtual DOM</h1>\n<p>Solid 还比较不同的地方，就在于DOM的更新策略上。</p>\n<p>Solid 并没有使用 虚拟DOM, 而是基于真实DOM进行操作。Solid 将DOM的变化颗粒化，响应式数据的变化只对依赖的Node起作用。而不是像虚拟DOM 一样组件重新更新再比较差异进行 patch</p>\n<p>这是一段Solid 代码</p>\n<pre><code class=\"language-tsx\">function Counter() {\n    const [count, setCount] = createSignal(0);\n    const increment = () =&gt; setCount(count() + 1);\n      \n    return (\n    &lt;button type=&quot;button&quot; onClick={increment}&gt;\n        {count()}\n        &lt;span&gt;{count() * 2}&lt;/span&gt;\n    &lt;/button&gt;\n    );\n\n}\n</code></pre>\n<p>编译后的代码</p>\n<pre><code class=\"language-ts\">const _tmpl$ = /*#__PURE__*/template(`&lt;button type=&quot;button&quot;&gt;&lt;span&gt;&lt;/span&gt;&lt;/button&gt;`, 4);\nfunction Counter() {\n    const [count, setCount] = createSignal(0);\n    const increment = () =&gt; setCount(count() + 1);\n    return (() =&gt; {\n        const _el$ = _tmpl$.cloneNode(true),\n        \n        _el$2 = _el$.firstChild;\n        \n        _el$.$$click = increment;\n        \n        insert(_el$, count, _el$2);\n        insert(_el$2, () =&gt; count() * 2);\n    return _el$;\n    })();\n\n}\n</code></pre>\n<p>这里我们可以看出，其实函数组件就返回了一个DOM。后续数据的变化只会影响到收集到DOM，这一点十分巧妙。</p>\n<h1 id=\"写在最后\">写在最后</h1>\n<p>使用过Vue, React后，来学习 Solid 有一种奇妙的感觉。Solid 使用了两个前辈的各自优点，又有自己的独特之处。</p>\n<p>第一眼看到 Solid 时，感觉是React. 具体进行使用时，又感觉是 Vue. 到了最后，才发现Solid 就是 Solid.</p>\n<p>这篇文章大概讲了下 Solid, 其实也没有讲具体用法。后续会更新具体的使用和相关生态。</p>\n",
        "title": "Solid 使用体验",
        "created": "2022-10-07 12:50:24  ",
        "updated": "2022-10-07 12:50:24 ",
        "excerpt": "写在前面 国庆假期基本没出去玩，学习了下Astro 和 Solid。这篇文章就来具体讲下 Solid 的开发体验，还有和Vue ,React的框架区别 React Like `tsx const [count, setCount] = cr...",
        "avatar": "https://avatars.githubusercontent.com/u/26271337?v=4",
        "id": "24"
    },
    "25": {
        "content": "<p>WIP</p>\n",
        "title": "Module Federation 详解",
        "created": "2022-10-24 11:50:59  ",
        "updated": "2022-10-24 11:50:59 ",
        "excerpt": "WIP",
        "avatar": "https://avatars.githubusercontent.com/u/26271337?v=4",
        "id": "25"
    }
}