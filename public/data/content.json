{
    "1": "<h3 id=\"写博客的原因\">写博客的原因</h3>\n<p>主要是对自己平时的工作做技术沉淀，用有道云笔记其实也够用。但是我还是希望能够在公共平台进行发布，希望自己遇到的一些问题和解决方案可以对其他人有些帮助。</p>\n<h3 id=\"技术选型\">技术选型</h3>\n<p>对自己的技术博客选型了很久，最后还是选择了github。主要原因还是因为懒，github issues作为CMS完全够用了。后续配合SSG生产静态网页是比较好的方案了。</p>\n<h3 id=\"写在最后\">写在最后</h3>\n<p>现在是2022年的1月，希望从今年开始能够经常进行写作，提高自己的文字表达能力。</p>\n",
    "2": "<p>现代前端开发都讲究模块化开发，作为打包界的扛把子，Webpack对与整个前端生态有着巨大的影响。但是随着Vite,ESBuild等后起之秀的崛起，webpack本身存在的问题就愈发明显。无论是繁琐的配置文件，还是奇慢无比的构建速度都令人望而却步。 </p>\n<p>Webpack官方也知道自身的问题，于是Webpack 5 来了</p>\n<h1 id=\"1-它的变化\">1. 它的变化</h1>\n<p>版本来到了5，Webpack有了以下这些变化：</p>\n<h2 id=\"11-基于文件系统的缓存\">1.1 基于文件系统的缓存</h2>\n<p>新增的缓存的功能让开发者在首次构建后享受缓存带来的构建速度提升（是的，首次还是很慢），实际测试后，无论是直接构建还是热更新开发，首次之后的重新构建时间只有几秒，热更新甚至少于1s.</p>\n<p>开启了这个功能之后，会在文件下多一个的文件夹，里面会存放之前构建产生的缓存。但是这个功能还是存在问题，由于缓存的存在，<strong>新添加的插件或者热更新被打断后重新运行都有几率报错</strong>。遇到这个问题，删除文件夹就好了\n<img src=\"https://user-images.githubusercontent.com/26271337/168218613-bf34cc73-facf-4c9c-a66c-f0c73ba3fdd5.png\" alt=\"image\"></p>\n<h2 id=\"12-asset-modules\">1.2 Asset Modules</h2>\n<p>Webpack 5 新增了Asset Module,取代了之前版本需要下载的  , .</p>\n<p>Asset Modules总共有四种类型</p>\n<ol>\n<li><p>asset/resource </p>\n<p> 用于文件的处理，替换了</p>\n</li>\n<li><p>asset/inline </p>\n<p>   替换了 , 会将文件转化为data URL</p>\n</li>\n<li><p>asset/source </p>\n<p> 替换了  ,会直接导入文件的内容</p>\n</li>\n<li><p>asset (默认)</p>\n<p> 会自动选择生产文件还是生成data URL, 可以进行设置maxSize来进行判断处理</p>\n</li>\n</ol>\n<p>因为Webpack 内置了这个所以之前的  等依赖也无法在Webpack 5下生效</p>\n<h2 id=\"13-module-federation\">1.3 Module Federation</h2>\n<p>Webpack 5的更新中，这个功能最有用（我说的）。Module Federation 即模块联邦，在配置文件中配置后可以让当前项目共享其他项目的代码，也可以共享本身的代码给其他服务。 </p>\n<p>在实际使用中就可以用来做组件库，然后共享给所有项目。完美解决了以往通用组件库存在的痛点，即每次更新后，所有使用到组件库的服务都需要重新进行依赖下载和构建。 而Module Federation只用构建组件库即可，依赖组件库的服务可以直接使用到最新的组件。</p>\n<p>Module Federation 的配置如下</p>\n<p>microFE@<a href=\"http://localhost:7777/remoteEntry.js\">http://localhost:7777/remoteEntry.js</a></p>\n<p>服务本身要切换成动态导入的模式</p>\n<p>Module Federation 本身的原理还是很简单的，就是利用动态导入打包成单独的包，然后其他服务使用时通过url加载对应的bundle即可。有了这个特性无论前端框架是什么，都可以做到组件共享。</p>\n<p>然后讲一下配置项</p>\n<ul>\n<li>name: &#39;service-name&#39;  定义服务的名称</li>\n<li>remotes  共享的服务的地址</li>\n<li>shared 声明公用的依赖</li>\n<li>exposed 声明暴露给其他服务使用的模块</li>\n<li>filename 服务构建后生产的单独文件，用于其他服务remotes使用</li>\n</ul>\n<h1 id=\"14-其他修改\">1.4 其他修改</h1>\n<p>Webpack 5还有很多其他的修改，例如一些配置项的更改, 内置了Terser进行代码压缩等。</p>\n<h1 id=\"2-存在的问题\">2. 存在的问题</h1>\n<p>新的版本，新的功能。总的来说对于开发者的使用体验有了很大的提升。</p>\n<p>在升级的过程中，我发现了一些问题：</p>\n<ol>\n<li>plugin 的写法还是过于复杂，用户自定义插件开发体验还是很糟糕</li>\n<li>首次构建速度变慢了，因为内置了Terser</li>\n<li>引入的缓存系统导致构建时的报错</li>\n</ol>\n",
    "4": "<h1 id=\"tldr\">TL.DR</h1>\n<p>前端开发已经几年了，对于业务场景中的组件开发也有自己的一些心得。平时开发中遇到的痛点和疑惑之处也常常令我烦躁。因此下文将谈谈我对组件开发和设计的理解。</p>\n<h1 id=\"1-what-why\">1. What? Why?</h1>\n<p>组件化就是将业务逻辑进行抽离，将不同的业务逻辑抽离成不同的文件，避免代码的耦合，方便复用和维护。</p>\n<h2 id=\"11-抽离，降低耦合\">1.1 抽离，降低耦合</h2>\n<p>平时开发中接手和维护旧代码，遇到上千行的组件，整个人都快要昏厥了。</p>\n<p>举个例子，常见的表格数据展示页面会伴随着相关的数据操作。不同的操作往往会有不同的数据和接口处理，这个时候将对应操作的弹窗抽离为单个组件，将相关的数据隔离在组件中，对主组件的影响尽量降低是比较好的做法。 </p>\n<p>反例则是将数据的新增，编辑等弹窗操作，状态都维护在主页面中。后期的需求变更和数据更迭会让当前页面的逻辑越来越混乱。</p>\n<h2 id=\"12-复用，dry\">1.2 复用，DRY</h2>\n<p>复用其实大家都很能理解，平时使用的UI库都是复用的组件。对于平时开发的组件，我习惯分为业务组件和通用组件。</p>\n<p><strong>通用组件</strong>就是基本的组成元素，例如表单，按钮等。对于我们的业务系统，沉淀出自己的通用组件库，对于业务设计系统的一致性有很大的用处。如果一个app的各种按钮和输入都不一致的话，可能没什么用户想去使用。 </p>\n<p><strong>业务组件</strong>就是针对当前业务的组件，例如开发时需要付款码弹窗，好的方法是抽离为一个独立的组件，在不同需要调用支付的地方进行使用，而不是在每个支付的地方都重写相关的逻辑。这样后续更改付款码的逻辑，例如接口调用或者校验之类的都十分方便。</p>\n<p>整个世界都是熵增的，再基础的业务随着不断的的迭代，都会变得越来越复杂。作为开发人员，应该严格要求自己。对于新开发的功能，要想如果移除这个功能所需的时间和代码改动是否合理，当前的结构是否满足新的需求，这些都是需要去好好思考的。开发时间和开发质量很多时候并不是取舍的问题，在屎山上拉屎是避免不了的，但是在前期可以避免但是为了省事而挖更多的坑简直就是 👎</p>\n<h1 id=\"2-how\">2. How?</h1>\n<p>开发人员如何去拆分组件呢？我的方法是找</p>\n<ol>\n<li>以页面作为基本单位，如果几个页面都有相同的部分，那么可以考虑抽离公用；</li>\n<li>如果某个部分的业务逻辑相对独立，只需要当前页面提供很少的信息，那么请抽离。</li>\n<li>细化组件的功能，不要负责太多的逻辑。不同场景对应不同的组件，比拥有不同场景的组件要好的多，UI要公用，逻辑要少混用。</li>\n</ol>\n<p>其实组件拆分并不麻烦，不同的开发人员有不同的理解。最好的准则就是 。</p>\n<h1 id=\"3-在框架上的体现\">3. 在框架上的体现</h1>\n<p>前端的框架有很多，都支持组件化的开发。由于框架本身的实现原理和设计风格不一样，我们在用不同的框架进行开发时也会有对应的开发心得。</p>\n<p>每个框架都有自己的特点，组件中的通信，数据传递都有差异。后面我会有对应框架的文章来介绍它们各自的优缺点。</p>\n",
    "5": "<h1 id=\"tldr\">TL,DR</h1>\n<p>Vue2 作为平时开发中最常用的框架，我在进行业务开发时对于组件拆分和设计还是比较有心得的。开发体验也还算友好，但是还是存在很多问题。本文会介绍一些常用的技巧和框架本身存在的一些问题。</p>\n<h1 id=\"一-基本知识\">一. 基本知识</h1>\n<h2 id=\"11-组件使用\">1.1 组件使用</h2>\n<p>Vue中组件使用十分的简单，++，当然也可以在全局中进行注册。</p>\n<h2 id=\"12-组件开发\">1.2 组件开发</h2>\n<p>在开发中，Vue的每个 都是一个组件。Vue2 通过声明Options来定义组件。</p>\n<h2 id=\"13-状态管理\">1.3 状态管理</h2>\n<p>在组件中，我们在数据变化后更新 View , View 控制数据的变化,   可以简单概述组件中整体变化的一个过程。</p>\n<p>但是在实际的开发场景中，往往是多个组件公用一些状态，可能是兄弟组件，也有可能是层级差别较大的组件。</p>\n<p>如果涉及组件较少，也能够用。如果需要共享数据的组件较多的话，选择状态管理库会比较合适。</p>\n<h1 id=\"二-高级技巧\">二. 高级技巧</h1>\n<p>没错，稍微讲下基础知识就直接来到高级技巧了。</p>\n<h2 id=\"21-extends\">2.1 extends</h2>\n<blockquote>\n<p>优雅其实很简单</p>\n</blockquote>\n<p>当我们平时使用UI库时会根据业务需求进行改造组件，简单的样式更改通过样式穿透和重置就能处理。对于业务逻辑的修改，很多同学可能会直接复制文件进行更改，这是一个办法。</p>\n<p>之前项目时，我通过手动实现方法继承和覆盖，但还是比较的麻烦</p>\n<p>使用 就很简单，<a href=\"https://v2.vuejs.org/v2/api/#extends\">extends</a> 的用法就是扩展一个组件</p>\n<p>通用extends就是继承一个组件，可以覆盖和扩展一些方法,当然也可以更改视图的一些展示。</p>\n<h2 id=\"22-mixin\">2.2 Mixin</h2>\n<blockquote>\n<p>逻辑隔离还是公用，它都可以</p>\n</blockquote>\n<p> 常用来做一些逻辑的抽离。这里我举一个我实际开发中的使用场景。 </p>\n<p>eg: 当前有一个列表展示数据，每个数据都有10几种操作，会调用不同的弹窗，接口，提醒等。与此同时列表还要支持两种展示方式，卡片和Table.</p>\n<p>在这个需求里，我通过minix对每一种操作进行拆分，每一个操作都是单独的mixin。每个minxin里面都包含操作对应的展示校验逻辑和实际的业务逻辑。</p>\n<p>对于每个mixin中的公用的函数和状态，就放在混入的组件中，进行公用即可。</p>\n<p>最后将所有操作形成的数组传入到列表的展示项中，实现了不同的展示形式公用相同的逻辑，避免了代码的重复。</p>\n<p>好处： 不同的业务逻辑进行了隔离，避免了组件的膨胀，很好的支持修改和扩展</p>\n<p>坏处： minix的缺点也比较明显，只能公用逻辑。视图还是需要放到主组件中，这会造成视图和逻辑分离的问题。因此在进行视图操作和公用状态的处理时，需要进行仔细核对。</p>\n<p>实际场景中可以根据需求封装mixin, 可以封装成函数处理不同数据的场景，可以在mixin中开发公用的逻辑，维护公用的状态。</p>\n<h2 id=\"23-vueextend\">2.3 Vue.extend</h2>\n<blockquote>\n<p>说是银弹，未尝不可 </p>\n</blockquote>\n<p>在使用Element-ui时，我们可以通过函数的形式调用组件。在翻看代码后，我知道了Vue.extend这个方法。其实Vue源码中，Vue组件在实际使用时也会通过这个方法进行组件的生产，这里我们就不深入聊下去了。</p>\n<p>介绍下这个方法，Vue.extend可以将组件转化为一个构造函数，通过实例化构造函数，就能生成组件。</p>\n<p>因此我们可以通过Vue.extend将对应的组件转化构造函数，然后封装一个函数进行组件的生成，挂载和更新等操作。常用的一些弹窗组件都可以通过这种形式进行开发</p>\n<p>当然你也可以通过 闭包实现单例和组件更新等逻辑，根据具体场景进行使用。非常好用</p>\n<p>关于Vue.extend的坑，我也专门有进行总结，<a href=\"https://github.com/vivipure/TIL/issues/8\">链接在这</a></p>\n<h2 id=\"24-slot\">2.4 Slot</h2>\n<blockquote>\n<p>基本知识，你知我知</p>\n</blockquote>\n<p>插槽其实也不用多介绍了，更多的场景还是布局的复用。知道具名插槽，默认插槽和作用域插槽各种使用方法即可</p>\n<h2 id=\"25-v-model\">2.5 v-model</h2>\n<blockquote>\n<p>表单再复杂，有它我不怕</p>\n</blockquote>\n<p>在Vue中我们可以通过v-model指令实现双向绑定。它的原理其实也很简单，其实就是作为语法糖封装了value和updateValue的逻辑。</p>\n<p>在Vue中也允许我们自定义v-model。</p>\n<p>通过model声明组件v-model绑定的值和更新值的事件即可。 因此在做一些富文本输入框，图片上传组件之类输入的组件时，使用v-model会比较合适。</p>\n<p>在我平时的开发中，我会用来做表单的抽离。例如</p>\n<p>当新增的组件需要改好几个值时，也能通过这种方式进行开发，v-model支持更改对象。不过我常常使用data保存对应的引用值直接进行更改，不会进行报错，也比较简单。</p>\n<p>同时注意watch下props传入的值，数据更改后要即使更改data中的值。还有分发事件时，要先触发model的事件，在分发change的事件，不然外部在使用change时拿不到正确的值。</p>\n<p>如果你像我一样在表单中使用的话，记得写验证和清除验证相关的方法供父组件进行使用</p>\n<h2 id=\"26-directives\">2.6 directives</h2>\n<blockquote>\n<p>指令：执行</p>\n</blockquote>\n<p>自定义指令的具体写法我就不写了，也很简单。说一下常用的场景吧，例如对dom的一些操作，输入处理，还有事件绑定都可以通过指令的方式进行处理。</p>\n<p>我的开发中就使用过埋点，拖拽，节流等指令。</p>\n<p>这里需要注意一个点，如果指令需要维持一些数据的话，可以绑定到el上。</p>\n<h2 id=\"27-providereject\">2.7 provide/reject</h2>\n<p>可以通过provide和reject让组件跨级别共享状态，类似React.context. </p>\n<p>如果需要往自组件传递太多的数据，可以考虑用这种方式，而不是用</p>\n<ol>\n<li>需要注意的是如果组件之间存在其他的provide和reject会使reject受到最近的的provide数据。</li>\n<li>共享的数据不是响应式的，可以通过函数的方式进行获取</li>\n</ol>\n<h1 id=\"3-还有点东西\">3. 还有点东西</h1>\n<ol>\n<li>弹窗组件最好放在body下，毕竟fixed会受到css样式的影响，要保证好遮罩层的层级</li>\n<li>弹窗组件如果不是必要，就单独放一个文件吧</li>\n<li>别让组件拥有太多状态，而是不同状态对应不同的组件</li>\n<li>如果一个值传递的层级太深，就把它放到全局状态吧</li>\n</ol>\n<h1 id=\"4-最后再说说\">4. 最后再说说</h1>\n<p>Vue2作为渐进式框架，无论是小应用还是大应用，组件开发是完全能够cover的住的。</p>\n<p>但是Vue Options Api中数据和方法的隔离【物理行数的隔离】导致可读性较差。</p>\n<p>与此同时TS支持较弱，导致开发时组件的传值无法智能提醒。</p>\n<p>mixin不是好的实现方式，视图和数据的分离导致可读性变差。</p>\n<p>好在Vue3来了，TS + Composition Api 让开发体验大大提升，后面将会有文章介绍下Vue3的相关特性。</p>\n",
    "6": "<h1 id=\"1-我的疑问\">1. 我的疑问</h1>\n<p> 1.1 是怎么保证每个组件都可以进行访问的\n 1.2. 为什么需要Mutation,而不是直接使用Action\n 1.3. mapState等方法是怎么映射到组件的\n 1.4. 怎么和Vue的响应式结合起来的\n 1.5. 插件的实现【兴趣不大】\n 1.6. 模块的实现【兴趣不大】</p>\n<p>带着我的疑问，现在就开搞！</p>\n<h1 id=\"2--基本介绍\">2.  基本介绍</h1>\n<p><img src=\"https://vuex.vuejs.org/vuex.png\" alt=\"流程图\"></p>\n<p> 的核心就是一个 , 管理着应用的全局状态。组件从  中读取数据，当   中数据变化时，组件也会一起更新。\n 中的数据需要通过  进行显示更改，当然根据实际业务直接更改对象类型的  其实也可以。显示更改更方便我们定位问题和在  中进行展示</p>\n<p>项目地址：<a href=\"https://github.com/vuejs/vuex\">https://github.com/vuejs/vuex</a>\n构建工具： Rollup\n入口文件：src/index.js</p>\n<p>由于平时使用的3.x版本的  ,所以分支为 <strong>v3.6.2</strong></p>\n<h1 id=\"3-初始化\">3. 初始化</h1>\n<p>回想下平时我们是怎么使用Vuex, 我们使用  安装了  插件，然后通过\n然后再来看  导出的相关包</p>\n<p>首先我们查看入口文件文件</p>\n<p> 就是我们初始化的类， 就是  安装的逻辑，还有平时使用到的一些辅助函数。</p>\n<h2 id=\"31-vuex初始化\">3.1 Vuex初始化</h2>\n<p>看下 的逻辑</p>\n<p>在执行时会往  中混入一些逻辑，2.0中混入了  函数的逻辑</p>\n<p>而  中的逻辑就是混入, 保证应用下的组件都可以访问到  。</p>\n<p>通过这里的逻辑就能解答我的[第一个疑问]了</p>\n<h2 id=\"32-store初始化\">3.2 Store初始化</h2>\n<p>Store初始化主要分为：</p>\n<ol>\n<li>Module注册，处理嵌套逻辑，形成tree</li>\n<li>Module安装，初始化 state,getters等</li>\n<li>初始化Store.vm</li>\n</ol>\n<h3 id=\"32-1-module注册\">3.2. 1 Module注册</h3>\n<p>初始化时我们会传入一个对象，里面包含 ,, 等属性。现在我们就来看看  这个类.</p>\n<p>整个  可以视为 Store的 root module, 在ModuleCollection中进行解析，如果有嵌套的 module ,该方法也会进行处理\n看一下模块注册的逻辑</p>\n<p>其中  为  的路径， 为配置项，  为是否运行时创建的模块。</p>\n<p>通过 Module 类中对模块进行初始化，判断当前  的长度，若为0则称为 , 否则就找到 父模块调用  方法形成父子逻辑。</p>\n<p>这样子模块可以通过路径找到父模块，父模块可以通过   找到子模块</p>\n<h3 id=\"322-module安装\">3.2.2 Module安装</h3>\n<p>这个方法的核心逻辑为</p>\n<p>在  方法中实现上下文的注册，上下文包括了 ,  , ,  等。这几个属性除了  都处理了  的情况。这里讲一下  的获取逻辑就好了</p>\n<p> 从 开始，层层查找子模块 ，最终找到目标模块的 .</p>\n<p> ,  等方法完成对 ,  的注册</p>\n<h3 id=\"323-初始化storevm\">3.2.3 初始化Store.vm</h3>\n<p>resetStoreVM的具体逻辑是这样的</p>\n<p>这里的流程就是从  中取出对应  函数，挂在到 中，同时存入  中，通过  的  ,和  产生依赖关系</p>\n<p> 然后  的  的  是这么设置的</p>\n<p>因此获取  时，实际上访问的是vm的</p>\n<p>总体的逻辑来说就是这样的\nkeystore.gettersgetterstore._vm[key]computed[key]computed[key]rawGetter(local.state,...)store.statestore._vm._data.1609statestore.statestore.getters</p>\n<p>在上面的代码中还有 严格模式的校验\ndo not mutate vuex store state outside mutation handlers.\n如果处于严格模式,就会手动添加一个 同步的, 监听的变化是否是  改变的，</p>\n<p>_withCommit方法保证了通过Vuex自身提供的方法改变数据才能使  为 </p>\n<p>读到这里，关于 [1.4]和[1.6]的问题，已经有了答案，响应式是通过  实现的，模块是  的基本单位，兼容层级的嵌套和命名空间。</p>\n<h1 id=\"4-api\">4. API</h1>\n<p>在 store 的初始化过程中完成了数据的存储，接下来就是通过 API来进行使用了。</p>\n<h2 id=\"41-mutation--commit\">4.1 Mutation &amp; commit</h2>\n<p>在初始化时，我们进行了 mutation 方法的初始化，可以通过 mutation 进行 state 的更改。</p>\n<p>这里我们也能明白在  中改变的数据是当前模块的数据，访问的  是  . 然后将每个  存入到 中</p>\n<p>然后我们再看看 commit, store 提供 commit 来提交 commit</p>\n<p>从这里可以看出，mutation必须是同步的，不然下面通知 订阅者 的逻辑会出错</p>\n<h2 id=\"42-action--dispatch\">4.2 Action &amp; dispatch</h2>\n<p>Action 和 Mutation的区别就是 Action是异步的，所以它们大部分逻辑还是差不多的，只是在异步处理和通知上有区别</p>\n<h2 id=\"42-mapstate\">4.2 mapState</h2>\n<p>在 中</p>\n<p>这里的主要逻辑是 得到一些getter函数，其中也包括对一些命名空间的处理。这里兼容了val是函数还是字符串的情况。</p>\n<p>接下来我们看看  函数干了啥，</p>\n<p>其实对于 做处理，拿到斜杠前的命名空间 然后对函数进行包裹，兼容传命名空间和不穿命名空间的两种情况。</p>\n<h2 id=\"43-mapmutations\">4.3 mapMutations</h2>\n<p>其实  的逻辑和  差不多，这里讲一下核心的逻辑就好了</p>\n<p>其他的 ,  的逻辑都与其类似。 </p>\n<h1 id=\"5-插件\">5. 插件</h1>\n<p>插件平时用的还是很少的，也就学习教程时知道一个  插件，还有 的插件。\n现在就顺便研究下插件机制, 显示插件激活</p>\n<p>代码其实就是将  传递给插件，然后插件调用  订阅  事件，或者订阅  事件。</p>\n<p>看了这么多源码，想一下 持久化插件会怎么做呢？ </p>\n<p>我觉得可以在每次数据改变后 将当前  存到  中，当  在激活插件时，从  中拿到旧的数据，然后改变 </p>\n<p>看了下源码果然逻辑差不多 <a href=\"https://github.com/robinvdvleuten/vuex-persistedstate/blob/master/src/index.ts\">Vuex-persistedstate</a></p>\n<h1 id=\"6-总结\">6. 总结</h1>\n<p>看完源码后我的6个疑问解决了5个，收获还是很大的。对于自己平时的开发，如果状态比较多的话，子模块和命名空间的确很好用。毕竟 Vuex 花了很大精力去处理这块逻辑。</p>\n<p>还有插件的设计，也让我学会了如何去制作 Vuex 插件和 设计插件系统</p>\n<p>当然还有最后的疑问，为啥需要Mutation，而不是直接使用Action呢？像 <a href=\"https://pinia.vuejs.org/\">pinia</a> 中就放弃了Mutation.</p>\n<p>我其实也有了答案，正如作者说的，Mutation其实是为了更好的追踪状态的改变，方便devtools去捕捉，同时数据更改后能够及时同步插件，保证插件获取的数据是正确的。</p>\n<p>当然直接使用Action也是可以，因为Action也能够通知订阅者。且用户直接更改数据也不会影响响应式的功能。所以这也是为什么 Mutation 被放弃的原因。</p>\n",
    "7": "<h2 id=\"1-为什么要学习源码\">1. 为什么要学习源码</h2>\n<p>就现有的前端框架来说，阅读源码其实是困难的。例如Vue,React, 这些工业框架为了处理各种边界情况，会让代码变得不那么清晰。而我们在进行学习时就需要从繁到简，理清核心逻辑，学习核心原理。</p>\n<p>至于学习框架的原因，也很简单。我自己有三大理由</p>\n<ol>\n<li>面试，开卷就是了</li>\n<li>学习优秀的代码结构和逻辑</li>\n<li>增加开发能力，了解原理后能够更好的进行开发和优化</li>\n</ol>\n<h2 id=\"2--如何去学习源码\">2.  如何去学习源码</h2>\n<p>如何去学习源码途径有很多，图省事和囫囵吞枣就可以直接看其他人的文章或者视频。这种效率最高，以面试作为需求的完全可以通过这种方式进行学习。</p>\n<p>我个人比较习惯带着问题去看源码，以<strong>什么是怎么实现的</strong>的疑问去阅读源码其实效率还是很高的。无论是阅读范围还是阅读收获都有一个可以量化的区间，不会陷入到无处下手的地步。</p>\n<p>我后面的相关文章也会带着疑问去进行学习。与此同时，我也会对源码中引用的一些第三方库和插件进行总结，方便后续自己使用</p>\n<h2 id=\"3-系列\">3. 系列</h2>\n<ol>\n<li><a href=\"https://github.com/vivipure/blog/issues/6\">Vuex源码学习</a></li>\n</ol>\n",
    "8": "<h1 id=\"1-我的疑问\">1. 我的疑问</h1>\n<p>Vue Router 的使用频率还是很高的，作为开发者，我们可能知道 hash路由和 history路由 的区别和实现原理。但是一些还是东西是值得理解的。</p>\n<ol>\n<li>内置组件 router-view 是怎么实现的</li>\n<li>路由守卫是怎么实现的</li>\n<li>和Transition是怎么搭配合作的</li>\n<li>routes 数据是怎么解析的</li>\n<li>和keep-alive 是怎么配合</li>\n</ol>\n<h1 id=\"2-基本介绍\">2. 基本介绍</h1>\n<p>这里就不介绍基本的使用</p>\n<p>项目地址：<a href=\"https://github.com/vuejs/vue-router\">https://github.com/vuejs/vue-router</a>\n构建工具： Rollup\n入口文件：src/index.js</p>\n<h1 id=\"3--入口文件分析\">3.  入口文件分析</h1>\n<h2 id=\"31-install\">3.1 install</h2>\n<p>看下 install 函数执行的逻辑</p>\n<p>相关注释我都写在代码中了，主要逻辑就是在组件中混入了路由的属性，定义全局的属性，注册了两个内置组件。</p>\n<p>这里比较巧妙的是通过树形结构的特性，保证了拥有  的组件进行了路由初始化，子组件根据父组件层层查找，找到离自己最近的带有  的组件。</p>\n<p>然后  方法暂时不知道用法，</p>\n<h2 id=\"32-vuerouter\">3.2 VueRouter</h2>\n<p> 类在  中，默认导出的就是 , 我们在业务开发时也通过实例化  来生成  给应用使用。</p>\n<h3 id=\"321-构造函数\">3.2.1 构造函数</h3>\n<p>invalid mode: </p>\n<p>这里主要的逻辑就是通过 生成 , 和通过路由模式生成对应的 对象. \n通过这里我才知道原来 路由还有  模式, 提供给服务端或者ssr模式使用，应该和V4版本的 是一样的。</p>\n<h3 id=\"322-init\">3.2.2 init</h3>\n<p>在 的过程中， 往  中  逻辑, 对有  的  进行了路由初始化</p>\n<p>因此我们再看看  的  方法</p>\n<p>初始化时将当前组件进行保存，将<strong>当前路由</strong>切换到<strong>当前链接</strong>对应路由，也设置了订阅，当  改变时，会更新组件的 Kernel IP routing table\nDestination     Gateway         Genmask         Flags Metric Ref    Use Iface\ndefault         _gateway        0.0.0.0         UG    100    0        0 eth0\n10.1.0.0        0.0.0.0         255.255.0.0     U     0      0        0 eth0\n168.63.129.16   _gateway        255.255.255.255 UGH   100    0        0 eth0\n169.254.169.254 _gateway        255.255.255.255 UGH   100    0        0 eth0\n172.17.0.0      0.0.0.0         255.255.0.0     U     0      0        0 docker0。</p>\n<h3 id=\"323-transitionto\">3.2.3 transitionTo</h3>\n<p>看下  的实际逻辑</p>\n<p>这里主要执行  方法，主要逻辑分为几步：</p>\n<ol>\n<li>检查是否重复路由，进行处理</li>\n<li>用  筛选出当前路由和跳转路由的差异</li>\n<li>然后对迭代一个队列，队列包含<ol>\n<li>激活失效组件  路由守卫</li>\n<li>全局路由 </li>\n<li>重用组件  路由守卫</li>\n<li>激活路由 配置的</li>\n<li>处理异步组件加载逻辑\n如果顺序执行中有一个任务失败，则不会继续下面的任务</li>\n</ol>\n</li>\n<li>队列跑完之后，执行新的队列任务。队列包括<ol>\n<li>激活组件的  </li>\n<li>全局路由的<br> 执行完成后，在  后执行路由完成后的回调操作，调用全局的  钩子。</li>\n</ol>\n</li>\n</ol>\n<h3 id=\"324-matcher\">3.2.4 matcher</h3>\n<p>上面的路由切换方法中，进场会比较 Kernel IP routing table\nDestination     Gateway         Genmask         Flags Metric Ref    Use Iface\ndefault         _gateway        0.0.0.0         UG    100    0        0 eth0\n10.1.0.0        0.0.0.0         255.255.0.0     U     0      0        0 eth0\n168.63.129.16   _gateway        255.255.255.255 UGH   100    0        0 eth0\n169.254.169.254 _gateway        255.255.255.255 UGH   100    0        0 eth0\n172.17.0.0      0.0.0.0         255.255.0.0     U     0      0        0 docker0 的  属性，而在构造函数中也有</p>\n<p>因此我们来研究下 </p>\n<p>首先是根据传入的  通过  解析为  和  .</p>\n<ul>\n<li>将用户传入的配置进行遍历，对每个路由生成 RouteRecord 存放到 pathList</li>\n<li>pathMap, nameMap 是存放了 path 和 name 对 RouteRecord 的映射</li>\n</ul>\n<p>在平时的业务开发中，路由的配置不是固定的，根据用户的权限生产对应的路由才是合理的。因此会使用两个方法：</p>\n<ol>\n<li><p>addRoutes</p>\n</li>\n<li><p>addRoute</p>\n</li>\n</ol>\n<p>逻辑都很简单，直接调用  的方法即可。在添加单个 Kernel IP routing table\nDestination     Gateway         Genmask         Flags Metric Ref    Use Iface\ndefault         _gateway        0.0.0.0         UG    100    0        0 eth0\n10.1.0.0        0.0.0.0         255.255.0.0     U     0      0        0 eth0\n168.63.129.16   _gateway        255.255.255.255 UGH   100    0        0 eth0\n169.254.169.254 _gateway        255.255.255.255 UGH   100    0        0 eth0\n172.17.0.0      0.0.0.0         255.255.0.0     U     0      0        0 docker0 时则会处理父级路由和别名的相关逻辑。</p>\n<p> 的返回值中还包括  方法, 通过这个方法将  转化为 . 这里的  就是我们平时使用 push 等方法传入的参数。</p>\n<p>现在看看 match 方法的执行逻辑\nRoute with name &#39;&#39; does not existnamed route </p>\n<ul>\n<li>如果  包含  那么在  中通过  取到路由</li>\n<li>如果包含  则通过遍历  ， 正则匹配到对应的路由\n从这里我们可以知道，如果传递  来获取路由是比较方便的， 的话会进行比较匹配，写在前面会被优先匹配到的</li>\n</ul>\n<p>最终的到的东西就是一个 Route对象</p>\n<p>由于 这个对象最终被 Object.freeze() ,因此实际使用时，我们无法更改上面的属性</p>\n<h1 id=\"4-内置组件\">4 内置组件</h1>\n<h2 id=\"4-1-router-link\">4. 1 router-link</h2>\n<p>router-link 自动处理了 a 标签 点击跳转的情况，在点击时会触发路由跳转的事件</p>\n<h2 id=\"42-router-view\">4.2 router-view</h2>\n<p>主要逻辑就是：</p>\n<ol>\n<li>标识当前路由为 routerview</li>\n<li>往父级遍历，得到当前的 routerview 深度，确定 route</li>\n<li>兼容 keep-alive 的逻辑，处理缓存逻辑</li>\n<li>渲染组件</li>\n</ol>\n<h1 id=\"5-最后总结\">5. 最后总结</h1>\n<p>看完核心逻辑后，我最初的疑问基本得到了解答。感觉还是挺有收获的。知道了路由的第三种模式，路由切换的整体过程，路由的匹配逻辑。也了解了 router-view 这种函数式组件的实现。\n我还有一个问题未得到答案</p>\n<p>看来只有到时候看 Vue 源码时才能有收获了.</p>\n",
    "9": "<h1 id=\"tldr\">TL,DR</h1>\n<p>最近半年对两个业务系统进行了重构升级，重构前的代码都是几千行的业务逻辑。在做业务迭代的过程中考虑到开发的难度和后续的维护，于是对就有组件进行了重构。经过重构将大文件组件进行拆分，方便了后续的扩展和维护。</p>\n<h1 id=\"业务背景\">业务背景</h1>\n<p>部门负责的业务中包含一个订单系统，该系统内部包含多种角色，10 余种订单状态，约30种订单操作。业务的前端页面由订单列表和订单详情两个主要组件构成，且订单详情页面展示时覆盖在订单列表上，并未使用独立页面。</p>\n<p>由于历史原因和不断的迭代，造成页面组件的代码行数几千行，且订单详情组件拥有多种自定义状态。</p>\n<p>由于版本迭代，页面UI需要进行调整，订单流程需要精简。结合当前的代码状况，于是决定进行重构。</p>\n<h1 id=\"重构过程\">重构过程</h1>\n<h2 id=\"1-针对订单操作进行拆分\">1. 针对订单操作进行拆分</h2>\n<p>将每个操作抽离成单独的就是</p>\n<p>将每个操作定义成如上数据结构，存入操作的数组中。然后在列表中直接传入 当前行的数据，执行每个操作的valid的方法，过滤出适合当前行数据的操作。\n定义好相关的订单操作后，在列表组件中 ,</p>\n<p>这一块的逻辑也可以单独放在  里面，之前有一个业务 列表有两种展示方式，卡片和普通列表。像这种情况我们把操作抽离出来，最后混入到对应的列表和卡片组件中即可。</p>\n<p>上述的操作还存在一个问题，就是操作的实际点击事件，很多都会包含视图的变化，弹一些弹窗之类的。 </p>\n<p>如果按照普通的逻辑，将弹窗定义在 列表组件中，然后再维护弹窗显示的状态，整个列表组件还是臃肿，而且视图和逻辑分离，不利于代码的阅读。</p>\n<p>这里我使用了 , 将所有的弹窗组件都封装成函数，将props时通过函数参数进行传入，将弹窗完成的操作通过props定义的回调函数进行传出。</p>\n<p>通过这种代码结构，我们把操作完全抽离，实现了十分合理的解耦</p>\n<h1 id=\"订单详情改造\">订单详情改造</h1>\n<p>之前版本的订单详情展示时是覆盖在订单列表上面的，这导致在详情时刷新页面时会展示为订单列表页面，这种实现和业务交互是不太合适的。</p>\n<p>订单详情页面之前包含 订单发单， 订单审核，订单详情 逻辑。组件的自定义状态过多，视图展示在不同状态的也有差异。因此整体详情的逻辑还是比较混乱的。</p>\n<p>因此在重构时，我将发单，详情，审核的逻辑抽离为单独的组件，通过不同的路由进行分发。对于试图相同的部分抽离为组件。</p>\n<p>将这个大组件拆分成各种逻辑的独立组件后，代码可读性高了很多。在平时的业务开发中，我们也应该注意业务组件公用。在视图的重合比例较高且业务逻辑较为简单时，将组件进行公用是OK的，更多的时候拆分为独立组件对于后续的维护和迭代好处更大</p>\n<h1 id=\"写在最后\">写在最后</h1>\n<p>最后终结下大组件的拆分吧。</p>\n<ol>\n<li>可以通过 mixin 和 Vue.extend 对业务逻辑进行抽离</li>\n<li>将多状态组件抽离为多个单状态组件</li>\n</ol>\n<p>重构的还是有一定风险的，重构过程中不能一蹴而就。一部分一部分的进行重构，写完之后及时测试，保证业务逻辑的正确。全部开发完成后也需要进行回归测试。</p>\n<p>业务开发时， 是一种妥协。如果时间允许且对于业务和自己有益处的话，还是推荐重构的。</p>\n",
    "10": "<h1 id=\"一业务背景\">一.业务背景</h1>\n<p>部门负责的业务主要是 H5 营销物料的制作，会有第三方使用我们的服务制作营销物料。作为营销产品，第三方往往需要私有化部署，自己保存相关的数据。当第三方需要进行数据采集或者在我们现有的框架上进行第二次开发时，就需要我们提供相应的SDK能力给对方。</p>\n<p>旧代码中暴露的方式是通过全局的回调函数，但是随着业务的复杂度提升，所需要的回调函数也会越来越多。而且客户有进行二次开发的需求，简单的回调函数不能满足该需求。</p>\n<p>因此决定根据在现有的框架的基础上开发一套SDK，暴露自身的业务能力和数据给第三方。</p>\n<h1 id=\"二-设计原则\">二. 设计原则</h1>\n<p>在进行SDK设计时，我的设计原则是：</p>\n<ol>\n<li>对现有业务代码侵蚀小，不污染业务逻辑</li>\n<li>接口易懂，方便调用</li>\n<li>不影响当前业务</li>\n<li>扩展性强</li>\n</ol>\n<h1 id=\"三实操过程\">三.实操过程</h1>\n<h2 id=\"31-发布订阅\">3.1 发布订阅</h2>\n<p>首先是事件分发，这里我采用了  的设计模式。当业务逻辑执行时，主动分发相关事件，提供给订阅者使用。</p>\n<p>上面就是一个简单的 发布订阅 设计模式，在此基础可以进行功能的丰富。例如直接进行全部事件的的订阅，取消订阅等逻辑。</p>\n<h2 id=\"32-阻止默认事件\">3.2 阻止默认事件</h2>\n<p>对于业务系统的事件，在事件发生时，可以提供给用户阻止默认事件发生的能力，方便用户进行自定义操作。于是我模仿了  的  的模式，在执行一些事件前提供阻止事件的能力。</p>\n<p>用户在使用时，可以这么进行调用</p>\n<p>在进行事件设计时，一般的业务都会分发两个事件  和 .</p>\n<p>那在具体代码中是怎么实现这个逻辑的呢？</p>\n<p>我是这么实现的, 先定义事件响应结果的类</p>\n<p>然后在  中，将 响应的实例传递给每个订阅者</p>\n<p>如果有订阅者调用  方法，则会让  为 。然后业务代码根据返回的值决定是否继续业务逻辑，当然此处只支持同步的阻止，异步阻止并无实际的业务意义。</p>\n<p>接下来，我们看看业务代码如何进行事件分发</p>\n<h2 id=\"33-事件代理\">3.3 事件代理</h2>\n<p>查看了旧的业务代码，业务相关的功能函数中充斥着各种回调，埋点的逻辑，实际的功能逻辑被大幅度污染。</p>\n<p>因此我决定不在现有函数中进行事件的分发，而是利用 函数代理，实现事件的分发。</p>\n<p>函数代理很简单，就是将原函数进行包裹，混入一些其他逻辑。</p>\n<p>这里我主要是混入一些 hook, 然后和之前的事件分发结合起来 ,于是我的代码是这样的</p>\n<p>这里通过注入前后  实现了原有函数的代理, 使用  和 被代理的函数， 实现了 事件的分发和默认事件的阻止。</p>\n<p>到了目前这一步，其实已经能够满足基本的需求了，但是实际业务中包含很多异步的逻辑，通过回调函数实现函数的结束，这种情况  就无法正常起作用了。</p>\n<p>其实对异步的处理也很简单，对于拥有回调函数的的函数我们可以这么进行处理</p>\n<p>通过对被代理函数 回调函数参数的处理，我们实现了  对异步函数的兼容。</p>\n<p>这是实际使用的例子\nafter:</p>\n<p>对于支持  的处理就相对简单了，这里就不进行讨论了。</p>\n<h2 id=\"34-总体处理\">3.4 总体处理</h2>\n<p>当我们将上面的工具函数写好之后，就可以对框架中需要进行暴露的业务函数进行代理，注入相关 ,\n并将相关的  整理成文档，提供给第三方进行使用。对于函数的代理，我们可以写一个函数进行处理，在  初始化时才进行代理。这样处理的好处在于如果不使用 ，对现有的业务逻辑没有一点影响，而且也不影响在线的 。</p>\n<h2 id=\"35-用户主动触发事件\">3.5 用户主动触发事件</h2>\n<p>这个逻辑也好处理，就是 发布者 和 订阅者 的身份对换即可。 业务事件函数订阅相关的 , 用户可以使用  进行发布事件即可。</p>\n<h1 id=\"四-写在最后\">四. 写在最后</h1>\n<p>经过这次  开发，加深了我对设计模式的理解，好的设计模式对于代码的解耦非常有帮助。</p>\n<p>同时我也学会了通过 函数代理 来对函数进行扩展，避免对函数内部的业务逻辑产生影响。</p>\n<p>当然  的开发最重要的还是文档，好的文档描述可以让开发者快速接入 . 对于双方的对接效率有很大的提升。</p>\n",
    "11": "<h1 id=\"一-业务背景\">一. 业务背景</h1>\n<p>日常的工作有很大一部分都是编辑器的开发。由于业务需求，今年推动了全景编辑器2.0的重构。本文会主要讲述此次重构的全部细节。</p>\n<p>作为一款编辑器，老版全景编辑器的功能存在很多问题。</p>\n<ol>\n<li>数据实时变化，用户操作后立即保存。不能进行撤销，也无历史记录功能</li>\n<li>前后端耦合严重，新功能开发需要依赖前后端共同协作</li>\n<li>用户使用体验不好，操作后数据流转和接口请求逻辑混乱，有明显的卡顿</li>\n<li>业务打包历史包袱重，各种大组件和事件传递，维护成本高</li>\n</ol>\n<p>当前的业务架构不在满足后续业务的开发，于是我决定重构。</p>\n<h1 id=\"二-重构目标\">二. 重构目标</h1>\n<p>作为编辑器的主程，产品在规划2.0版的新功能时，我基于当前业务现状和主管提出了重构的想法。通过重构后，主要能够实现的目标有：</p>\n<ol>\n<li>满足2.0的产品需求，不进行实时保存，在前端存储数据，由用户决定数据的保存</li>\n<li>减少前后端耦合，减少接口请求。后续新功能可以完全有前端进行开发。</li>\n<li>性能优化，提高用户的使用体验</li>\n<li>全景逻辑和UI框架逻辑抽离，让全景编辑的逻辑完全独立，即时使用其他UI框架也能快速实现编辑器</li>\n</ol>\n<h1 id=\"三-具体实操\">三. 具体实操</h1>\n<h2 id=\"31-数据建模\">3.1 数据建模</h2>\n<p>首先是数据，和H5编辑器不同，老版本的全景编辑器在前端存储的数据是很零散的。完全通过  读取全景的数据。在数据更改时直接提交后端，更改配置  文件，前后端耦合非常严重。</p>\n<p>因此数据方面我完全放弃从  实例中读取数据，而是在进入编辑器时获取该物料的 XML配置文件，然后将  转化为 ，从  中获取数据构建整个全景的  树，后续的编辑器操作都基于  操作。</p>\n<p>从  到  的转化过程中，我对全景中所有的组件都进行数据建模。包括 热点，图层，标尺等，声明的类大约 20余种。每个类都提供解析  获取  的方法，最终对整个  进行操作，就获取到所有的组件数据了。</p>\n<p>对数据建模的好处,  不止在于解析数据。上面我也提到，我希望将全景编辑的逻辑和UI逻辑抽离，而通过类来对相关的组件进行数据和逻辑的封装就非常好用。我将  相关的操作全部封装到对应的类中，操作数据时，直接调用相关的类和实例的方法即可</p>\n<p>这样就不用在  代码中写  的相关逻辑了，界面表单在更新  数据时，使用封装好的类同步预览的视图即可。</p>\n<h2 id=\"32-组件拆分\">3.2 组件拆分</h2>\n<p>旧代码中包含很多的大组件，例如热点组件，热点的类型有7种，每种热点的属性各有异同。老组件中直接包含所有热点的配置，各种状态判断，十分混乱。</p>\n<p>这里的重构逻辑很简单，拆分组件，每种类型热点对应相关的属性组件，编辑时通过数据类型标识识别对应组件然后用动态组件进行展示。</p>\n<p>对于其他的大组件，我们也采用一样的方法进行抽离，保证组件的颗粒度，保证组件的业务复杂度不能过高。</p>\n<h2 id=\"33-切图处理\">3.3 切图处理</h2>\n<p>用户上传的全景图是一张2：1的图片，无法直接被全景使用。我们使用  官方提供的切图工具在服务器进行切图，然后放到对应的物料文件夹中。</p>\n<p>重构时有考虑前端切图，普通切图将全景图分割为6张图片是可以实现的，但是业务场景更多的需要的是高清切图，由于算法问题，最终还是放弃了这个小优化。</p>\n<p>老版本切图存在一个问题，就是用户在进行切图时，对服务器的压力特别大，后端在队列管理上也处理的不好，没有进行异步处理。这就导致多用户多图上传时，等待的时间可能会特别久，如果接口超时失败，前端也未进行相关处理。10张切图，有一张失败了都会造成整体操作失败，用户体验十分糟糕。</p>\n<p>我这边的处理也很简单，切图时不使用遮罩阻止用户操作。将每个切图都变成任务，每个任务有各自的进度条，任务之间互不影响。这样用户在编辑物料时也能进行上传的操作，用户使用体验大幅提高。</p>\n<p>同时为了缓解服务器压力，前端封装了一个 任务调度器 , 用户任务最多并行两个。 当然这个处理的收益还是比较小的，也不能真正解决问题，还是需要后端进行优化。</p>\n<h2 id=\"34-最终保存\">3.4 最终保存</h2>\n<p>重构一开始的目的就是为了最终保存，用户拥有数据保存的决定权。在编辑器对 进行编辑后，我们需要进行转换。将  重新转化为 ，这里同样使用类的序列化方法\n&lt;hotspot ... /&gt;</p>\n<p>这里在进行开发时还是遇到了坑， 一开始我们使用的是对属性进行遍历，然后通过字符串组装成 ，由于业务场景不需要关心  的问题。但是在代码提测之后，问题接踵而来。当输入特殊字符或者引号之类的特殊符号时，由于  的格式要求， 就变成了非法的  文档了，这也造成了全景保存失败。</p>\n<p>因此我们选择通过将  转化成通过  提供的能力来进行序列化</p>\n<p>这种方法解决了大部分的问题，但是还是会有不少的坑，例如  中的特殊空格，就是无法进行保存。定位到问题后，只能根据  进行匹配替换。</p>\n<p>还有富文本的情况，富文本通过属性进行保存时也会存在问题，要么是预览异常，要么是回显到富文本编辑器异常。最终还是决定针对富文本进行字符串拼接，然后将,,,符号进行实体化处理，上线后到目前为止暂时无任何异常。</p>\n<h1 id=\"四最后结果\">四.最后结果</h1>\n<p>经过2.0 的重构，在业务架构上减少了后端的依赖，大幅提高了用户的使用体验。 让用户可以通过全景编辑器快速制作出全景漫游物料，添加丰富的交互效果。</p>\n<p>在前端代码设计上，让全景编辑的逻辑完全独立，针对全景模块进行数据建模，对后续维护和新增功能十分的友好。</p>\n<p>当然通过这次大的重构，无论是业务架构设计还是组件拆分，我都有了巨大的收获。</p>\n<p>当然重构到目前为止，编辑器已经重构的十分强大了。但是还是缺少一个最重要的功能： 历史记录。后面我会有专文介绍历史记录功能的实现，和具体业务难点。</p>\n",
    "12": "<h1 id=\"一-业务背景\">一. 业务背景</h1>\n<p><a href=\"https://github.com/vivipure/blog/issues/11\">上文</a>我讲了编辑器的整体重构，也留下了一个关于 <strong>历史记录</strong> 的坑。在我们的业务中，无论老版本还是新版，都缺少历史记录的功能。 </p>\n<p>作为一款编辑器，不能进行历史记录的展示，不能进行操作的回退和重做是不完整的。因此开发历史记录功能刻不容缓。</p>\n<h1 id=\"二-方案选型\">二. 方案选型</h1>\n<p>和H5编辑器不一样，在H5编辑器中，我们可以通过JSON直接控制相关元素的展示。历史记录功能可以将JSON在操作后进行备份，回撤时直接使用备份的JSON即可。</p>\n<p>这也是通过  实现历史记录功能的基本逻辑，但是全景编辑器却无法使用这个功能，全景编辑器的预览并不是由JSON直接控制，每次JSON更新都需要手动更新预览。如果通过 实现该需求，那么在进行回撤时，全景预览就会重载，用户使用体验十分不好。我们更需要的是十分精细的更新。</p>\n<p>于是我选择了  ，我在全局建立一个历史记录的一个管理类，用户的每一次操作都会触发一个命令，然后  到历史记录中。在历史记录中可以看到每个命令的细节，点击对应命令时，根据状态执行当前命令和点击命令之间的所有命令的动作，执行就是重做，撤销就是回撤。这样就实现了历史记录功能和重做撤销。</p>\n<h1 id=\"三-实操\">三. 实操</h1>\n<h2 id=\"31-定义命令类和控制类\">3.1 定义命令类和控制类</h2>\n<p>首先是定义命令基类</p>\n<p>每个命令包含 name 和 执行重做两个方法。接下来就是管理器</p>\n<p>管理器中维护了一个命令的数组和当前的索引，这种实现比使用 重做和撤销两个数组 要简单和清晰。同时也定义了历史记录的最大数。 每个命令都需要管理器进行执行， 然后管理器也提供重做和撤销功能.</p>\n<p>具体的重做和撤销代码我这里就展开了，实际逻辑很简单，就是从数组中取出对应的命令执行相关的操作，然后更新索引即可。</p>\n<h2 id=\"32-和框架结合\">3.2 和框架结合</h2>\n<p>我引入命令模式，其实是希望通过命令来进行数据的更新和视图的更新，但是  作为数据绑定的框架，当视图改变后，数据自动更新了，并没有在命令类中进行操作。这其实不符合我的预期。这样对后面的重做和撤销操作也会有影响，会造成无法对比更改的问题。</p>\n<p>我的解决方法也很简单，就是当编辑器选中编辑数据时，特定的数据，使用特定的更新命令类记录当前的数据。</p>\n<p>每次选中数据时，就将当前数据备份，当数据更改后就触发对应命令。在命令类中进行数据比较，然后在 \n,  更改数据和引用对应的类更新视图。 之前重构时还是的必须将类在Vue文件中使用，通过这种方式，完全进行了隔离，每个组件只关心  数据的改变，视图的更新通过  ,生成命令进行控制。</p>\n<p>上面主要讲的是更新命令和  框架的兼容，其他的删除，添加命令就要简单的多了。</p>\n<h2 id=\"32-命令合并的实现\">3.2 命令合并的实现</h2>\n<p>在进行开发时，有参考  历史记录的实现，对于同一个对象同一种操作，历史记录会进行合并，只会出现一条记录。在全景编辑器中也会出现热点移动等多次触发的操作，因此也需要实现命令合并的功能，优化历史记录的展示。</p>\n<p>具体的实现也很简单，在  执行命令时，判断当前命令是否有实现合并的方法，如果有且上一条命令和当前命令是同一命令的实例，就进行比较。</p>\n<p>主要比较数据改变的字段是否一致，如果字段一致，那么就将当前命令更新的部分合并到上一条命令中即可，这样就实现了命令的合并功能。</p>\n<h1 id=\"四-命令模式存在的问题\">四. 命令模式存在的问题</h1>\n<p> 对我们管理应用的数据操作有着很大的好处，但是它也存在一个很明显的问题。就是随着操作的变多，相关的命令文件也会随之膨胀，编辑器几十上百种操作都需要进行定义相关命令类，工作量和代码体积膨胀都是问题。</p>\n<p>但是  对于全景编辑器的业务场景十分适合，用户体验也十分友好，毕竟也不想用户每次回撤都黑屏一下。因此基于业务场景，最终还是使用了这套方案</p>\n<h1 id=\"五-最后总结\">五. 最后总结</h1>\n<p>通过对编辑器的历史记录功能开发，我学会了  和  两种方案。我们在实际业务开发中可以根据业务场景进行技术选型。 如果是简单的H5编辑器，那么  就足够了。但如果你的业务场景也和我们的场景类似，数据和预览视图是完全独立的场景，那么  是比较合适的。</p>\n<p>没有完美的技术方案， 我们只能选择做相对正确的事而不是做简单的事！</p>\n",
    "14": "<h1 id=\"一-写在前面\">一. 写在前面</h1>\n<p>作为前端开发， 是我日常工作中使用最多的框架，各种特性我都有进行了解。但是对于框架底层的原理却知之甚少，知道数据劫持，但是不知道依赖收集的具体过程。知道  算法，但对  所做的算法优化不了解。一入门就学习了  的生命周期，却不了解组件实例化的整个过程。</p>\n<p>总的来说就是似懂非懂，都知道一些，都不深入。因此学习源码，了解  的整体设计是我的主要目标。也希望通过  源码的学习能让我在工作中使用  更加的得心应手。</p>\n<h1 id=\"二-基本介绍\">二. 基本介绍</h1>\n<p> 的源码设计的东西太多了，我决定拆分成不同部分去阅读，带有目的去了解。</p>\n<ul>\n<li>源码地址： <a href=\"https://github.com/vuejs/vue\">https://github.com/vuejs/vue</a></li>\n<li>分支： main</li>\n<li>版本： v2.7.0</li>\n</ul>\n<p>这里选择了当前(2022-06)最新版本的代码，当前版本的代码已经全部使用  进行重写，舍弃了之前的  标注，阅读体验还是比较好的。</p>\n<p> 的代码在  目录下，目录结构为</p>\n<p>看源码的顺序一般从入口文件开始， 作为库，入口文件是它的构建产物，因此我们从打包命令中入手。</p>\n<p>于是找到  文件，然后找到配置文件 </p>\n<p>从上面的配置中，我们可以看到  在打包是构建成不同的版本，有支持  规范 ,\n也有支持  的 , 也有兼容多格式的 。其中有带  的版本，也有  的版本。</p>\n<h1 id=\"三-入口文件\">三. 入口文件</h1>\n<p>从配置文件中有找到 别名的声明文件 </p>\n<p>也有很多的构建版本以该文件作为入口文件，因此从 开始入手。</p>\n<p>忽略新增的  的功能代码，进入 文件</p>\n<p>这个文件的代码很多，但是核心逻辑就是引入了  方法, 扩展了  方法，支持将  的  转化为  函数。根据导入一直寻找，我们最终来到了</p>\n<p>然后在 文件</p>\n<p>new\n在这里我们知道， 就是一个构造函数，只能通过  进行实例化，然后通过不同函数对  进行扩展实现功能模块化，</p>\n<h1 id=\"四-总结\">四. 总结</h1>\n<p>Vue 的整体逻辑过于庞大，涉及到组件化, 响应式原理，编译等诸多逻辑。因此我会从不同的部分去阅读和解析源码。</p>\n<p>文章链接：TODO</p>\n",
    "15": "<h1 id=\"_init\">_init</h1>\n<p>当我们使用  时，我们会用  实例化一个应用</p>\n<p>   是一个构造函数，实例化时会调用  方法.</p>\n<p>找到 文件中，函数执行时挂载了 方法</p>\n<p>这里的逻辑我大致讲一下，</p>\n<ol>\n<li>递增</li>\n<li>往实例上加一些属性标识</li>\n<li>初始化，合并 ,  等</li>\n<li>初始化声明周期，初始化 </li>\n<li></li>\n<li>初始化 </li>\n<li>初始化  -&gt;  -&gt;  -&gt;  -&gt; </li>\n<li>初始化 </li>\n<li></li>\n<li>开始</li>\n</ol>\n<h1 id=\"\"></h1>\n<p>上面的流程大致过下，接下来我们看看  执行的过程。</p>\n<p>在 中我们讲过，这里将  函数引入进来，用于讲  转化成  函数，这里我们也讲一下详细的逻辑</p>\n<p>来到 ， 这里就是  时 方法</p>\n<p>这里调用了 的  方法</p>\n<p>这里实例化了一个 渲染的 , 在它的回调中会调用  方法，执行 ， 更新 </p>\n<p>这里还有一个判断 , 这里  表示父 ，为  则表示为根结点的实例.</p>\n<p>Watcher 我们先不看，这主要是响应式原理和依赖收集相关的部分，我们继续看  ,  方法的逻辑.</p>\n<h1 id=\"_render\">_render</h1>\n<p>在 中， 函数注册了  方法.</p>\n<p> 函数调用  生成  进行返回</p>\n<p>平时我们使用  函数时是这么写的：</p>\n<p>这里的  就对应了 , 而  就是响应式的数据</p>\n<p>其中  在  时进行了注册，实际上也是对  方法进行了封装。</p>\n<h1 id=\"createelement\">createElement</h1>\n<p>在 中定义了  函数，该函数是对  的封装，让参数更加灵活</p>\n<p>这里主要执行的逻辑是，先将  规范为  数组， 标识规范类型。</p>\n<p>然后创建 , 对  进行判断,</p>\n<ul>\n<li>. 如果是  是  类型<ul>\n<li>. 内置  元素的话，直接创建普通 </li>\n<li>. 已经注册过的组件名，则使用  创建组件 </li>\n<li>. 创建未知标签的</li>\n</ul>\n</li>\n<li>. 如果是  类型，直接创建  组件</li>\n</ul>\n<p>到这里我们大致讲完了  的逻辑了。</p>\n<h1 id=\"update\">update</h1>\n<p>在 方法中，执行完成后，会执行 方法</p>\n<p>查看  方法</p>\n<p>这里的核心逻辑是  方法. 由于  不只面向  平台， 也会处理其他平台的逻辑，例如<strong>死去的</strong> . 而且在  时，也是不需要 。这里我们看   方法。</p>\n<p>这里主要通过  创建元素</p>\n<p>这里的逻辑就是通过  创建正式的  然后插入到它的父节点中。</p>\n<p>这里先创建  元素，然后创建 ，遍历子节点，递归调用 , 然后调用 。</p>\n<p>最后调用  方法插入到 父节点，所以插入节点的顺序是 子&gt;父 的。</p>\n<h1 id=\"总结\">总结</h1>\n<p>最后回顾下整个 Vue 初始化的流程：</p>\n<ol>\n<li>初始化声明周期，数据</li>\n<li>开始挂载</li>\n<li></li>\n<li>生成 </li>\n<li>到  上</li>\n</ol>\n<p>从  的过程我们也知道了从 虚拟节点 到 DOM 的一个生成逻辑，所以有一个常见的面试题，就是父子组件的生命周期问题，这个问题的答案现在就很简单了</p>\n<p>上面我们大致讲了下  的过程，很多关于 新旧节点的比较逻辑，diff 算法优化并没有细聊。后续会有文章, 我们接着聊。</p>\n",
    "19": "<h1 id=\"写在前面\">写在前面</h1>\n<p>在平时开发中，我们更新数据后，需要通过 nextTick 的回调中才能获取DOM。</p>\n<p>通过前面的文章我们知道，这是因为 Vue中数据更新后，视图并不是立即更新，而是进入批量更新的队列中，而批量更新的队列也是在 nextTick 的回调，所以当 更新的回调执行完成后，我们操作dom的回调执行时才能正确获取到DOM的状态。</p>\n<p>所以来看看nextTick</p>\n<h1 id=\"nexttick\">nextTick</h1>\n<p>nextTick 方法可以将 回调函数推入到 callbacks 数组中，如果未传入 cb， 则会执行 resolve， 保证 nextTick后的 then回调被执行。</p>\n<p>这里会执行 timeFunc 函数</p>\n<p>这里做了很多兼容，有使用Promise 的微任务回调版本，也有定时器版本的宏任务版本。</p>\n<p>这里保证nextTick 回调的执行实际在 任务队列中完成，执行 flushCallbacks</p>\n<p>平时我们使用的  就是 这个逻辑</p>\n<h1 id=\"总结\">总结</h1>\n<p>通过对 nextTick 的源码学习，我们知道了 Vue 的批量更新是 不是在主线程执行的逻辑里面，而是在任务队列中执行相关的逻辑。</p>\n",
    "20": "<h1 id=\"一-写在前面\">一. 写在前面</h1>\n<p>React 生态的状态管理库有很多，比如Redux ，Recoil ，Mobx，自身的 context  也可以用来进行状态管理。</p>\n<p>首先 Redux 实在说不上是一个合格的状态管理库，功能太基础，结合业务必须使用插件。而且需要写的模版代码太多了，开发体验一般般。</p>\n<p>而 Mobx 也不太行，在 class 组件流行时，通过装饰器写 Mobx 还是很爽的。但是 hooks 流行的今天，呃，就这样吧。</p>\n<p><a href=\"https://github.com/pmndrs/zustand\">Zustand</a> 是这么多状态管理库中让我眼前一亮的库。它的代码很少，功能很多。</p>\n<h1 id=\"二-安装\">二. 安装</h1>\n<p>added 160 packages, and audited 161 packages in 14s</p>\n<p>22 packages are looking for funding\n  run <code>npm fund</code> for details</p>\n<p>found 0 vulnerabilities</p>\n<h1 id=\"三-快速使用\">三. 快速使用</h1>\n<h2 id=\"31-定义store\">3.1 定义store</h2>\n<p>在 create 时， set 有几种用法</p>\n<ul>\n<li>obj 会合并到 state中</li>\n<li>函数返回值合并到 state 中</li>\n<li>obj 会取代当前 state</li>\n</ul>\n<p>create 函数中的第二个参数是 ， 我们可以通过 get 获取当前的 state</p>\n<h2 id=\"32-在组件中使用\">3.2 在组件中使用</h2>\n<p>上面都是我从官网中 copy 的代码，实际开发也就是这么写的。可以看出，它的代码真的非常的少，我需要什么，我就定义什么。</p>\n<h1 id=\"四-优势\">四. 优势</h1>\n<p>和 redux 比：</p>\n<ol>\n<li>简单</li>\n<li>hooks 友好</li>\n<li>不需要 context provider</li>\n<li>可以和组件渲染解耦，只更改状态</li>\n</ol>\n<p>和 context 比：</p>\n<ol>\n<li>更少的模版代码</li>\n<li>只在数据变化时更新组件</li>\n<li>集中的、基于操作的状态管理</li>\n</ol>\n<h1 id=\"五-插件\">五. 插件</h1>\n<p>的插件也很简单，就是定义一个函数。 上面这个 log 插件也逻辑很清晰，在create 内执行时，对set 方法进行覆写，实现 log 的效果</p>\n<p>我在RN 中开发中需要对数据进行持久化，于是我可以这么写</p>\n<h1 id=\"六-总结\">六. 总结</h1>\n<p>Zustand 是一个优秀的数据管理库，可以很好的管理应用的状态。逻辑简单，可定制化强。开发 React 应用，Zustand 是不错的选择。</p>\n",
    "21": "<h1 id=\"hooks-出现的原因\">hooks 出现的原因</h1>\n<ol>\n<li>class 自身存在的问题<ol>\n<li>组件逻辑复用困难，尽管拥有HOC 和render props ，逻辑复用还是比较困难。</li>\n<li>在不同生命周期中执行不同的逻辑，组件会变得越来越复杂。相关的逻辑不好抽离</li>\n<li>使用Class 组件只为了组件定义状态，视图和逻辑，其实没有用到Class 的太多功能。而且还需要处理 this的绑定</li>\n<li>通过this 读取状态，是有副作用的。并不能确保状态的正确性</li>\n</ol>\n</li>\n</ol>\n<p>例如这个组件，点击发生后，如果props改变，那么最终的弹出的数据并不符合点击时的预期</p>\n<ol start=\"2\">\n<li>增强函数组件</li>\n</ol>\n<p>之前版本的函数组件太过鸡肋，只能用于展示，自身不拥有状态。</p>\n<h1 id=\"hooks-存在的问题\">hooks 存在的问题</h1>\n<h2 id=\"使用场景限制\">使用场景限制</h2>\n<p>React hook 不能在判断语句中使用</p>\n<p>具体原因是和 hook 的原理有关。 hook 通过闭包维护状态，然后将每个hooks注册到一个链表中进行存储，也就是说 hook 本身取值是有顺序的。 </p>\n<p>当组件更新时，hook重新执行，如果通过条件语句新增或者减少 hook 都会影响到原有链表的顺序，造成取值异常。</p>\n<h2 id=\"闭包陷阱\">闭包陷阱</h2>\n<p>当我们使用 useEffect 时，不同的依赖项会有不同的效果。 当我们传入空数组时， 此时的 useEffect 相当于 componentDidMount. 只会执行一次。结合函数使用时，就有可能产生的问题。</p>\n<p>这个例子中， 定时器通过闭包获取的变量永远都是第一次渲染时的 count， 导致打印的都是 0.</p>\n<p>其实不止定时器，还有在 useEffect 外部定义的函数，都有可能产生这个问题。</p>\n<p>解决办法：</p>\n<ol>\n<li><p>useEffect 添加依赖，内部函数使用到了哪个变量，就加入到依赖项。函数也是如此</p>\n</li>\n<li><p>使用useRef, 由于 ref是一个对象，它的 current 才指向真实的值。所以可以避免这个问题</p>\n</li>\n</ol>\n",
    "22": "<h1 id=\"写在前面\">写在前面</h1>\n<p>今年是毕业的第三年，也是我从事前端开发的第三年。相比于刚毕业时用 Vue 都不太熟练的新手，现在的我可以算的上是一名靠谱的前端开发。对于前端这一领域，我也有了一些自己的思考。</p>\n<h1 id=\"学习\">学习</h1>\n<p>内卷这个词语是近几年的热词。作为程序员，我从技术网站，社交平台经常会接收到各种渲染焦虑信息，这些信息会逼着我们内卷，学习。</p>\n<p>我一直要求自己成为不可替代的那种技术人才，而不是 CRUD boy，为此我也做了很多努力。基本上的时间都是在学习，看技术视频，博客。但是学习真的由减轻自己的心里压力吗，能够保证自己未来不失业，不35岁送外卖吗？ </p>\n<p>其实不能！至少对于我来说是不能的，我依旧感觉到焦虑，依旧对未来没有希望。我会因为技术焦虑买一些课程，或者学习目前根本用不到的东西（3D渲染，C++, Flutter），但是都没有很好的学习下去。</p>\n<p>前端的技术更迭很快，各种包管理，构建工具，语言，框架层出不穷。今天我看了这个源码，明天学会了那个工具。追逐技术的过程是比较累的。</p>\n<p>现在的我理解到，只有真正的业务实践才是最好的学习方法， 而我更应该掌握的是如何快速学习的能力。</p>\n<p>比如我负责的一个移动端APP的开发需求，从技术预研，相关框架和语言学习，到后面同步给同事学习，快速开发业务。整体的时间花费是比较少的，因为我知道了如何快速的去学习。</p>\n<p>关于学习的方向，我现在是比较明确的。JS/TS 编程语言精通，UI框架熟练掌握，扩展自己移动端原生开发的能力，熟悉后端的技术。总的来说就是 前端有深度，技术有广度。</p>\n<h1 id=\"和后端的比较\">和后端的比较</h1>\n<p>很多人说前端是娱乐圈，没有什么技术门槛。刚入门时我听到还是会有点不开心的，觉得自己的工作被人贬低，而且作为非科班出身，不可避免会有不自信的心态。</p>\n<p>而对于现在的我来说，我反而庆幸前端的门槛低。我能通过自学快速的找到一份前端的工作，而且在工作中获得持续的成就感。到现在三年了，我在工作中获得的成就感从未中断。</p>\n<p>后端的确比前端复杂，后端的开发体验和开发流程十分的完整，工业化程度十分的高。前端其实起势也就这十几年，JS变成一门还算可以的语言也就这几年。而且对于多人维护的项目来说，JS算不得上是好语言，灵活的优点带来的缺点更多。还好我们有TS， 我可以自信的说，TS 改变了前端。</p>\n<p>可能对于很多项目来说，复杂的业务逻辑都由后端来处理，前端做的都是一些页面交互，没有<strong>含金量</strong>。对也不完全对，用户交互在我看来和功能来说一样重要。很多时候产品想的和用户实际使用的根本对不上，交互是产品和用户交流的第一线，好的交互有利于成就伟大的产品。前端平时开发时也应该多想想交互，把自己作为第一个测试和用户来体验产品。写出恶心人的交互是对前端工作的侮辱。</p>\n<p>对于现在的前端，其实业务逻辑也不简单。我做过业务包含编辑器，大部分的业务逻辑都在前端。后端的业务只有数据存储和文件写入。而且现在很多在线文档，笔记或者其他工具，它们的前端业务也很复杂。桌面应用网页化是潮流所向，所以前端不仅只有页面，我们的未来是一篇蓝海。</p>\n<h2 id=\"我的困惑\">我的困惑</h2>\n<p>前面讲了很多东西，现在我讲一下我的一些疑惑点吧，希望未来的自己能够解答这些问题</p>\n<ol>\n<li>组件和样式的边界在哪里，如果只是样式一致，有必要抽离成组件吗？</li>\n<li>很多开发都渐渐变成了 chrome 前端工程师，这种趋势好吗？</li>\n<li>CSS的兼容问题，如果一种写法有 90% 的用户显示正常，是否需要对10% 写更多的hack代码？</li>\n<li>utility css 类框架例如 tailwind css 变得流行，但是开发的代码如何去维护？</li>\n</ol>\n",
    "23": "<h1 id=\"一-写在前面\">一. 写在前面</h1>\n<p>之前文章讲了 SDK开发的背景，和具体封装的逻辑。最近有用户使用我的SDK进行二次开发，对接的过程中我发现SDK存在一些问题，例如 使用方式，对接方式。因此我根据这些问题，将SDK进行了重构。</p>\n<h1 id=\"二-重构\">二. 重构</h1>\n<p>框架通过暴露全局函数的方式来暴露能力，第三方通过覆写对应的函数来实现能力的调用。</p>\n<p>我开发的SDK讲这些全局函数再次进行封装，通过 发布订阅 的设计模式进行通信。但是SDK 的暴露方式还是通过全局对象进行暴露，第三方在进行二次开发时，需要讲他们的JS 放到 我们的JS 逻辑之下才能运行。而且通\n过全局变量这种方式，无法进行友好的类型提示，根据文档进行开发，开发体验不是很友好。</p>\n<p>所以我对SDK进行了抽离，变为一个独立的 NPM 包。第三方开发时可以通过引入NPM包的形式进行开发。</p>\n<h2 id=\"2-1-环境\">2. 1 环境</h2>\n<ul>\n<li>构建工具 ： Vite</li>\n<li>插件： <a href=\"https://www.npmjs.com/package/rollup-plugin-typescript2\">rollup-plugin-typescript2</a></li>\n<li>语言：TypeScript</li>\n</ul>\n<p>使用  可以在打包时生成  文件，其他人在使用我们的包时，通过JS开发也能获得类型提醒，使用体验十分的友好。</p>\n<h2 id=\"22-类型体操\">2.2 类型体操</h2>\n<p>其实通过 TypeScript 开发和 JavaScript 开发区别并不大，无非就是加一些类型注解。但是我之所以使用 TypeScript ，还是希望通过 TypeScript 强大的类型提示可以让用户减少看文档的时间。</p>\n<p>举个例子，SDK 通过 发布订阅 分发事件，不同的事件的返回值是不同的。 我想实现的效果是用户订阅不同的事件时，类型提醒可以返回对应事件的值。</p>\n<p>灵感来源： <a href=\"https://twitter.com/mattpocockuk/status/1549721729630625799\">https://twitter.com/mattpocockuk/status/1549721729630625799</a></p>\n<p>想法很简单，实现有点难。这里我参考了上面推文的例子：<a href=\"https://www.typescriptlang.org/play?#code/JYWwDg9gTgLgBAbzgMTgXzgMyhEcBEMAzgLQwQQA2ARgKaUz4DcAUCzAJ5i1wBCAhkVoAlCAFcYtKAGEIAO0zAA5nAC8cYbQDG0ACYAeIjCjA5SgDSI4Q-lC0ALAPwAua8dNKA2gF10APlYWHTkjOBB+AGsRcUkoNTh9ABVZBWU4WgAPSTldIj5BaIkpFMUlPwAKFjg4AH1g0tdkADoAOVscAHckkuU-cxYASjU-RCq4KFoYMSg5UerqpQhEiFck0SL0rNocvKiOCEw4ZPlSy0SAZVpbB3jj1K9E9clvT3wbO3t8bwqx+fGY2iuR4A-p-arvBwuI6Xa72TbZXJuExmHy-MGOKyeGEfAAKtn4eFM0KuH08cjEIDoUG83ihRmRKjQaL+rjktAAblJQfMhqoRghmXBKJM4GyOk8eOpzu4zOUcEUBoEwXBgIdyhD7EMBcrqmKJXAANTqMVwACqwgAMtiHHioASiJUdfMNXBBBptHpDDKLEiPH1BdUBk1yNKGeVFYKmcqOqZdBAOk1KBAtPwYMB5E17BNDsbaOKAaw-mhuWhWKW2MFQvLJHl1OEohKoOVtQQAPT4VwIYtjfCt3SCezUCC2XQdubOkkOVyvMD8JS0fCWfDcKB4+eLghEXCTeweL4l-poCMsau0IhNRbLcq9-tEQfDqCjywt2fz1z4ACMi7GW5AO4877fkegSnuel4QNe7YRkAA\">makeRouter</a>，这个例子通过 路由配置 让返回的路由实例能够正确提醒路由所对应的query.</p>\n<p>我最终实现的效果如下：</p>\n<p>利用 类型收紧和泛型，我在 TypeScript 传入相关事件的配置，用户在使用时就能从不同的事件得到不通的类型提示，that&#39;s  cool!</p>\n<h2 id=\"23-使用场景\">2.3 使用场景</h2>\n<p>用户在使用SDK时一般有两种场景，一种是在现有HTML里嵌入自身逻辑，还有一种是通过 iframe 嵌入我们的物料，然后在 iframe 外部写自己的逻辑。</p>\n<p>第一种方式SDK是能够正常使用的，但是通过 iframe 方式，SDK并不能生效。因为我们的SDK是通过拦截 window 上的事件进行重写，在进行事件分发。iframe 模式的 window 并不一致，所以SDK无法正常使用。</p>\n<p>兼容也很简单，提供一个方法进行初始化</p>\n<p>不传值的情况就使用当前 window，拦截相关函数。 传值时就传入对应的iframe DOM即可。</p>\n<p>这样我们的SDK既能支持当前物料的开发，也能支持iframe嵌入</p>\n<h2 id=\"24-发布\">2.4 发布</h2>\n<p>作为SDK,通过全局变量的形式暴露对于开发者是不友好的，更好的方式是发布到 npm 上提供给开发者下载</p>\n<ol>\n<li>注册账号，可以添加组织，让包名拥有scope</li>\n<li>package.json 配置包信息，入口文件</li>\n<li>配置.npmignore, 忽略上传文件</li>\n<li>npm login</li>\n<li>npm publish(组织包，需要执行 npm publish --access public)</li>\n</ol>\n<p>更新版本时，先 npm version patch 再 publish</p>\n<h1 id=\"三-文档\">三. 文档</h1>\n<p>其实有了 TypeScript 和相关注释，用户在进行开发时不借助文档也能够很好的开发。但是文档还是很重要的。</p>\n<p>当用户想接入我们的SDK时，他接触的第一个东西肯定是文档。文档可以告诉他 SDK 能够提供的能力，已经如何进行接入。</p>\n<p>写文档的确很烦，但当我们自己开发时又希望其他人写文档。很矛盾，又很真实。</p>\n<p>文档的结构我借鉴了常用的文档模式。</p>\n<ol>\n<li>功能介绍</li>\n<li>安装</li>\n<li>快速使用</li>\n<li>事件</li>\n<li>模块</li>\n</ol>\n<p>写完这些，快速对接基本上没啥问题了。</p>\n<h1 id=\"四-界限\">四. 界限</h1>\n<p>写 SDK 的主要目的时暴露自身的能力，因此我们需要注意能力的界限。</p>\n<p>例如用户在使用我们的SDK时想要进行数据埋点，获取访问用户的IP. 这个能力就不应该由我们提供，而是用户自己使用第三方库来开发。</p>\n<p>SDK的目的就是降低耦合，即使SDK内部有某些能力，但是我们也要考虑是否需要开放。</p>\n<h1 id=\"五-写在最后\">五. 写在最后</h1>\n<p>SDK 的开发经验还是很宝贵的，我也从中学习到了很多东西。我也通过这个业务将平时所学到的东西进行了实践。</p>\n",
    "24": "<h1 id=\"写在前面\">写在前面</h1>\n<p>国庆假期基本没出去玩，学习了下Astro 和 Solid。这篇文章就来具体讲下 Solid  的开发体验，还有和Vue ,React的框架区别</p>\n<h1 id=\"react-like\">React Like</h1>\n<p>看到语法的第一眼，就会感到十分眼熟。这不是 React吗？ </p>\n<p>从语法上来说，Solid 和 React 十分相似，但确有根本上的不同。</p>\n<p>在 Solid 中声明响应式变量需要用到 .  与 React 的  不同的是，返回的第一个值为函数，而不是一个值。</p>\n<p>React 为了实现组件中数据的更新，利用多次闭包加链表实现了 Hooks ,但是 Hooks 存在的闭包陷阱和必须顶层使用是无法进行避免的。</p>\n<p>Solid 中直接返回一个函数，使用函数获取真实的值，完全没有 React hook 存在的问题。这里有点像 Vue3 ，但是比 Vue3  更简洁。</p>\n<h1 id=\"reactive\">Reactive</h1>\n<p>在组件更新上，Solid的处理方式和 React 有很大的区别</p>\n<p>React 函数组件中， 通过 setState 触发函数再次执行函数，实现组件更新。</p>\n<p>而 Solid 函数组件中的代码只会执行一次，组件的更新依赖于响应式数据。Solid 实现了和Vue 类似的方式，进行了依赖收集。当数据变化时，组件就会进行更新。</p>\n<p>由于是直接使用函数， 在Solid 中变得很简单</p>\n<p>不得不说，这样的实现十分优美</p>\n<h1 id=\"❌-virtual-dom\">❌ Virtual DOM</h1>\n<p>Solid 还比较不同的地方，就在于DOM的更新策略上。</p>\n<p>Solid 并没有使用 虚拟DOM, 而是基于真实DOM进行操作。Solid 将DOM的变化颗粒化，响应式数据的变化只对依赖的Node起作用。而不是像虚拟DOM 一样组件重新更新再比较差异进行 patch</p>\n<p>这是一段Solid 代码</p>\n<p>编译后的代码\n<button type=button><span></span></button>\n这里我们可以看出，其实函数组件就返回了一个DOM。后续数据的变化只会影响到收集到DOM，这一点十分巧妙。</p>\n<h1 id=\"写在最后\">写在最后</h1>\n<p>使用过Vue, React后，来学习 Solid 有一种奇妙的感觉。Solid 使用了两个前辈的各自优点，又有自己的独特之处。</p>\n<p>第一眼看到 Solid 时，感觉是React. 具体进行使用时，又感觉是 Vue. 到了最后，才发现Solid 就是 Solid.</p>\n<p>这篇文章大概讲了下 Solid, 其实也没有讲具体用法。后续会更新具体的使用和相关生态。</p>\n",
    "25": "<p>WIP</p>\n"
}