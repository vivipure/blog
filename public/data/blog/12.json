{
    "title": "编辑器历史记录功能，命令模式实操",
    "excerpt": "一. 业务背景 上文我讲了编辑器的整体重构，也留下了一个关于 历史记录 的坑。在我们的业务中，无论老版本还是新版，都缺少历史记录的功能。 作为一款编辑器，不能进行历史记录的展示，不能进行操作的回退和重做是不完整的。因此开发历史记录功能刻不容...",
    "updated": "2022-06-18 10:04:15 ",
    "created": "2022-06-16 15:18:46 ",
    "avatar": "https://avatars.githubusercontent.com/u/26271337?v=4",
    "id": 12,
    "content": "<h1 id=\"一-业务背景\">一. 业务背景</h1>\n<p><a href=\"https://github.com/vivipure/blog/issues/11\">上文</a>我讲了编辑器的整体重构，也留下了一个关于 <strong>历史记录</strong> 的坑。在我们的业务中，无论老版本还是新版，都缺少历史记录的功能。 </p>\n<p>作为一款编辑器，不能进行历史记录的展示，不能进行操作的回退和重做是不完整的。因此开发历史记录功能刻不容缓。</p>\n<h1 id=\"二-方案选型\">二. 方案选型</h1>\n<p>和H5编辑器不一样，在H5编辑器中，我们可以通过JSON直接控制相关元素的展示。历史记录功能可以将JSON在操作后进行备份，回撤时直接使用备份的JSON即可。</p>\n<p>这也是通过 <code>快照方式</code> 实现历史记录功能的基本逻辑，但是全景编辑器却无法使用这个功能，全景编辑器的预览并不是由JSON直接控制，每次JSON更新都需要手动更新预览。如果通过 <code>快照方式</code>实现该需求，那么在进行回撤时，全景预览就会重载，用户使用体验十分不好。我们更需要的是十分精细的更新。</p>\n<p>于是我选择了 <code>命令模式</code> ，我在全局建立一个历史记录的一个管理类，用户的每一次操作都会触发一个命令，然后 <code>push</code> 到历史记录中。在历史记录中可以看到每个命令的细节，点击对应命令时，根据状态执行当前命令和点击命令之间的所有命令的动作，执行就是重做，撤销就是回撤。这样就实现了历史记录功能和重做撤销。</p>\n<h1 id=\"三-实操\">三. 实操</h1>\n<h2 id=\"31-定义命令类和控制类\">3.1 定义命令类和控制类</h2>\n<p>首先是定义命令基类</p>\n<pre><code class=\"language-js\">class Command {\n    name\n    excute() {}\n    undo() {}\n}\n</code></pre>\n<p>每个命令包含 name 和 执行重做两个方法。接下来就是管理器</p>\n<pre><code class=\"language-js\">class Controller {\n    commandStack = []\n    curIdx = 0\n    maxLength = 30\n    \n    execute(command){}\n    undo(idx){...}\n    redo(idx){...}\n    \n    deal(command) {\n        const idx = this.commandStack.findIndex(c =&gt; c=== command)\n        if(idx &lt; this.curIdx) {\n            this.undo(idx)\n        } else {\n            this.redo(idx)\n        }\n    }\n\n}\n</code></pre>\n<p>管理器中维护了一个命令的数组和当前的索引，这种实现比使用 重做和撤销两个数组 要简单和清晰。同时也定义了历史记录的最大数。 每个命令都需要管理器进行执行， 然后管理器也提供重做和撤销功能.</p>\n<p>具体的重做和撤销代码我这里就展开了，实际逻辑很简单，就是从数组中取出对应的命令执行相关的操作，然后更新索引即可。</p>\n<h2 id=\"32-和框架结合\">3.2 和框架结合</h2>\n<p>我引入命令模式，其实是希望通过命令来进行数据的更新和视图的更新，但是 <code>Vue</code> 作为数据绑定的框架，当视图改变后，数据自动更新了，并没有在命令类中进行操作。这其实不符合我的预期。这样对后面的重做和撤销操作也会有影响，会造成无法对比更改的问题。</p>\n<p>我的解决方法也很简单，就是当编辑器选中编辑数据时，特定的数据，使用特定的更新命令类记录当前的数据。</p>\n<pre><code class=\"language-js\">watch: {\n    editData  {\n        handler(cur, last) {\n            // 不同数据，设置备份\n            if(cur !== last) {\n                if(this.editType === editTypeConst.hotspot) {\n                    UpdateHotspotCommand.setTarget(cur)\n                }\n            }else {\n                // 相同数据，意味着数据变动\n                const command = new UpdateHotspotCommand(cur)\n                // 管理器实触发罚命令\n                controller.execute(command)\n            }\n        },\n        deep: true\n    }\n}\n\nclass UpdateHotspotCommand extends Command {\n    static target = null\n    \n    static setTarget(data) {\n        this.target = JSON.parse(JSON.stringify(data))\n    }\n    execute() {}\n    undo() {}\n    // 数据变化后，比较数据之间不同的字段\n    getDiffKeys() {}\n\n}\n</code></pre>\n<p>每次选中数据时，就将当前数据备份，当数据更改后就触发对应命令。在命令类中进行数据比较，然后在 \n<code>execute</code>, <code>undo</code> 更改数据和引用对应的类更新视图。 之前重构时还是的必须将类在Vue文件中使用，通过这种方式，完全进行了隔离，每个组件只关心 <code>JSON</code> 数据的改变，视图的更新通过 <code>watch</code> ,生成命令进行控制。</p>\n<p>上面主要讲的是更新命令和 <code>Vue</code> 框架的兼容，其他的删除，添加命令就要简单的多了。</p>\n<h2 id=\"32-命令合并的实现\">3.2 命令合并的实现</h2>\n<p>在进行开发时，有参考 <code>photoshop</code> 历史记录的实现，对于同一个对象同一种操作，历史记录会进行合并，只会出现一条记录。在全景编辑器中也会出现热点移动等多次触发的操作，因此也需要实现命令合并的功能，优化历史记录的展示。</p>\n<p>具体的实现也很简单，在 <code>controller</code> 执行命令时，判断当前命令是否有实现合并的方法，如果有且上一条命令和当前命令是同一命令的实例，就进行比较。</p>\n<p>主要比较数据改变的字段是否一致，如果字段一致，那么就将当前命令更新的部分合并到上一条命令中即可，这样就实现了命令的合并功能。</p>\n<h1 id=\"四-命令模式存在的问题\">四. 命令模式存在的问题</h1>\n<p><code>命令模式</code> 对我们管理应用的数据操作有着很大的好处，但是它也存在一个很明显的问题。就是随着操作的变多，相关的命令文件也会随之膨胀，编辑器几十上百种操作都需要进行定义相关命令类，工作量和代码体积膨胀都是问题。</p>\n<p>但是 <code>命令模式</code> 对于全景编辑器的业务场景十分适合，用户体验也十分友好，毕竟也不想用户每次回撤都黑屏一下。因此基于业务场景，最终还是使用了这套方案</p>\n<h1 id=\"五-最后总结\">五. 最后总结</h1>\n<p>通过对编辑器的历史记录功能开发，我学会了 <code>命令模式</code> 和 <code>快照方式</code> 两种方案。我们在实际业务开发中可以根据业务场景进行技术选型。 如果是简单的H5编辑器，那么 <code>快照方式</code> 就足够了。但如果你的业务场景也和我们的场景类似，数据和预览视图是完全独立的场景，那么 <code>命令模式</code> 是比较合适的。</p>\n<p>没有完美的技术方案， 我们只能选择做相对正确的事而不是做简单的事！</p>\n"
}