{
    "title": "Vue 源码学习 (3) - 组件",
    "excerpt": "一. createComponent Vue 开发就是开发组件，现在我们来看看组件形成 VNode 的逻辑。 在 _createElement 方法中, 在两种场景会调用 createComponent 方法 `ts // tag 是已经声...",
    "updated": "2022-07-03 16:42:09 ",
    "created": "2022-07-03 16:42:09 ",
    "avatar": "https://avatars.githubusercontent.com/u/26271337?v=4",
    "id": 17,
    "content": "<h1 id=\"一-createcomponent\">一. createComponent</h1>\n<p>Vue 开发就是开发组件，现在我们来看看组件形成 VNode 的逻辑。</p>\n<p>在 <code>_createElement</code> 方法中, 在两种场景会调用 createComponent 方法</p>\n<pre><code class=\"language-ts\">// tag 是已经声明过的 components 时\nvnode = createComponent(Ctor, data, context, children, tag)\n// tag 不为字符串时\nvnode = createComponent(tag as any, data, context, children)\n</code></pre>\n<p>初始化时我们传入的值都为 options 对象，对应的实现为</p>\n<pre><code class=\"language-ts\">export function createComponent(\nCtor: typeof Component | Function | ComponentOptions | void,\ndata: VNodeData | undefined,\ncontext: Component,\nchildren?: Array&lt;VNode&gt;,\ntag?: string\n): VNode | Array&lt;VNode&gt; | void {\n    // baseCtor 就是 Vue\n    const baseCtor = context.$options._base\n    // 将当前的 Ctor 传入 Vue.extend 得到新的 Ctor\n    if (isObject(Ctor)) {\n        Ctor = baseCtor.extend(Ctor as typeof Component)\n    }\n\n    data = data || {}\n    resolveConstructorOptions(Ctor as typeof Component)\n    \n    const propsData = extractPropsFromVNodeData(data, Ctor, tag)\n    const listeners = data.on\n    data.on = data.nativeOn\n\n    installComponentHooks(data)\n\n    const name = Ctor.options.name || tag\n    const vnode = new VNode(\n        `vue-component-${Ctor.cid}${name ? `-${name}` : &#39;&#39;}`,\n        data,\n        undefined,\n        undefined,\n        undefined,\n        context,\n        { Ctor, propsData, listeners, tag, children },\n        asyncFactory\n    )\n    return vnode\n}\n</code></pre>\n<p>这里先将传入的 Ctor 通过 Vue.extend 进行扩展</p>\n<pre><code class=\"language-ts\">Vue.extend = function (extendOptions: any): typeof Component {\n    extendOptions = extendOptions || {}\n    const Super = this\n    const SuperId = Super.cid\n    const cachedCtors = extendOptions._Ctor || (extendOptions._Ctor = {})\n\n    if (cachedCtors[SuperId]) {\n        return cachedCtors[SuperId]\n    }\n\n    const name = extendOptions.name || Super.options.name\n    const Sub = function VueComponent(this: any, options: any) {\n\n        this._init(options)\n\n    } as unknown as typeof Component\n    \n    // 通过原型进行继承\n    // Sub.prototype.__proto__ = Suer.prototype\n    Sub.prototype = Object.create(Super.prototype)\n    Sub.prototype.constructor = Sub\n    \n    Sub.cid = cid++\n    Sub.options = mergeOptions(Super.options, extendOptions)\n    Sub[&#39;super&#39;] = Super\n\n    if (Sub.options.props) {\n        initProps(Sub)\n    }\n\n    if (Sub.options.computed) {\n        initComputed(Sub)\n    }\n\n    Sub.extend = Super.extend\n    Sub.mixin = Super.mixin\n    Sub.use = Super.use\n\n\n    ASSET_TYPES.forEach(function (type) {\n        Sub[type] = Super[type]\n    })\n\n    // enable recursive self-lookup\n    if (name) {\n        Sub.options.components[name] = Sub\n    }\n  \n    Sub.superOptions = Super.options\n    Sub.extendOptions = extendOptions\n    Sub.sealedOptions = extend({}, Sub.options)\n    // cache constructor\n    cachedCtors[SuperId] = Sub\n    return Sub\n}\n</code></pre>\n<p>Vue.extend 函数允许我们讲 options 转化为构造函数，平时开发时也会进行使用。</p>\n<p>这里 Vue.extend 创建了 Vue 的子类，并对子类进行缓存。</p>\n<p>在 create-component 方法中 还有个 <code>installComponentHooks</code> 方法，我们看看它的逻辑</p>\n<pre><code class=\"language-ts\">const hooksToMerge = Object.keys(componentVNodeHooks)\n\nfunction installComponentHooks(data: VNodeData) {\n    const hooks = data.hook || (data.hook = {})\n    for (let i = 0; i &lt; hooksToMerge.length; i++) {\n        const key = hooksToMerge[i]\n        const existing = hooks[key]\n        const toMerge = componentVNodeHooks[key]\n        if (existing !== toMerge &amp;&amp; !(existing &amp;&amp; existing._merged)) {\n            hooks[key] = existing ? mergeHook(toMerge, existing) : toMerge\n\n        }\n    }\n}\n</code></pre>\n<p>这里主要是合并自身的 hook 和组件自带的 hook ,组件自带的hook有这些</p>\n<pre><code class=\"language-ts\">const componentVNodeHooks = {\n    init(){}, // 处理keep-alive逻辑 和 挂载子组件\n    prepatch(){}, // 更新子组件\n    insert(){}, // mounted事件， 处理keep-alive activate相关\n    destroy(){}, // 组件销毁\n}\n</code></pre>\n<p>在 patch 方法中会先对 vnode 进行一个判断，如果返回为 true 就不执行下方的插入逻辑了</p>\n<pre><code class=\"language-ts\">if (createComponent(vnode, insertedVnodeQueue, parentElm, refElm)) {\nreturn\n}\n</code></pre>\n<p>所以来看看这个 patch 内部定义的 createComponent 方法</p>\n<pre><code class=\"language-ts\">function createComponent(vnode, insertedVnodeQueue, parentElm, refElm) {\n    let i = vnode.data\n    if (isDef(i)) {\n        if (isDef((i = i.hook)) &amp;&amp; isDef((i = i.init))) {\n            i(vnode, false /* hydrating */)\n        }\n        if (isDef(vnode.componentInstance)) {\n            initComponent(vnode, insertedVnodeQueue)\n            insert(parentElm, vnode.elm, refElm)\n            return true\n        }\n    }\n}\n</code></pre>\n<p>这里判断 如果 vnode 有data的话，代表它是一个组件。然后执行 componentVNodeHooks 中定义的 init 方法</p>\n<pre><code class=\"language-ts\">...\nvnode.componentInstance = createComponentInstanceForVnode(\nvnode,\nactiveInstance\n))\n...\n\n// createComponentInstanceForVnode\nconst options: InternalComponentOptions = {\n_isComponent: true,\n_parentVnode: vnode,\nparent\n}\n\nreturn new vnode.componentOptions.Ctor(options)\n</code></pre>\n<p>这个方法中 执行 createComponent方法， 将 options 的 _isComponent 设为 true。 然后实例化构造函数，执行 _init方法,\n走了  initInternalComponent 函数的逻辑</p>\n<pre><code class=\"language-ts\">if (options &amp;&amp; options._isComponent) {\n    initInternalComponent(vm, options as any)\n}\n</code></pre>\n<p>这个函数就是为了实例内部子组件初始化使用的，优化合并配置的体验</p>\n<pre><code class=\"language-ts\">export function initInternalComponent(\nvm: Component,\noptions: InternalComponentOptions\n) {\n    // 直接获取 构造函数的 options\n    const opts = (vm.$options = Object.create((vm.constructor as any).options))\n    \n    const parentVnode = options._parentVnode\n    opts.parent = options.parent // 父组件实例\n    opts._parentVnode = parentVnode // 父Vnode\n\n\n    const vnodeComponentOptions = parentVnode.componentOptions!\n    opts.propsData = vnodeComponentOptions.propsData\n    opts._parentListeners = vnodeComponentOptions.listeners\n    opts._renderChildren = vnodeComponentOptions.children\n    opts._componentTag = vnodeComponentOptions.tag\n    if (options.render) {\n        opts.render = options.render\n        opts.staticRenderFns = options.staticRenderFns\n    }\n\n}\n</code></pre>\n<p>回到组件 init hook,这里组件会进行手动挂载</p>\n<pre><code class=\"language-ts\">child.$mount(hydrating ? vnode.elm : undefined, hydrating)\n\n// 在客户端\nchild.$mount( undefined, false)\n</code></pre>\n<p>在render 时</p>\n<pre><code class=\"language-ts\">Vue.prototype._render = function (): VNode {\n    const { render, _parentVnode } = vm.$options\n    vm.$vnode = _parentVnode!\n    vnode = render.call(vm._renderProxy, vm.$createElement)\n    ...\n    vnode.$parent = _parentVnode\n}\n</code></pre>\n<p>我看了接下来的流程， 子组件之所以会持有父节点，主要有两个作用</p>\n<ol>\n<li>往父组件的 $children 中push 当前实例<pre><code class=\"language-ts\">parent.$children.push(vm)\nvm.$parent = parent\n</code></pre>\n</li>\n<li>插入dom<pre><code class=\"language-ts\">insert(parentElm, vnode.elm, refElm)\n</code></pre>\n</li>\n</ol>\n<p>最后我们总结 patch 中 createElm方法：</p>\n<blockquote>\n<p>如果传入的<code>vnode</code> 个普通元素， <code>createComponent(vnode, insertedVnodeQueue, parentElm, refElm)</code> 的返回值是 false。接下来的过程就和我们上一章一样了，先创建一个父节点占位符，然后再遍历所有子 VNode 递归调用 <code>createElm</code>，在遍历的过程中，如果遇到子 VNode 是一个组件的 VNode，就走组件初始化和挂载的逻辑，通过一个递归的方式就可以完整地构建了整个组件树。</p>\n</blockquote>\n<h1 id=\"二-配置处理\">二. 配置处理</h1>\n<p>当我们平时开发组件时，会声明很多属性，也会使用 extends, mixin 等服用逻辑。而我们访问属性时直接从 vm 上就能访问的到，那么 Vue 是怎么实现这个配置合并到组件的呢？ 请接着往下看。</p>\n<h2 id=\"2-1实例场景\">2. 1实例场景</h2>\n<p>使用 mergeOptions 将构造器的 options 和 传入的 options 进行合并</p>\n<pre><code class=\"language-ts\">vm.$options = mergeOptions(\n    resolveConstructorOptions(vm.constructor as any),\n    options || {},\n    vm\n)\n</code></pre>\n<p>构造器的 options 包括全局的一些 components, directives, filters等</p>\n<p>接着看看 mergeOptions 的实际逻辑</p>\n<pre><code class=\"language-ts\">export function mergeOptions(\nparent: Record&lt;string, any&gt;,\nchild: Record&lt;string, any&gt;,\nvm?: Component | null\n): ComponentOptions {\n\nif (isFunction(child)) {\n    child = child.options\n}\n\n  \nnormalizeProps(child, vm)\nnormalizeInject(child, vm)\nnormalizeDirectives(child)\n  \nif (!child._base) {\n    if (child.extends) {\n        parent = mergeOptions(parent, child.extends, vm)\n    }\n    if (child.mixins) {\n        for (let i = 0, l = child.mixins.length; i &lt; l; i++) {\n            parent = mergeOptions(parent, child.mixins[i], vm)\n        }\n    }\n}\n\nconst options: ComponentOptions = {} as any\n\nlet key\n\nfor (key in parent) {\n    mergeField(key)\n}\n\nfor (key in child) {\n    if (!hasOwn(parent, key)) {\n        mergeField(key)\n    }\n\n}\n\nfunction mergeField(key: any) {\n    const strat = strats[key] || defaultStrat\n    options[key] = strat(parent[key], child[key], vm, key)\n\n}\n\nreturn options\n\n}\n</code></pre>\n<p>这里的步骤有：</p>\n<ol>\n<li>处理 props, inject, directives, 合并到child.options<ol>\n<li>这里child optinos 最终会由于合并策略 直接合并到options</li>\n</ol>\n</li>\n<li>将 extends 和 mixins 合并到 parent</li>\n<li>然后遍历parent, mergeField 到 options上</li>\n<li>遍历child, 将不在 parent上的属性合并到 options</li>\n<li>最后返回options, 挂载到 vm.options</li>\n</ol>\n<p>mergeField 函数针对不同的 key 值也有不同的合并策略</p>\n<pre><code class=\"language-ts\">const strats = config.optionMergeStrategies\nstrats.props = strats.methods = strats.inject = strats.computed = ...\n\nstrats[hook] = ...\n</code></pre>\n<p>具体每个属性的合并策略，我们后续有兴趣可以仔细看看。</p>\n<h2 id=\"22-组件场景\">2.2 组件场景</h2>\n<p>内部组件都是通过 Vue.extend 扩展为 Vue 的子类, 现在我们再看看 initInternalComponet 的具体逻辑</p>\n<pre><code class=\"language-ts\">export function initInternalComponent(\nvm: Component,\noptions: InternalComponentOptions\n) {\n    const opts = (vm.$options = Object.create((vm.constructor as any).options))\n\n    const parentVnode = options._parentVnode\n    opts.parent = options.parent\n    opts._parentVnode = parentVnode\n    const vnodeComponentOptions = parentVnode.componentOptions!\n    opts.propsData = vnodeComponentOptions.propsData\n    opts._parentListeners = vnodeComponentOptions.listeners\n    opts._renderChildren = vnodeComponentOptions.children\n    opts._componentTag = vnodeComponentOptions.tag\n\n    if (options.render) {\n        opts.render = options.render\n        opts.staticRenderFns = options.staticRenderFns\n\n    }\n\n}\n</code></pre>\n<p>这里的逻辑就是</p>\n<ol>\n<li>将vm.$options 的原型指向 构造器的options</li>\n<li>然后保留 父实例，父 VNode, 还保存propsData等属性</li>\n</ol>\n<p>这里可以看出，组件生成的实例主要还是以原型链为基础，结合简单的对象引用赋值，相比于直接实例化 Vue, 不需要进行那么多 配置的合并，递归和处理。所以官方注释也是这么说的</p>\n<blockquote>\n<p>optimize internal component instantiation\nsince dynamic options merging is pretty slow, and none of the\n internal component options needs special treatment.</p>\n</blockquote>\n<p> 内部组件的配置初始化要比 应用直接初始化要快的多，而且结合缓存，这对性能有极大的帮助</p>\n<h1 id=\"三-组件注册\">三. 组件注册</h1>\n<p>平时注册组件有两种方式，一种是通过 <code>Vue.component</code> 注册全局组件，还有中是在组件内部注册局部组件. 其实原理应该很简单的，全局注册就注册到 <code>Vue.options.components</code>里，局部注册就直接 注册到 <code>vm.$options.components</code>里. 然后组件初始化时混入构造器逻辑，就可以读取到全局组件了。</p>\n<p>接下来我们看看具体逻辑，首先是 全局注册</p>\n<h2 id=\"31-全局注册\">3.1 全局注册</h2>\n<pre><code class=\"language-ts\">// &gt; src/core/global-api/asset.ts\n\nexport function initAssetRegisters(Vue: GlobalAPI) {\n    ASSET_TYPES.forEach(type =&gt; {\n        Vue[type] = function (\n        id: string,\n        definition?: Function | Object\n        ): Function | Object | void {\n            if (type === &#39;component&#39; &amp;&amp; isPlainObject(definition)) {\n                definition.name = definition.name || id\n                definition = this.options._base.extend(definition)\n            }\n            this.options[type + &#39;s&#39;][id] = definition\n            return definition\n        }\n    })\n}\n</code></pre>\n<p>这里注册了 <code>Vue.component</code>,<code>Vue.directive</code>, <code>Vue.filter</code>三个静态方法，我们看下 <code>Vue.component</code>的逻辑。</p>\n<ol>\n<li>通过 <code>Vue.extend</code>将组件扩展为 组件构造器</li>\n<li>存入 <code>Vue.options</code> 中\n这样应用下的每个组件在实例化时，合并配置，都可以使用到这个组件</li>\n</ol>\n<h2 id=\"32-局部注册\">3.2 局部注册</h2>\n<p>局部注册就是实例化合并 <code>option</code> 时， 将 <code>components</code> 合并到 <code>vm.$options.components</code> 上，这样在组件中就可以使用注册的组件了</p>\n<h1 id=\"四-总结\">四. 总结</h1>\n<p>组件这一篇我是看的比较难受的，一开始很难理解内部组件的整体的创建流程。结合网上的文章和源码才断断续续读到差不多。但是对于整个流程还是有点迷糊，后续会绘制完整的流程图，方便理解。</p>\n"
}