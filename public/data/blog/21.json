{
    "title": "我所理解的 React Hooks ",
    "excerpt": "hooks 出现的原因 class 自身存在的问题 组件逻辑复用困难，尽管拥有HOC 和render props ，逻辑复用还是比较困难。 在不同生命周期中执行不同的逻辑，组件会变得越来越复杂。相关的逻辑不好抽离 使用Class 组件只为了...",
    "updated": "2022-07-09 16:05:44 ",
    "created": "2022-07-09 09:28:43 ",
    "avatar": "https://avatars.githubusercontent.com/u/26271337?v=4",
    "id": 21,
    "content": "<h1 id=\"hooks-出现的原因\">hooks 出现的原因</h1>\n<ol>\n<li><p>class 自身存在的问题</p>\n<ol>\n<li>组件逻辑复用困难，尽管拥有HOC 和render props ，逻辑复用还是比较困难。</li>\n<li>在不同生命周期中执行不同的逻辑，组件会变得越来越复杂。相关的逻辑不好抽离</li>\n<li>使用Class 组件只为了组件定义状态，视图和逻辑，其实没有用到Class 的太多功能。而且还需要处理 this的绑定</li>\n<li>通过this 读取状态，是有副作用的。并不能确保状态的正确性\n```tsx\nclass ProfilePage extends React.Component { \n showMessage = () =&gt; {\n alert(&#39;Followed &#39; + this.props.user); \n };</li>\n</ol>\n<p> handleClick = () =&gt; { \n     setTimeout(this.showMessage, 3000); \n }; \n render() {\n     return &lt;button onClick{this.handleClick}&gt;\n         Follow</button>; \n }</p>\n</li>\n</ol>\n<p>}</p>\n<pre><code>例如这个组件，点击发生后，如果props改变，那么最终的弹出的数据并不符合点击时的预期\n\n2. 增强函数组件\n\n之前版本的函数组件太过鸡肋，只能用于展示，自身不拥有状态。\n\n\n# hooks 存在的问题\n## 使用场景限制\n\nReact hook 不能在判断语句中使用\n```ts\ncosnt [count, setCount] = useState(0)\nif(count == 2) {\n   const [num, setNum] = useState(1)\n}\n...\n</code></pre>\n<p>具体原因是和 hook 的原理有关。 hook 通过闭包维护状态，然后将每个hooks注册到一个链表中进行存储，也就是说 hook 本身取值是有顺序的。 </p>\n<p>当组件更新时，hook重新执行，如果通过条件语句新增或者减少 hook 都会影响到原有链表的顺序，造成取值异常。</p>\n<h2 id=\"闭包陷阱\">闭包陷阱</h2>\n<p>当我们使用 useEffect 时，不同的依赖项会有不同的效果。 当我们传入空数组时， 此时的 useEffect 相当于 componentDidMount. 只会执行一次。结合函数使用时，就有可能产生的问题。</p>\n<pre><code class=\"language-ts\">export default function App() {\n  const [count, setCount] = useState(0);\n  useEffect(() =&gt; {\n    const timer = setInterval(() =&gt; {\n      console.log(count);\n    }, 3000);\n  }, []);\n  return (\n    &lt;div className=&quot;App&quot;&gt;\n      &lt;h1&gt; {count}&lt;/h1&gt;\n      &lt;h2 onClick={() =&gt; setCount(count + 1)}&gt;\n        Start editing to see some magic happen!\n      &lt;/h2&gt;\n    &lt;/div&gt;\n  );\n}\n</code></pre>\n<p>这个例子中， 定时器通过闭包获取的变量永远都是第一次渲染时的 count， 导致打印的都是 0.</p>\n<p>其实不止定时器，还有在 useEffect 外部定义的函数，都有可能产生这个问题。</p>\n<p>解决办法：</p>\n<ol>\n<li>useEffect 添加依赖，内部函数使用到了哪个变量，就加入到依赖项。函数也是如此<pre><code class=\"language-ts\"> const [count, setCount] = useState(0);\n  useEffect(() =&gt; {\n const timer = setInterval(() =&gt; {\n   console.log(count);\n }, 3000);\n return () =&gt; {\n   clearInterval(timer)\n }\n  }, [count]);\n</code></pre>\n</li>\n<li>使用useRef, 由于 ref是一个对象，它的 current 才指向真实的值。所以可以避免这个问题</li>\n</ol>\n"
}