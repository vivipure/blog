{
    "title": "Vue 源码学习 (4) - 响应式篇",
    "excerpt": "一. 数据初始化 如果有人问 Vue 的响应式是怎么实现的，大多数人会回答 通过数据劫持，利用 Object.defineProperty 劫持 getter 和 setter 实现的。数据赋值时，更新视图。然后数组 通过重写数组的 pro...",
    "updated": "2022-07-03 16:42:54 ",
    "created": "2022-07-03 16:42:54 ",
    "avatar": "https://avatars.githubusercontent.com/u/26271337?v=4",
    "id": 18,
    "content": "<h1 id=\"一-数据初始化\">一. 数据初始化</h1>\n<p>如果有人问 Vue 的响应式是怎么实现的，大多数人会回答 通过数据劫持，利用 <code>Object.defineProperty</code> 劫持 getter 和 setter 实现的。数据赋值时，更新视图。然后数组 通过重写数组的 prototype 方法实现劫持。</p>\n<p>上面的说法其实也没多错，但是不够细节。例如依赖时怎么收集的，数据变化时，怎么知道该更新哪些数据？定义在 option 上的数据，为何通过 this 可以直接访问的到？ 带着这些疑问，我们继续源码探索之旅。</p>\n<p>首先来到数据初始化的逻辑</p>\n<pre><code class=\"language-ts\">// &gt; src/core/instance/state.ts\nexport function initState(vm: Component) {\n    const opts = vm.$options\n    if (opts.props) initProps(vm, opts.props)\n        initSetup(vm)\n    if (opts.methods) initMethods(vm, opts.methods)\n    if (opts.data) {\n        initData(vm)\n    } else {\n        const ob = observe((vm._data = {}))\n        ob &amp;&amp; ob.vmCount++\n    }\n    if (opts.computed) initComputed(vm, opts.computed)\n    if (opts.watch &amp;&amp; opts.watch !== nativeWatch) {\n        initWatch(vm, opts.watch)\n    }\n}\n</code></pre>\n<h2 id=\"11-initprops\">1.1 initProps</h2>\n<pre><code class=\"language-ts\">function initProps(vm: Component, propsOptions: Object) {\n    const propsData = vm.$options.propsData || {}\n    const props = (vm._props = shallowReactive({}))\n    const keys: string[] = (vm.$options._propKeys = [])\n    const isRoot = !vm.$parent\n\n    if (!isRoot) {\n        toggleObserving(false)\n    }\n    for (const key in propsOptions) {\n        keys.push(key)\n        const value = validateProp(key, propsOptions, propsData, vm)\n        defineReactive(props, key, value)\n\n        if (!(key in vm)) {\n            proxy(vm, `_props`, key)\n        }\n\n    }\n    toggleObserving(true)\n}\n</code></pre>\n<ol>\n<li>调用 <code>defineReactive</code> 将每个 prop key 变成响应式</li>\n<li>通过 proxy 方法将 vm._props.* 代理到 vm.* 上</li>\n</ol>\n<p>这里有一个 propsData ，这是给组件传入的 props 值</p>\n<h1 id=\"12-initdata\">1.2 initData</h1>\n<pre><code class=\"language-ts\">function initData(vm: Component) {\n    let data: any = vm.$options.data\n    data = vm._data = isFunction(data) ? getData(data, vm) : data || {}\n    // proxy data on instance\n    const keys = Object.keys(data)\n    let i = keys.length\n\n    while (i--) {\n        const key = keys[i]\n         if (!isReserved(key)) {\n            proxy(vm, `_data`, key)\n        }\n    }\n\n    // observe data\n    const ob = observe(data)\n    ob &amp;&amp; ob.vmCount++\n}\n</code></pre>\n<p>这里通过 proxy 方法将 data 中的 key 代理到 vm上，还有通过 observe 方法观测整个 data数据。</p>\n<p>数据初始化就先讲 initProps 和 initState, 通过这两个方法，我们了解到了三个重要函数 ，defineReactive , proxy, oberve 。接下来我们来看下这三个函数的主要逻辑。</p>\n<h1 id=\"13-proxy\">1.3 proxy</h1>\n<p>proxy 代理属性到 vm 上，这也是为什么我们写在 option 中的配置，可以直接通过 this 访问的到原因。</p>\n<pre><code class=\"language-ts\">const sharedPropertyDefinition = {\n    enumerable: true,\n    configurable: true,\n    get: noop,\n    set: noop\n}\n\n\nexport function proxy(target: Object, sourceKey: string, key: string) {\n    sharedPropertyDefinition.get = function proxyGetter() {\n        return this[sourceKey][key]\n    }\n    sharedPropertyDefinition.set = function proxySetter(val) {\n        this[sourceKey][key] = val\n    }\n    Object.defineProperty(target, key, sharedPropertyDefinition)\n}\n</code></pre>\n<p>逻辑很简单，就是通过 Object.defineProperty 劫持属性的访问，将对vm的操作，映射为被代理数据的操作。</p>\n<h1 id=\"14-observe\">1.4 observe</h1>\n<pre><code class=\"language-ts\">export function observe(value: any, shallow?: boolean): Observer | void {\n    let ob: Observer | void\n     if (\n\n        shouldObserve &amp;&amp;\n        !isServerRendering() &amp;&amp;\n        (isArray(value) || isPlainObject(value)) &amp;&amp;\n        Object.isExtensible(value) &amp;&amp;\n        !value.__v_skip\n    ) {\n        ob = new Observer(value, shallow)\n    }\n    return ob\n}\n</code></pre>\n<p>符合条件时，实例化一个 Observer 对象实例</p>\n<pre><code class=\"language-ts\">export class Observer {\n    dep: Dep\n    vmCount: number \n\n    constructor(public value: any, public shallow = false) {\n        this.dep = new Dep()\n        this.vmCount = 0\n        def(value, &#39;__ob__&#39;, this)\n        if (isArray(value)) {\n            protoAugment(value, arrayMethods)\n            if (!shallow) {\n                this.observeArray(value)\n            }\n\n        } else {\n            this.walk(value, shallow)\n        }\n    }\n\n    walk(obj: object, shallow: boolean) {\n        const keys = Object.keys(obj)\n        for (let i = 0; i &lt; keys.length; i++) {\n            const key = keys[i]\n            defineReactive(obj, key, NO_INIITIAL_VALUE, undefined, shallow)\n        }\n\n    }\n  \n    observeArray(items: Array&lt;any&gt;) {\n        for (let i = 0, l = items.length; i &lt; l; i++) {\n            observe(items[i])\n        }\n    }\n\n}\n</code></pre>\n<p>这里的逻辑主要是对 Array 和 Object 进行数据劫持</p>\n<ol>\n<li>如果是数组，就劫持原型方法，然后对每一项进行递归 observe</li>\n<li>如果是对象，就对每一个属性执行 defineReactive</li>\n</ol>\n<h1 id=\"15-definereactive\">1.5 defineReactive</h1>\n<p>initProps 和 initData 实质上都使用到了这个方法，现在看看它的逻辑</p>\n<pre><code class=\"language-ts\">export function defineReactive(\n    obj: object,\n    key: string,\n    val?: any,\n    customSetter?: Function | null,\n    shallow?: boolean\n) {\n\n    const dep = new Dep()\n    const property = Object.getOwnPropertyDescriptor(obj, key)\n\n    const getter = property &amp;&amp; property.get\n    const setter = property &amp;&amp; property.set\n\n\n    let childOb = !shallow &amp;&amp; observe(val)\n    Object.defineProperty(obj, key, {\n        enumerable: true,\n        configurable: true,\n        get: function reactiveGetter() {\n            const value = getter ? getter.call(obj) : val\n            if (Dep.target) {\n                dep.depend()\n                if (childOb) {\n                    childOb.dep.depend()\n                    if (isArray(value)) {\n                    dependArray(value)\n                    }\n                }\n            }\n            return isRef(value) ? value.value : value\n        },\n\n        set: function reactiveSetter(newVal) {\n            const value = getter ? getter.call(obj) : val\n            if (!hasChanged(value, newVal)) {\n                return\n            }\n\n            if (setter) {\n                setter.call(obj, newVal)\n            } else if (getter) {\n                return\n            } else if (isRef(value) &amp;&amp; !isRef(newVal)) {\n                value.value = newVal\n                return\n            } else {\n                val = newVal\n            }\n\n            childOb = !shallow &amp;&amp; observe(newVal)\n            dep.notify()\n        }\n\n    })\n    return dep\n\n}\n</code></pre>\n<p>这里执行的逻辑为：</p>\n<ol>\n<li>拿到原始的 getter和 setter,方便后续劫持时使用</li>\n<li>如果不是 shallow, 就Observe当前数据</li>\n<li>getter函数中，如果Dep.target 存在，就执行depend<ol>\n<li>自身depend</li>\n<li>childOb 的depend</li>\n</ol>\n</li>\n<li>setter函数中<ol>\n<li>利用原始getter得到原始值，和新值比较，如果不变就 return</li>\n<li>执行赋值逻辑，重新对当前属性observe</li>\n<li>执行 notify</li>\n</ol>\n</li>\n</ol>\n<p>这个函数也是通过递归对整个对象进行劫持，这样保证了无论是多深的数据结构，任何值变化都能执行 notify的逻辑</p>\n<p>上面的方法中，我们能看到 Dep 这个类，在执行getter时，会触发 dep.depend 来进行依赖收集 ，setter 时会触发 dep.notify方法进行派发更新。其实这就是 Vue 响应式的基本原理。接下来我们来看下 Dep 这个类</p>\n<h1 id=\"二-dep\">二. Dep</h1>\n<p>Dep 类的定义</p>\n<pre><code class=\"language-ts\">export interface DepTarget extends DebuggerOptions {\n    id: number\n    addDep(dep: Dep): void\n    update(): void\n}\n\nexport default class Dep {\n    static target?: DepTarget | null\n    id: number\n    subs: Array&lt;DepTarget&gt;\n\n    constructor() {\n        this.id = uid++\n        this.subs = []\n    }\n    addSub(sub: DepTarget) {\n        this.subs.push(sub)\n    }\n    removeSub(sub: DepTarget) {\n        remove(this.subs, sub)\n    }\n    depend() {\n        if (Dep.target) {\n            Dep.target.addDep(this)\n        }\n    }\n    notify() {\n        const subs = this.subs.slice()\n        for (let i = 0, l = subs.length; i &lt; l; i++) {\n            subs[i].update()\n        }\n    }\n}\n</code></pre>\n<p>Dep 拥有一个静态属性 target, 全局唯一。在使用 depend方法时 实际上是对当前 target 添加 addDep. 在使用 notify 方法会对当前所有的订阅执行更新方法。</p>\n<p>所以一切的关键都在于 target.addDep 的方法执行的逻辑。</p>\n<p>实际上 Dep 和 Watcher 相辅相成，target 指向的一般是 watcher, subs也是 watcher数组。</p>\n<h1 id=\"三-watcher\">三. Watcher</h1>\n<p>在前面的文章中，我们了解到有渲染 watcher,。</p>\n<p>我们平时在 options 时可以自定义 watcher , 还有我们使用的 computed ，它本质上也是一个 watcher。</p>\n<p>总的来说，Vue 的响应式的实现就是依赖 Watcher 的。现在我们就来看看 Watcher 的逻辑。</p>\n<pre><code class=\"language-ts\">&gt; core/observer/watcher.ts\n\nexport default class Watcher implements DepTarget {\n    vm?: Component | null\n    expression: string\n    cb: Function\n    id: number\n    deep: boolean\n    user: boolean\n    lazy: boolean\n    sync: boolean\n    dirty: boolean\n    active: boolean\n    deps: Array&lt;Dep&gt;\n    newDeps: Array&lt;Dep&gt;\n    depIds: SimpleSet\n    newDepIds: SimpleSet\n    before?: Function\n    onStop?: Function\n    noRecurse?: boolean\n    getter: Function\n    value: any\n\n    constructor(\n    vm: Component | null,\n    expOrFn: string | (() =&gt; any),\n    cb: Function,\n    options?: WatcherOptions | null,\n    isRenderWatcher?: boolean\n    ) {\n        recordEffectScope(this, activeEffectScope || (vm ? vm._scope : undefined))\n        if ((this.vm = vm)) {\n\n            if (isRenderWatcher) {\n\n            vm._watcher = this\n\n            }\n\n        }\n        if (options) {\n            this.deep = !!options.deep\n            this.user = !!options.user\n            this.lazy = !!options.lazy\n            this.sync = !!options.sync\n            this.before = options.before\n        } else {\n            this.deep = this.user = this.lazy = this.sync = false\n        }\n\n        this.cb = cb\n        this.id = ++uid // uid for batching\n        this.active = true\n        this.dirty = this.lazy // for lazy watchers\n        this.deps = []\n        this.newDeps = []\n        this.depIds = new Set()\n        this.newDepIds = new Set()\n        this.expression = &#39;&#39;\n\n        if (isFunction(expOrFn)) {\n            this.getter = expOrFn\n        } else {\n            this.getter = parsePath(expOrFn)\n        }\n        this.value = this.lazy ? undefined : this.get()\n    }\n\n  \n\n    get() {\n        pushTarget(this)\n        let value\n        const vm = this.vm\n        try {\n            value = this.getter.call(vm, vm)\n        } finally {\n            if (this.deep) {\n                traverse(value)\n            }\n            popTarget()\n            this.cleanupDeps()\n        }\n        return value\n    }\n\n    addDep(dep: Dep) {\n        const id = dep.id\n        if (!this.newDepIds.has(id)) {\n            this.newDepIds.add(id)\n            this.newDeps.push(dep)\n            if (!this.depIds.has(id)) {\n                dep.addSub(this)\n            }\n        }\n\n    }\n\n  \n\n    cleanupDeps() {\n        let i = this.deps.length\n\n        while (i--) {\n            const dep = this.deps[i]\n            if (!this.newDepIds.has(dep.id)) {\n                dep.removeSub(this)\n            }\n        }\n\n        let tmp: any = this.depIds\n        this.depIds = this.newDepIds\n        this.newDepIds = tmp\n        this.newDepIds.clear()\n\n        tmp = this.deps\n        this.deps = this.newDeps\n        this.newDeps = tmp\n        this.newDeps.length = 0\n    }\n\n  \n\n    update() {\n        if (this.lazy) {\n            this.dirty = true\n        } else if (this.sync) {\n            this.run()\n        } else {\n            queueWatcher(this)\n\n        }\n\n    }\n\n    run() {\n        if (this.active) {\n            const value = this.get()\n            if (\n                value !== this.value ||\n            isObject(value) ||\n            this.deep\n            ) {\n            const oldValue = this.value\n            this.value = value\n            if (this.user) {\n                const info = `callback for watcher &quot;${this.expression}&quot;`\n                invokeWithErrorHandling(\n                    this.cb,\n                    this.vm,\n                    [value, oldValue],\n                    this.vm,\n                    info\n                )\n\n                } else {\n                    this.cb.call(this.vm, value, oldValue)\n                }\n            }\n        }\n    }\n\n    evaluate() {\n        this.value = this.get()\n        this.dirty = false\n    }\n\n    depend() {\n        let i = this.deps.length\n        while (i--) {\n            this.deps[i].depend()\n        }\n    }\n\n    teardown() {\n        if (this.vm &amp;&amp; !this.vm._isBeingDestroyed) {\n            remove(this.vm._scope.effects, this)\n        }\n        if (this.active) {\n            let i = this.deps.length\n            while (i--) {\n                this.deps[i].removeSub(this)\n            }\n            this.active = false\n            if (this.onStop) {\n                this.onStop()\n            }\n\n        }\n\n    }\n\n}\n</code></pre>\n<p>在 Watcher 类中，有几个属性需要注意</p>\n<pre><code class=\"language-ts\">deps: Array&lt;Dep&gt; // 依赖数组\nnewDeps: Array&lt;Dep&gt; // 依赖数组\ndepIds: SimpleSet // 依赖id set\nnewDepIds: SimpleSet // 依赖id set\n</code></pre>\n<h2 id=\"31-依赖收集和派发更新\">3.1 依赖收集和派发更新</h2>\n<p>在 Watcher 初始化时，会执行自己的 get方法</p>\n<pre><code class=\"language-ts\">\nthis.getter = expOrFn\nthis.value = this.lazy ? undefined : this.get()\n}\n\nget() {\n    pushTarget(this)\n    let value\n    const vm = this.vm\n    ...\n    value = this.getter.call(vm, vm)\n    ...\n    if (this.deep) {\n        traverse(value)\n    }\n    popTarget()\n    this.cleanupDeps()\n    return value\n\n}\n</code></pre>\n<p>get 方法中会执行 pushTarget 和 popTarget 方法</p>\n<pre><code class=\"language-ts\">export function pushTarget(target?: DepTarget | null) {\n    targetStack.push(target)\n    Dep.target = target\n}\nexport function popTarget() {\n    targetStack.pop()\n    Dep.target = targetStack[targetStack.length - 1]\n}\n</code></pre>\n<p>pushTarget 方法就是把当前的 watcher 设为 Dep.target并压栈</p>\n<p>然后执行 this.getter 方法，会想 <code>mountComponent</code> 方法，在实例化 在渲染 <code>watcher</code> 中， <code>getter</code> 方法传入的是 <code>updateCompontent</code></p>\n<pre><code class=\"language-ts\">updateComponent = () =&gt; {\n    vm._update(vm._render(), hydrating)\n}\n</code></pre>\n<p>这里 vm.render() 生成 VNode 时会触发 vm上响应式数据的 getter , 也因此调用 <code>dep.depend()</code> 方法，也就是 <code>Dep.target.addDep(this)</code>，也就是当前 watcher 执行 addDep方法</p>\n<pre><code class=\"language-ts\">addDep(dep: Dep) {\n    const id = dep.id\n    if (!this.newDepIds.has(id)) {\n        this.newDepIds.add(id)\n        this.newDeps.push(dep)\n        if (!this.depIds.has(id)) {\n            dep.addSub(this)\n        }\n    }\n}\n</code></pre>\n<p>这里 watcher 收集了数据的依赖，数据的依赖也收集了 watcher 的依赖。然后执行 popTarget 将当前Dep.tareget 恢复成上一次的状态</p>\n<pre><code class=\"language-ts\">popTarget()\nthis.cleanupDeps()\n</code></pre>\n<p>这里除了 popTarget 之外， 这里还执行了 this.cleanupDesp 方法</p>\n<pre><code class=\"language-ts\">cleanupDeps() {\n    let i = this.deps.length\n    while (i--) {\n        const dep = this.deps[i]\n        if (!this.newDepIds.has(dep.id)) {\n            dep.removeSub(this)\n        }\n    }\n    let tmp: any = this.depIds\n    this.depIds = this.newDepIds\n    this.newDepIds = tmp\n    this.newDepIds.clear()\n    tmp = this.deps\n    this.deps = this.newDeps\n    this.newDeps = tmp\n    this.newDeps.length = 0\n}\n</code></pre>\n<p>这里的逻辑就是将没有依赖进行更新，对没有用到的依赖进行移除。</p>\n<p>所以通过 watcher 和 Dep.depend  在组件进行渲染时，触发数据的getter，进行依赖的收集。这里watcher 也收集了依赖，主要是为了每次更新能够移除不再需要的依赖，使更新更加颗粒度。</p>\n<p>所以当数据更新，触发 setter 时，会触发当前数据的 <code>dep.notify</code>, 然后将 dep 所有的依赖 sub，触发 sub.update. 也就是当前 渲染 watcher 的 update 方法</p>\n<pre><code class=\"language-ts\">update() {\n    if (this.lazy) {\n        this.dirty = true\n    } else if (this.sync) {\n        this.run()\n    } else {\n        queueWatcher(this)\n    }\n\n}\n</code></pre>\n<p>这里 渲染 watcher 会走 queueWatcher 的逻辑，至于 lazy 和 sync 会和其他功能的实现有关系，我们后面再专门去讲。</p>\n<pre><code class=\"language-ts\">export function queueWatcher(watcher: Watcher) {\n    const id = watcher.id\n    if (has[id] != null) {\n        return\n    }\n    if (watcher === Dep.target &amp;&amp; watcher.noRecurse) {\n        return\n    }\n    has[id] = true\n    if (!flushing) {\n        queue.push(watcher)\n    } else {\n        let i = queue.length - 1\n        while (i &gt; index &amp;&amp; queue[i].id &gt; watcher.id) {\n            i--\n        }\n        queue.splice(i + 1, 0, watcher)\n    }\n\n    if (!waiting) {\n        waiting = true\n        nextTick(flushSchedulerQueue)\n    }\n}\n</code></pre>\n<p>我们可以看到这里的逻辑就是讲当前的watcher push 到队列中，然后在 nextTick 的回调中执行 flushSchedulerQueue方法。因此我们可知，并不是每次数据更新，视图都会更新，而是push 到队列中，进行批量更新。</p>\n<pre><code class=\"language-ts\">function flushSchedulerQueue() {\n    currentFlushTimestamp = getNow()\n    flushing = true\n    let watcher, id\n    queue.sort((a, b) =&gt; a.id - b.id)\n    for (index = 0; index &lt; queue.length; index++) {\n        watcher = queue[index]\n        if (watcher.before) {\n            watcher.before()\n        }\n        id = watcher.id\n        has[id] = null\n        watcher.run()\n    }\n\n    const activatedQueue = activatedChildren.slice()\n    const updatedQueue = queue.slice()\n    resetSchedulerState()\n    // 触发hook\n    callActivatedHooks(activatedQueue)\n    callUpdatedHooks(updatedQueue)\n}\n</code></pre>\n<p>flushSchedulerQueue 逻辑为：</p>\n<ol>\n<li>对queue进行排序<ol>\n<li>保证 父组件比子组件先更新</li>\n<li>用户自定义 watcher 比 渲染 watcher 先执行</li>\n<li>如果一个组件被父组件 watcher 执行时销毁，那么该组件的watcher 可以不被执行</li>\n</ol>\n</li>\n<li>在遍历中执行wachter.run 的方法，而且在watcher 执行过程中可能会添加新的watcher到队列，所以这里用了传统的 for 循环，每次都会判断 length<pre><code class=\"language-ts\">let i = queue.length - 1\nwhile (i &gt; index &amp;&amp; queue[i].id &gt; watcher.id) {\n i--\n}\nqueue.splice(i + 1, 0, watcher)\n</code></pre>\n</li>\n<li>执行 resetSchedulerState 函数，重置状态和队列<pre><code class=\"language-ts\">function resetSchedulerState() {\n index = queue.length = activatedChildren.length = 0\n has = {}\n waiting = flushing = false\n}\n</code></pre>\n</li>\n</ol>\n<p>在 watcher.run 函数中</p>\n<pre><code class=\"language-ts\">run() {\n    if (this.active) {\n        const value = this.get()\n        if (\n            value !== this.value ||\n            isObject(value) ||\n            this.deep\n        ) {\n            const oldValue = this.value\n            this.value = value\n            this.cb.call(this.vm, value, oldValue)\n        }\n    }\n}\n</code></pre>\n<p>run 方法，先执行 get 方法，然后执行 回调。 对于渲染 watcher 就是执行 udpateComponent 方法，对于用户自定义的watcher, 也就是执行我们定义执行的回调。</p>\n<h1 id=\"四-响应式存在的问题\">四. 响应式存在的问题</h1>\n<p>在进行业务开发时，我们知道给对象添加新的key值，视图不会更新，这是因为当前的key 值并未被劫持, 不能触发setter.</p>\n<p>而数组改动某一项的值也存在这个问题，而数组是因为劫持的是原型方法，直接根据索引改值也不会触发 dep.notify 的逻辑。</p>\n<p>而我们针对这种情况会使用 $set 函数解决这种情况。</p>\n<pre><code class=\"language-ts\">export function set(\ntarget: any[] | Record&lt;string, any&gt;,\nkey: any,\nval: any\n): any {\n\n\n    if (isArray(target) &amp;&amp; isValidArrayIndex(key)) {\n        target.length = Math.max(target.length, key)\n        target.splice(key, 1, val)\n        return val\n    }\n\n    if (key in target &amp;&amp; !(key in Object.prototype)) {\n        target[key] = val\n        return val\n    }\n\n    const ob = (target as any).__ob__\n\n    if ((target as any)._isVue || (ob &amp;&amp; ob.vmCount)) {\n        return val\n    }\n\n    if (!ob) {\n        target[key] = val\n        return val\n    }\n\n    defineReactive(ob.value, key, val)\n    ob.dep.notify()\n    return val\n}\n</code></pre>\n<ol>\n<li>如果是改变数组的值，就使用 splice 方法，触发更新</li>\n<li>如果本身在target上，直接复制并返回</li>\n<li>如果 target 不是响应式对象，直接赋值</li>\n<li>对当前target 的 key 值进行响应式处理</li>\n<li>通知 dep 更新</li>\n</ol>\n<h1 id=\"五-总结\">五. 总结</h1>\n<p>看到现在，我们知道了 数据初始化时 是如何变成 响应式数据的，然后知道了 依赖如何收集和更新如何派发。 而且 数据触发更新，并不会直接更新，而是进入到队列中，在nextTick的回调中进行更新操作。</p>\n<p>后面文章会讲下 nextTick 的逻辑，还有在 watcher 中我们漏掉的逻辑，这也会涉及到 computed 和 用户自定义 watcher 的实现。</p>\n<p>这里补一张 总体的流程图\n<img src=\"https://ustbhuangyi.github.io/vue-analysis/assets/reactive.png\" alt=\"\"></p>\n"
}