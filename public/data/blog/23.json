{
    "title": "提供业务能力，SDK的开发（二）",
    "excerpt": "一. 写在前面 之前文章讲了 SDK开发的背景，和具体封装的逻辑。最近有用户使用我的SDK进行二次开发，对接的过程中我发现SDK存在一些问题，例如 使用方式，对接方式。因此我根据这些问题，将SDK进行了重构。 二. 重构 框架通过暴露全局函...",
    "updated": "2022-08-09 15:15:54 ",
    "created": "2022-08-07 03:55:39 ",
    "avatar": "https://avatars.githubusercontent.com/u/26271337?v=4",
    "id": 23,
    "content": "<h1 id=\"一-写在前面\">一. 写在前面</h1>\n<p>之前文章讲了 SDK开发的背景，和具体封装的逻辑。最近有用户使用我的SDK进行二次开发，对接的过程中我发现SDK存在一些问题，例如 使用方式，对接方式。因此我根据这些问题，将SDK进行了重构。</p>\n<h1 id=\"二-重构\">二. 重构</h1>\n<p>框架通过暴露全局函数的方式来暴露能力，第三方通过覆写对应的函数来实现能力的调用。</p>\n<p>我开发的SDK讲这些全局函数再次进行封装，通过 发布订阅 的设计模式进行通信。但是SDK 的暴露方式还是通过全局对象进行暴露，第三方在进行二次开发时，需要讲他们的JS 放到 我们的JS 逻辑之下才能运行。而且通\n过全局变量这种方式，无法进行友好的类型提示，根据文档进行开发，开发体验不是很友好。</p>\n<p>所以我对SDK进行了抽离，变为一个独立的 NPM 包。第三方开发时可以通过引入NPM包的形式进行开发。</p>\n<h2 id=\"2-1-环境\">2. 1 环境</h2>\n<ul>\n<li>构建工具 ： Vite</li>\n<li>插件： <a href=\"https://www.npmjs.com/package/rollup-plugin-typescript2\">rollup-plugin-typescript2</a></li>\n<li>语言：TypeScript</li>\n</ul>\n<p>使用 <code>rollup-plugin-typescript2</code> 可以在打包时生成 <code>.d.ts</code> 文件，其他人在使用我们的包时，通过JS开发也能获得类型提醒，使用体验十分的友好。</p>\n<h2 id=\"22-类型体操\">2.2 类型体操</h2>\n<p>其实通过 TypeScript 开发和 JavaScript 开发区别并不大，无非就是加一些类型注解。但是我之所以使用 TypeScript ，还是希望通过 TypeScript 强大的类型提示可以让用户减少看文档的时间。</p>\n<p>举个例子，SDK 通过 发布订阅 分发事件，不同的事件的返回值是不同的。 我想实现的效果是用户订阅不同的事件时，类型提醒可以返回对应事件的值。</p>\n<p>灵感来源： <a href=\"https://twitter.com/mattpocockuk/status/1549721729630625799\">https://twitter.com/mattpocockuk/status/1549721729630625799</a></p>\n<p>想法很简单，实现有点难。这里我参考了上面推文的例子：<a href=\"https://www.typescriptlang.org/play?#code/JYWwDg9gTgLgBAbzgMTgXzgMyhEcBEMAzgLQwQQA2ARgKaUz4DcAUCzAJ5i1wBCAhkVoAlCAFcYtKAGEIAO0zAA5nAC8cYbQDG0ACYAeIjCjA5SgDSI4Q-lC0ALAPwAua8dNKA2gF10APlYWHTkjOBB+AGsRcUkoNTh9ABVZBWU4WgAPSTldIj5BaIkpFMUlPwAKFjg4AH1g0tdkADoAOVscAHckkuU-cxYASjU-RCq4KFoYMSg5UerqpQhEiFck0SL0rNocvKiOCEw4ZPlSy0SAZVpbB3jj1K9E9clvT3wbO3t8bwqx+fGY2iuR4A-p-arvBwuI6Xa72TbZXJuExmHy-MGOKyeGEfAAKtn4eFM0KuH08cjEIDoUG83ihRmRKjQaL+rjktAAblJQfMhqoRghmXBKJM4GyOk8eOpzu4zOUcEUBoEwXBgIdyhD7EMBcrqmKJXAANTqMVwACqwgAMtiHHioASiJUdfMNXBBBptHpDDKLEiPH1BdUBk1yNKGeVFYKmcqOqZdBAOk1KBAtPwYMB5E17BNDsbaOKAaw-mhuWhWKW2MFQvLJHl1OEohKoOVtQQAPT4VwIYtjfCt3SCezUCC2XQdubOkkOVyvMD8JS0fCWfDcKB4+eLghEXCTeweL4l-poCMsau0IhNRbLcq9-tEQfDqCjywt2fz1z4ACMi7GW5AO4877fkegSnuel4QNe7YRkAA\">makeRouter</a>，这个例子通过 路由配置 让返回的路由实例能够正确提醒路由所对应的query.</p>\n<p>我最终实现的效果如下：</p>\n<pre><code class=\"language-ts\">import { F } from &quot;ts-toolbelt&quot;;\n\ntype BaseEventConfig = Record&lt;string, string[]&gt;\n\nconst makeEvents= &lt;TConfig extends BaseEventConfig&gt;(_config: F.Narrow&lt;TConfig&gt;) =&gt; ({\n    $on: &lt;EventName extends keyof TConfig, Response = TConfig[EventName]&gt;(eventName: EventName, callback: ResCallback&lt; Response extends string[] ? { [SearchParam in Response[number]]?: string } : never, EventName&gt; ):void =&gt; {\n    \n    }\n\n})\n\ntype ResCallback&lt;T, E&gt; = (e: {\n    data: T\n    preventDefault: () =&gt; void\n    type: E\n}) =&gt; void\n\n// test\n\nlet emitter = makeEvents({\n    &#39;page:change1&#39;: [&quot;pageName&quot;,&quot;pageParams&quot;,&quot;pageTitle&quot;,&quot;rid&quot;],\n    &#39;page:change2&#39;: [&quot;aadfa1&quot;,&quot;bbb1&quot;]\n})\n\nemitter.$on(&#39;page:change1&#39;, e =&gt; {\n    e.data.pageName\n    e.data.pageParams\n    e.data.pageTitle\n    e.data.rid\n})\n\nemitter.$on(&#39;page:change2&#39;, e =&gt; {\n    e.data.aadfa1\n    e.data.bbb1\n})\n</code></pre>\n<p>利用 类型收紧和泛型，我在 TypeScript 传入相关事件的配置，用户在使用时就能从不同的事件得到不通的类型提示，that&#39;s  cool!</p>\n<h2 id=\"23-使用场景\">2.3 使用场景</h2>\n<p>用户在使用SDK时一般有两种场景，一种是在现有HTML里嵌入自身逻辑，还有一种是通过 iframe 嵌入我们的物料，然后在 iframe 外部写自己的逻辑。</p>\n<p>第一种方式SDK是能够正常使用的，但是通过 iframe 方式，SDK并不能生效。因为我们的SDK是通过拦截 window 上的事件进行重写，在进行事件分发。iframe 模式的 window 并不一致，所以SDK无法正常使用。</p>\n<p>兼容也很简单，提供一个方法进行初始化</p>\n<pre><code class=\"language-ts\">SDK.init()\n</code></pre>\n<p>不传值的情况就使用当前 window，拦截相关函数。 传值时就传入对应的iframe DOM即可。</p>\n<pre><code class=\"language-ts\">SDK.init(iframe)\n//\ninit(iframe) {\n    let global = window\n    if(iframe) {\n        global = iframe.contentWindow\n    } \n    registProxy(global)\n}\n</code></pre>\n<p>这样我们的SDK既能支持当前物料的开发，也能支持iframe嵌入</p>\n<h2 id=\"24-发布\">2.4 发布</h2>\n<p>作为SDK,通过全局变量的形式暴露对于开发者是不友好的，更好的方式是发布到 npm 上提供给开发者下载</p>\n<ol>\n<li>注册账号，可以添加组织，让包名拥有scope</li>\n<li>package.json 配置包信息，入口文件</li>\n<li>配置.npmignore, 忽略上传文件</li>\n<li>npm login</li>\n<li>npm publish(组织包，需要执行 npm publish --access public)</li>\n</ol>\n<p>更新版本时，先 npm version patch 再 publish</p>\n<h1 id=\"三-文档\">三. 文档</h1>\n<p>其实有了 TypeScript 和相关注释，用户在进行开发时不借助文档也能够很好的开发。但是文档还是很重要的。</p>\n<p>当用户想接入我们的SDK时，他接触的第一个东西肯定是文档。文档可以告诉他 SDK 能够提供的能力，已经如何进行接入。</p>\n<p>写文档的确很烦，但当我们自己开发时又希望其他人写文档。很矛盾，又很真实。</p>\n<p>文档的结构我借鉴了常用的文档模式。</p>\n<ol>\n<li>功能介绍</li>\n<li>安装</li>\n<li>快速使用</li>\n<li>事件</li>\n<li>模块</li>\n</ol>\n<p>写完这些，快速对接基本上没啥问题了。</p>\n<h1 id=\"四-界限\">四. 界限</h1>\n<p>写 SDK 的主要目的时暴露自身的能力，因此我们需要注意能力的界限。</p>\n<p>例如用户在使用我们的SDK时想要进行数据埋点，获取访问用户的IP. 这个能力就不应该由我们提供，而是用户自己使用第三方库来开发。</p>\n<p>SDK的目的就是降低耦合，即使SDK内部有某些能力，但是我们也要考虑是否需要开放。</p>\n<h1 id=\"五-写在最后\">五. 写在最后</h1>\n<p>SDK 的开发经验还是很宝贵的，我也从中学习到了很多东西。我也通过这个业务将平时所学到的东西进行了实践。</p>\n"
}