{
    "title": "Vue 源码学习 (1) - 起始篇",
    "excerpt": "一. 写在前面 作为前端开发，Vue 是我日常工作中使用最多的框架，各种特性我都有进行了解。但是对于框架底层的原理却知之甚少，知道数据劫持，但是不知道依赖收集的具体过程。知道 diff 算法，但对 Vue 所做的算法优化不了解。一入门就学习...",
    "updated": "2022-06-26 11:28:17 ",
    "created": "2022-06-26 11:28:17 ",
    "avatar": "https://avatars.githubusercontent.com/u/26271337?v=4",
    "id": 14,
    "content": "<h1 id=\"一-写在前面\">一. 写在前面</h1>\n<p>作为前端开发，<code>Vue</code> 是我日常工作中使用最多的框架，各种特性我都有进行了解。但是对于框架底层的原理却知之甚少，知道数据劫持，但是不知道依赖收集的具体过程。知道 <code>diff</code> 算法，但对 <code>Vue</code> 所做的算法优化不了解。一入门就学习了 <code>Vue</code> 的生命周期，却不了解组件实例化的整个过程。</p>\n<p>总的来说就是似懂非懂，都知道一些，都不深入。因此学习源码，了解 <code>Vue</code> 的整体设计是我的主要目标。也希望通过 <code>Vue</code> 源码的学习能让我在工作中使用 <code>Vue</code> 更加的得心应手。</p>\n<h1 id=\"二-基本介绍\">二. 基本介绍</h1>\n<p><code>Vue</code> 的源码设计的东西太多了，我决定拆分成不同部分去阅读，带有目的去了解。</p>\n<ul>\n<li>源码地址： <a href=\"https://github.com/vuejs/vue\">https://github.com/vuejs/vue</a></li>\n<li>分支： main</li>\n<li>版本： v2.7.0</li>\n</ul>\n<p>这里选择了当前(2022-06)最新版本的代码，当前版本的代码已经全部使用 <code>TypeScript</code> 进行重写，舍弃了之前的 <code>flow</code> 标注，阅读体验还是比较好的。</p>\n<p><code>Vue</code> 的代码在 <code>src</code> 目录下，目录结构为</p>\n<pre><code>src\n├── compiler        # 编译相关 \n├── core            # 核心代码 \n├── platforms       # 多平台支持\n├── server          # 服务端\n├── types           # 类型声明\n├── shared          # 共享工具方法\n├── v3              # v3的特性\n</code></pre>\n<p>看源码的顺序一般从入口文件开始，<code>Vue</code> 作为库，入口文件是它的构建产物，因此我们从打包命令中入手。</p>\n<pre><code class=\"language-shell\">&quot;build&quot;: &quot;node scripts/build.js&quot;,\n</code></pre>\n<p>于是找到 <code>scripts/build.js</code> 文件，然后找到配置文件 <code>scripts/config.js</code></p>\n<pre><code class=\"language-js\">const builds = {\n    // Runtime only (CommonJS). Used by bundlers e.g. Webpack &amp; Browserify\n    &#39;runtime-cjs-dev&#39;: {\n        entry: resolve(&#39;web/entry-runtime.ts&#39;),\n        dest: resolve(&#39;dist/vue.runtime.common.dev.js&#39;),\n        format: &#39;cjs&#39;,\n        env: &#39;development&#39;,\n        banner\n    },\n    &#39;runtime-cjs-prod&#39;: {\n        entry: resolve(&#39;web/entry-runtime.ts&#39;),\n        dest: resolve(&#39;dist/vue.runtime.common.prod.js&#39;),\n        format: &#39;cjs&#39;,\n        env: &#39;production&#39;,\n        ...\n</code></pre>\n<p>从上面的配置中，我们可以看到 <code>Vue</code> 在打包是构建成不同的版本，有支持 <code>CommonJS</code> 规范 <code>cjs</code>,\n也有支持 <code>ESM</code> 的 <code>esm</code>, 也有兼容多格式的 <code>UMD</code>。其中有带 <code>complier</code> 的版本，也有 <code>runtime-only</code> 的版本。</p>\n<h1 id=\"三-入口文件\">三. 入口文件</h1>\n<p>从配置文件中有找到 别名的声明文件 <code>scripts/alias </code></p>\n<pre><code class=\"language-js\">{\n    vue: resolve(&#39;src/platforms/web/entry-runtime-with-compiler&#39;),\n}\n</code></pre>\n<p>也有很多的构建版本以该文件作为入口文件，因此从 <code>src/platforms/web/entry-runtime-with-compiler.ts</code>开始入手。</p>\n<pre><code class=\"language-ts\">import Vue from &#39;./runtime-with-compiler&#39;\nimport * as vca from &#39;v3&#39;\nimport { extend } from &#39;shared/util&#39;\nextend(Vue, vca)\nimport { effect } from &#39;v3/reactivity/effect&#39;\nVue.effect = effect\n\nexport default Vue\n</code></pre>\n<p>忽略新增的 <code>v3</code> 的功能代码，进入 <code>./runtime-with-compiler</code>文件</p>\n<pre><code class=\"language-ts\">const mount = Vue.prototype.$mount\nVue.prototype.$mount = function () {\n    const { render, staticRenderFns } = compileToFunctions(...)\n    options.render = render\n    options.staticRenderFns = staticRenderFns\n}\n</code></pre>\n<p>这个文件的代码很多，但是核心逻辑就是引入了 <code>compileToFunctions</code> 方法, 扩展了 <code>$mount</code> 方法，支持将 <code>options</code> 的 <code>template</code> 转化为 <code>render</code> 函数。根据导入一直寻找，我们最终来到了<code>src/core/index.ts</code></p>\n<pre><code class=\"language-ts\">import Vue from &#39;./instance/index&#39;\ninitGlobalAPI(Vue) // 初始化全局Api\n</code></pre>\n<p>然后在 <code>instance/index</code>文件</p>\n<pre><code class=\"language-ts\">function Vue(options) {\n    if (__DEV__ &amp;&amp; !(this instanceof Vue)) {\n        warn(&#39;Vue is a constructor and should be called with the `new` keyword&#39;)\n    }\n    this._init(options)\n}\ninitMixin(Vue)\nstateMixin(Vue)\neventsMixin(Vue)\nlifecycleMixin(Vue)\nrenderMixin(Vue)\n</code></pre>\n<p>在这里我们知道，<code>Vue</code> 就是一个构造函数，只能通过 <code>new Vue</code> 进行实例化，然后通过不同函数对 <code>prototype</code> 进行扩展实现功能模块化，</p>\n<h1 id=\"四-总结\">四. 总结</h1>\n<p>Vue 的整体逻辑过于庞大，涉及到组件化, 响应式原理，编译等诸多逻辑。因此我会从不同的部分去阅读和解析源码。</p>\n<p>文章链接：TODO</p>\n"
}